commit 1b589974f2a8f8c7926ebd5aa82dd0a520d59646
Author: You-Chi Cheng <ycheng31@iw-k30-4.pace.gatech.edu>
Date:   Sun Aug 12 17:27:01 2012 -0400

    normalize color

diff --git a/VideoFE.h b/VideoFE.h
index 7a7bea3..256250a 100644
--- a/VideoFE.h
+++ b/VideoFE.h
@@ -7441,6 +7441,71 @@ MYRETURN:
 			}
 		}
 	}
+	
+	// Normalize image color by RGB histogram
+	void NormalizeImageRGB(IplImage* pImg, IplImage*& pNewImg, double ptr = 0.01)
+	{
+		int height = pImg->height;
+		int width  = pImg->width;
+		int nC = pImg->nChannels;
+		int depth = pImg->depth;
+		double dPts = (double)(width * height);
+		double dptrnum = dPts * ptr;
+		if(pNewImg != NULL)
+		{
+			cvReleaseImage(&pNewImg);
+		}
+		pNewImg = cvCreateImage(cvSize(width, height), depth, nC);
+		vector< vector<double> > vHist(nC, vector<double>(256,0.0));
+		vector<double> vtr(nC, 255.0);
+		for(int n = 0; n < height; ++n)
+		{
+			for(int m = 0; m < width; ++m)
+			{
+				CvScalar s = cvGet2D(pImg, n, m);
+				for(int c = 0; c < nC; ++c)
+				{
+					int nIndex = (int)float(s.val[c]+0.5);
+					nIndex = (nIndex <0)?0:nIndex;
+					nIndex = (nIndex>255)?255:nIndex;
+					vHist[c][nIndex]++;
+				}
+			}
+		}
+		
+		for(int c = 0; c < nC; ++c)
+		{
+			double dbtmpcb = 0.0;
+			double dbtmptr = 255.0;
+			for(int b = 255; b >=0; b--)
+			{
+				dbtmpcb += vHist[c][b];
+				if(dbtmpcb >= dptrnum)
+				{
+					dbtmptr = (double)b;
+					break;
+				}
+			}
+			vtr[c] = dbtmptr;
+		}
+		
+		for(int n = 0; n < height; ++n)
+		{
+			for(int m = 0; m < width; ++m)
+			{
+				CvScalar s = cvGet2D(pImg, n, m);
+				for(int c = 0; c < nC; ++c)
+				{
+					if(s.val[c] >= vtr[c])
+						s.val[c] = 255.0;
+					else
+						s.val[c] = s.val[c] / vtr[c] * 255;
+				}
+				cvSet2D(pNewImg, n, m, s);
+			}
+		}
+	}
+
 	vector<int> vDimConsidered;
 	int m_nHandModelIndex;
 	int m_nBkGndModelIndex;

commit 2f724e104bcbfa0fa9c124c512564832e0f38bba
Author: You-Chi Cheng <ycheng31@ece.pace.gatech.edu>
Date:   Fri Aug 3 17:41:52 2012 -0400

    08032012 87.43% version on COM

diff --git a/Defs.h b/Defs.h
new file mode 100644
index 0000000..75805c6
--- /dev/null
+++ b/Defs.h
@@ -0,0 +1,240 @@
+#pragma once
+
+#ifndef DEF_H
+#define DEF_H
+
+#include <stdio.h>
+//#include <direct.h>
+
+#include <complex>
+#include <string>
+#include <vector>
+#include <list>
+#include <iostream>
+#include <algorithm>
+#include <cctype>
+#include <fstream>
+#include <limits>
+using namespace std;
+
+#ifdef _MSC_VER
+#include <io.h>
+#include <direct.h>
+#include <hash_map>
+using namespace stdext;
+#define unordered_map hash_map
+#elif defined(__GNUC__)
+#include <tr1/unordered_map>
+using namespace std::tr1;
+#endif
+
+#include "connected.h"
+#include "matrix.h"
+using namespace math;
+
+
+#include <sys/stat.h>
+#include <sys/types.h> 
+#include <float.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+#include "cv.h"
+#include "cxcore.h"
+#include "cvaux.h"
+#include "highgui.h"
+#include "ml.h"
+using namespace cv;
+
+//#ifdef _MSC_VER
+//#include <crtdbg.h>  
+////#define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
+//#ifdef _DEBUG
+////#define CRTDBG_MAP_ALLOC
+////#define new DEBUG_NEW
+////#undef THIS_FILE
+////static char THIS_FILE[] = __FILE__;
+//#endif
+//#endif
+
+#define MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN 15
+#define PI 3.14159265358979323846264338327950288
+#define MY_MAX_DOUBLE 1.7976931348623158e+308
+
+// From HTK
+#define LZERO  (-1.0E10)   /* ~log(0) */
+#define LSMALL (-0.5E10)   /* log values < LSMALL are set to LZERO */
+#define DIAGONAL
+#define LOGHALF -0.69314718055994530941723212145818
+#define TWOPI 6.28318530717958647692528676655900576
+#define LOGTWOPI 1.8378770664093454835606594728112
+#define LOGLOGTWOPI 0.60861113726210809872881467715665
+static double minLogExp = -log(-LZERO);
+
+#ifndef DWORD
+typedef unsigned long       DWORD;
+#endif
+
+#ifndef HRESULT
+typedef long       HRESULT;
+#define S_OK                             0L
+#define S_FALSE                          1L
+#define ERROR_OUT_OF_PAPER               28L
+#define ERROR_OPEN_FAILED                110L
+#define ERROR_INVALID_ADDRESS            487L
+#define ERROR_INVALID_INDEX              1413L
+#define ERROR_INVALID_DATA		 0x8007000DL
+#define ERROR_EMPTY                      4306L
+#define E_POINTER                        0x80004003L
+#endif
+
+#ifdef _DEBUG
+   #define DEBUG_CLIENTBLOCK   new( _CLIENT_BLOCK, __FILE__, __LINE__)
+#else
+   #define DEBUG_CLIENTBLOCK
+#endif
+
+
+#ifndef isnan
+inline bool Myisnan(double x) {
+	return x != x;
+}
+#endif
+
+#ifndef isinf
+inline bool Myisinf(double x) {	
+	return numeric_limits<double>::has_infinity && x == numeric_limits<double>::infinity();
+}
+#endif
+
+#ifndef FENode
+struct FENode
+{
+	vector<IplImage*> vpImgs;
+	string szOutFeatureFile;
+	string szOutFeatureFile_uhalf;
+	string szOutFeatureFile_lhalf;
+	string szErrLog;
+	string szMLFName;
+	string szLabelName;
+	string szKeyName;
+	bool IsCreated;
+};
+#endif
+
+#ifndef DoublePoint
+struct DoublePoint
+{
+	double x;
+	double y;
+}typedef DoublePoint;
+#endif
+#ifndef VideoNode
+struct VideoNode
+{
+	int nStart;
+	int nStop;
+	string szName;
+}typedef VideoNode;
+#endif
+
+// For sorting
+struct LessDereference {
+	template <class T>
+	bool operator()(const T * lhs, const T * rhs) const {
+	return *lhs > *rhs;
+	}
+};
+template<class T> struct index_cmp {
+	index_cmp(const T arr) : arr(arr) {}
+	bool operator()(const size_t a, const size_t b) const
+	{ return arr[a] > arr[b]; }
+	const T arr;
+};
+template<class T> struct index_cmp_ascend {
+	index_cmp_ascend(const T arr) : arr(arr) {}
+	bool operator()(const size_t a, const size_t b) const
+	{ return arr[a] < arr[b]; }
+	const T arr;
+};
+
+
+// For HMM stuff
+class Mixture
+{
+public:
+	Mixture()
+	{
+		m_dbWeight = 0.0;
+		m_dbgconst = 0.0;
+	}
+	double m_dbWeight;
+	vector<double> m_vMean;
+	vector<double> m_vDiagVar;
+	double m_dbgconst;
+};
+
+class State
+{
+public:
+	State()
+	{
+		m_nNumMixs = 0;
+	}
+	int m_nNumMixs;
+	vector<Mixture> m_Mixtures;
+};
+
+class Model
+{
+public:
+	Model()
+	{
+		m_nNumStates = 0;
+	}
+	string m_szName;
+	int m_nNumStates;
+	vector<double> m_vPis;
+	vector< vector<double> > m_vvTransp;
+	vector<State> m_States;
+};
+class GaussianNode
+{
+
+public:
+
+	GaussianNode()
+	{
+		m_nPrevClosestMix = 0;
+	}
+	void SetDimMix(int nDim, int nMixs)
+	{
+		m_vdbWeight.resize(nMixs, 1.0/(double)nMixs);
+		m_vvdbMean.resize(nMixs);
+		m_vvdbDiagvar.resize(nMixs);
+		for(int n = 0; n < nMixs; n++)
+		{
+			m_vvdbMean[n].resize(nDim, 0.0);
+			m_vvdbDiagvar[n].resize(nDim, 0.0);
+		}
+	}
+	void Mixup(int nNexMixs)
+	{
+		int nCurrMixSize = (int)m_vdbWeight.size();
+		m_vdbWeight.resize(nNexMixs);
+		m_vvdbMean.resize(nNexMixs);
+		m_vvdbDiagvar.resize(nNexMixs);
+		for(int n = nCurrMixSize; n < nNexMixs; n++)
+		{
+			m_vvdbMean[n].resize(m_vvdbMean[0].size(), 0.0);
+			m_vvdbDiagvar[n].resize(m_vvdbMean[0].size(), 0.0);
+		}
+	}
+	vector<double> m_vdbWeight;
+	vector< vector<double> > m_vvdbMean;
+	vector< vector<double> > m_vvdbDiagvar;
+	int m_nPrevClosestMix;
+};
+
+#endif
diff --git a/ExtLowLevelImgFeature.h b/ExtLowLevelImgFeature.h
new file mode 100644
index 0000000..5b245e2
--- /dev/null
+++ b/ExtLowLevelImgFeature.h
@@ -0,0 +1,734 @@
+#pragma once
+#ifndef EXTLOWLEVELIMGFEATURE_H
+#define EXTLOWLEVELIMGFEATURE_H
+
+#include "Defs.h"
+#include "LocalFeatuers.h"
+
+
+class ExtLowLevelImgFeature
+{
+public:
+	ExtLowLevelImgFeature(void)
+	{
+	}
+
+	~ExtLowLevelImgFeature(void)
+	{
+	}
+	static int ExtColorFeatures(IplImage*& pimg, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		if(pimg == NULL)
+		{
+			cerr<<"No image is loaded for feature extraction\n";
+			return 0;
+		}
+		cv::Mat img(pimg);
+		cv::Mat fimg;
+		img.convertTo(fimg, CV_32FC3);
+		//===========================================================================================//
+		// 08/01/2011, prepare for color histogram, You-Chi
+		//===========================================================================================//
+		bool bColorHist = false;
+		const int channels[] = {0, 1, 2};
+		const cv::Mat defaultmat = cv::Mat();
+		int ndims = 3;
+		const int histSize[] = {4, 8, 8};
+		float rrange[] = {0,256};
+		float grange[] = {0,256};
+		float brange[] = {0,256};
+		//const int histSize[] = {16, 4, 4};
+		const float* ranges[] = {brange, grange, rrange};
+		//float hrange[] = {0,180};
+		//float srange[] = {0,1};
+		//float vrange[] = {0,256};
+		//const float* ranges[] = {hrange, srange, vrange};
+		//===========================================================================================//
+		matrix<double> UT30, mu;
+		if(bColorHist)
+		{
+#ifdef _MSC_VER
+			LoadMyBinMat("C:\\CollectedData\\Sample004\\Sample004\\Individual_RGB\\FEList_Covar_EigVecs_30.dat", UT30);
+			LoadMyBinMat("C:\\CollectedData\\Sample004\\Sample004\\Individual_RGB\\FEList_Mean_debug.dat", mu);
+#else
+        	        LoadMyBinMat("/nv/pec1/ycheng31/local/include/AdjustGMMNew/FEList_Covar_EigVecs_30.dat", UT30);
+                	LoadMyBinMat("/nv/pec1/ycheng31/local/include/AdjustGMMNew/FEList_Mean_debug.dat", mu);		
+#endif
+		}
+		double dbNormalizedFactor = 256.0 / (double)(BLKSIZE * BLKSIZE);
+		for(int x = 0; x < img.cols / BLKSIZE; x++)
+		{
+			cv::Scalar fmeanxy, stddevxy;
+			cv::Scalar fmeanxyhsv, stddevxyhsv;
+			cv::Scalar fmeanxyx, stddevxyx;
+			cv::Scalar fmeanxyy, stddevxyy;
+			cv::Mat colx = fimg/*fres*/.colRange(x*BLKSIZE, (x+1)*BLKSIZE/*min((x+1)*8, img.cols - 1)*/); 
+			for(int y = 0; y < img.rows / BLKSIZE; y++)
+			{	
+				cv::Mat sub = colx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+				cv::Mat subhsv;
+				//sub.convertTo(subf, CV_32F);
+				//cv::cvtColor(sub, subhsv, CV_BGR2HSV);
+				//cv::Scalar ss = cv::mean(subhsv);
+				//cv::Scalar ss0 = cv::mean(sub);
+				//===========================================================================================//
+				// 08/01/2011, compute color histogram instead, You-Chi
+				//===========================================================================================//
+				if(bColorHist)
+				{
+					// Let's calculate color histogram instead
+					cv::MatND hist;
+					cv::calcHist(&sub, 1, channels, defaultmat, hist, ndims, histSize, ranges, true, false);
+					vector<double> vdbTemp(4*8*8, 0.0);
+					size_t ii = 0;
+					double dbCount = 0;
+					for(size_t i1 = 0; i1 < 4; ++i1)
+					{
+						for(size_t i2 = 0; i2 < 8; ++i2)
+						{
+							for(size_t i3 = 0; i3 < 8; ++i3)
+							{
+								//SparseMat::
+								double val = (double) hist.at<float>(i1, i2, i3);
+								dbCount += val;
+								vdbTemp[ii] = val;
+								++ii;
+							}
+						}
+					}
+					matrix<double> mvec;
+					mvec.SetSize(vdbTemp.size(), 1);
+					for(size_t ii = 0; ii < vdbTemp.size(); ++ii)
+					{
+						mvec(ii, 0) = vdbTemp[ii] * dbNormalizedFactor - mu(ii, 0);
+					}
+					matrix<double> mvec30 = UT30 * mvec;
+					vector<double> vdbTemp30(mvec30.RowNo(), 0.0);
+					for(size_t ii = 0; ii < mvec30.RowNo(); ++ii)
+					{
+						vdbTemp30[ii] = mvec30(ii, 0);
+					}
+					vvFeatures.push_back(vdbTemp30);
+				}
+				else
+				{
+					// Old version
+					cv::Mat sub8bits;
+					sub.convertTo(sub8bits, CV_8UC3);
+					cv::Mat subhsv;
+					cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+					cv::meanStdDev(sub, fmeanxy, stddevxy);
+					cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+
+					BlockFeatures blk;
+					blk.cvmat2vec(sub, blk.m_vvData);
+					blk.extractBlockMean();
+					blk.extractBlockVars();
+
+					//double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+					//double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+					double dbBMean = fmeanxy.val[0];
+					double dbGMean = fmeanxy.val[1];
+					double dbRMean = fmeanxy.val[2];
+					//double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+					//double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+					//double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+					//double dbVMean = fmeanxyhsv.val[2];
+					//double dbSMean = fmeanxyhsv.val[1];
+					//double dbHMean = fmeanxyhsv.val[0];
+					vector<double> vdbTemp;
+					//vdbTemp.push_back(dbAvgStdev);
+					//vdbTemp.push_back(dbIMean);
+					vdbTemp.push_back(dbBMean);
+					vdbTemp.push_back(dbGMean);
+					vdbTemp.push_back(dbRMean);
+					//double dbFE1 = (-0.5668) * (dbBMean - 93.72874) + (-0.5715) * (dbGMean - 96.96279) + (-0.5934) * (dbRMean - 100.3968);
+					//double dbFE2 = (0.5921) * (dbBMean - 93.72874) + (0.2182) * (dbGMean - 96.96279) + (-0.7758) * (dbRMean - 100.3968);
+					//double dbFE3 = (0.5729) * (dbBMean - 93.72874) + (-0.7910) * (dbGMean - 96.96279) + (0.2147) * (dbRMean - 100.3968);
+					
+					//vdbTemp.push_back(dbFE1);
+					//vdbTemp.push_back(dbFE2);
+					//vdbTemp.push_back(dbFE3);					
+					//vdbTemp.push_back(dbExBMean);
+					//vdbTemp.push_back(dbExGMean);
+					//vdbTemp.push_back(dbExRMean);
+					//vdbTemp.push_back(dbVMean);
+					//vdbTemp.push_back(dbSMean);
+					//vdbTemp.push_back(dbHMean);
+					vvFeatures.push_back(vdbTemp);
+				}
+			}
+		}
+		int yrange = img.rows / BLKSIZE;
+		return yrange;
+	}
+
+	static int ExtColorFeaturesDiag(IplImage*& pimg, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		if(pimg == NULL)
+		{
+			cerr<<"No image is loaded for feature extraction\n";
+			return 0;
+		}
+		cv::Mat img(pimg);
+		cv::Mat fimg;
+		img.convertTo(fimg, CV_32FC3);
+		//===========================================================================================//
+		// 08/01/2011, prepare for color histogram, You-Chi
+		//===========================================================================================//
+		bool bColorHist = false;
+		const int channels[] = {0, 1, 2};
+		const cv::Mat defaultmat = cv::Mat();
+		int ndims = 3;
+		const int histSize[] = {8, 8, 8};
+		float rrange[] = {0,256};
+		float grange[] = {0,256};
+		float brange[] = {0,256};
+		const float* ranges[] = {brange, grange, rrange};
+
+		//===========================================================================================//
+		for(int x = 0; x < img.cols / BLKSIZE; x++)
+		{
+			cv::Scalar fmeanxy, stddevxy;
+			cv::Scalar fmeanxyhsv, stddevxyhsv;
+			cv::Scalar fmeanxyx, stddevxyx;
+			cv::Scalar fmeanxyy, stddevxyy;
+			cv::Mat colx = fimg/*fres*/.colRange(x*BLKSIZE, (x+1)*BLKSIZE/*min((x+1)*8, img.cols - 1)*/); 
+			for(int y = 0; y < img.rows / BLKSIZE; y++)
+			{	
+				cv::Mat sub = colx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+				//===========================================================================================//
+				// 08/01/2011, compute color histogram instead, You-Chi
+				//===========================================================================================//
+				if(bColorHist)
+				{
+					// Let's calculate color histogram instead
+					cv::MatND hist;
+					cv::calcHist(&sub, 1, channels, defaultmat, hist, ndims, histSize, ranges, true, false);
+					vector<double> vdbTemp(8*8*8, 0.0);
+					size_t ii = 0;
+					double dbCount = 0;
+					for(size_t i1 = 0; i1 < 8; ++i1)
+					{
+						for(size_t i2 = 0; i2 < 8; ++i2)
+						{
+							for(size_t i3 = 0; i3 < 8; ++i3)
+							{
+								//SparseMat::
+								double val = (double) hist.at<float>(i1, i2, i3);
+								dbCount += val;
+								vdbTemp[ii] = val;
+								++ii;
+								
+							}
+						}
+					}
+					vvFeatures.push_back(vdbTemp);
+				}
+				else
+				{
+					// Old version
+					cv::Mat sub8bits;
+					sub.convertTo(sub8bits, CV_8UC3);
+					cv::Mat subhsv;
+					cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+					cv::meanStdDev(sub, fmeanxy, stddevxy);
+					cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+
+					BlockFeatures blk;
+					blk.cvmat2vec(sub, blk.m_vvData);
+					blk.extractBlockMean();
+					blk.extractBlockVars();
+
+					//double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+					//double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+					double dbBMean = fmeanxy.val[0];
+					double dbGMean = fmeanxy.val[1];
+					double dbRMean = fmeanxy.val[2];
+					double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+					double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+					double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+					//double dbVMean = fmeanxyhsv.val[2];
+					//double dbSMean = fmeanxyhsv.val[1];
+					//double dbHMean = fmeanxyhsv.val[0];
+					vector<double> vdbTemp;
+					//vdbTemp.push_back(dbAvgStdev);
+					//vdbTemp.push_back(dbIMean);
+					vdbTemp.push_back(dbBMean);
+					vdbTemp.push_back(dbGMean);
+					vdbTemp.push_back(dbRMean);
+					//vdbTemp.push_back(dbExBMean);
+					//vdbTemp.push_back(dbExGMean);
+					//vdbTemp.push_back(dbExRMean);
+					//vdbTemp.push_back(dbVMean);
+					//vdbTemp.push_back(dbSMean);
+					//vdbTemp.push_back(dbHMean);
+					vvFeatures.push_back(vdbTemp);
+				}
+			}
+		}
+		int yrange = img.rows / BLKSIZE;
+		return yrange;
+	}
+
+	
+	static int ExtColorFeatures_BS0(IplImage*& pimg, vector< vector<double> >& vvFeatures, int BLKSIZE, IplImage*& pRefImg, vector< vector<double> >& vvCorrs)
+	{
+		if(pimg == NULL)
+		{
+			cerr<<"No image is loaded for feature extraction\n";
+			return 0;
+		}
+		cv::Mat img(pimg);
+		cv::Mat refimg(pRefImg);
+		cv::Mat fimg;
+		img.convertTo(fimg, CV_32FC3);
+		//===========================================================================================//
+		// 08/01/2011, prepare for color histogram, You-Chi
+		//===========================================================================================//
+		bool bColorHist = false;
+		const int channels[] = {0, 1, 2};
+		const cv::Mat defaultmat = cv::Mat();
+		int ndims = 3;
+		const int histSize[] = {4, 8, 8};
+		float rrange[] = {0,256};
+		float grange[] = {0,256};
+		float brange[] = {0,256};
+		const float* ranges[] = {brange, grange, rrange};
+		//const int histSize[] = {16, 4, 4};
+		//float hrange[] = {0,180};
+		//float srange[] = {0,1};
+		//float vrange[] = {0,256};
+		//const float* ranges[] = {hrange, srange, vrange};
+		matrix<double> UT30, mu;
+		if(bColorHist)
+		{
+#ifdef _MSC_VER
+			LoadMyBinMat("C:\\CollectedData\\Sample004\\Sample004\\Individual_RGB\\FEList_Covar_EigVecs_30.dat", UT30);
+			LoadMyBinMat("C:\\CollectedData\\Sample004\\Sample004\\Individual_RGB\\FEList_Mean_debug.dat", mu);
+#else
+        	        LoadMyBinMat("/nv/pec1/ycheng31/local/include/AdjustGMMNew/FEList_Covar_EigVecs_30.dat", UT30);
+                	LoadMyBinMat("/nv/pec1/ycheng31/local/include/AdjustGMMNew/FEList_Mean_debug.dat", mu);		
+#endif
+		}
+		double dbNormalizedFactor = 256.0 / (double)(BLKSIZE * BLKSIZE);
+		//===========================================================================================//
+		for(int x = 0; x < img.cols / BLKSIZE; x++)
+		{
+			cv::Scalar fmeanxy, stddevxy;
+			cv::Scalar fmeanxyhsv, stddevxyhsv;
+			cv::Scalar fmeanxyx, stddevxyx;
+			cv::Scalar fmeanxyy, stddevxyy;
+			cv::Mat colx = fimg/*fres*/.colRange(x*BLKSIZE, (x+1)*BLKSIZE/*min((x+1)*8, img.cols - 1)*/); 
+			cv::Mat refcolx = refimg/*fres*/.colRange(x*BLKSIZE, (x+1)*BLKSIZE/*min((x+1)*8, img.cols - 1)*/); 
+			for(int y = 0; y < img.rows / BLKSIZE; y++)
+			{	
+				cv::Mat sub = colx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+				cv::Mat refsub = refcolx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+				//===========================================================================================//
+				// 08/01/2011, compute color histogram instead, You-Chi
+				//===========================================================================================//
+				// Old version
+				cv::Mat sub8bits;
+				sub.convertTo(sub8bits, CV_8UC3);
+				cv::Mat subhsv;
+				//cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+				cv::meanStdDev(sub, fmeanxy, stddevxy);
+				//cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+
+				BlockFeatures blk;
+				blk.cvmat2vec(sub, blk.m_vvData);
+				blk.extractBlockMean();
+				blk.extractBlockVars();
+
+				BlockFeatures refblk;
+				refblk.cvmat2vec(refsub, refblk.m_vvData);
+				refblk.extractBlockMean();
+				refblk.extractBlockVars();
+				blk.compBSCorrelation(refblk);
+				
+				vvCorrs.push_back(blk.m_vBSCorr);
+				if(bColorHist)
+				{
+					// Let's calculate color histogram instead
+					cv::MatND hist;
+					cv::calcHist(&sub, 1, channels, defaultmat, hist, ndims, histSize, ranges, true, false);
+					vector<double> vdbTemp(4*8*8, 0.0);
+					size_t ii = 0;
+					double dbCount = 0;
+					for(size_t i1 = 0; i1 < 4; ++i1)
+					{
+						for(size_t i2 = 0; i2 < 8; ++i2)
+						{
+							for(size_t i3 = 0; i3 < 8; ++i3)
+							{
+								//SparseMat::
+								double val = (double) hist.at<float>(i1, i2, i3);
+								dbCount += val;
+								vdbTemp[ii] = val;
+								++ii;
+								
+							}
+						}
+					}
+					matrix<double> mvec;
+					mvec.SetSize(vdbTemp.size(), 1);
+					for(size_t ii = 0; ii < vdbTemp.size(); ++ii)
+					{
+						mvec(ii, 0) = vdbTemp[ii] * dbNormalizedFactor - mu(ii, 0);
+					}
+					matrix<double> mvec30 = UT30 * mvec;
+					vector<double> vdbTemp30(mvec30.RowNo(), 0.0);
+					for(size_t ii = 0; ii < mvec30.RowNo(); ++ii)
+					{
+						vdbTemp30[ii] = mvec30(ii, 0);
+					}
+					vvFeatures.push_back(vdbTemp30);
+				}
+				else
+				{
+					//double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+					//double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+					double dbBMean = fmeanxy.val[0];
+					double dbGMean = fmeanxy.val[1];
+					double dbRMean = fmeanxy.val[2];
+					//double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+					//double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+					//double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+					//double dbVMean = fmeanxyhsv.val[2];
+					//double dbSMean = fmeanxyhsv.val[1];
+					//double dbHMean = fmeanxyhsv.val[0];
+					vector<double> vdbTemp;
+					//vdbTemp.push_back(dbAvgStdev);
+					//vdbTemp.push_back(dbIMean);
+					//double dbFE1 = (-0.5668) * (dbBMean - 93.72874) + (-0.5715) * (dbGMean - 96.96279) + (-0.5934) * (dbRMean - 100.3968);
+					//double dbFE2 = (0.5921) * (dbBMean - 93.72874) + (0.2182) * (dbGMean - 96.96279) + (-0.7758) * (dbRMean - 100.3968);
+					//double dbFE3 = (0.5729) * (dbBMean - 93.72874) + (-0.7910) * (dbGMean - 96.96279) + (0.2147) * (dbRMean - 100.3968);
+					//vdbTemp.push_back(dbFE1);
+					//vdbTemp.push_back(dbFE2);
+					//vdbTemp.push_back(dbFE3);					
+					vdbTemp.push_back(dbBMean);
+					vdbTemp.push_back(dbGMean);
+					vdbTemp.push_back(dbRMean);
+					//vdbTemp.push_back(dbExBMean);
+					//vdbTemp.push_back(dbExGMean);
+					//vdbTemp.push_back(dbExRMean);
+					//vdbTemp.push_back(dbVMean);
+					//vdbTemp.push_back(dbSMean);
+					//vdbTemp.push_back(dbHMean);
+					vvFeatures.push_back(vdbTemp);
+				}
+			}
+		}
+		int yrange = img.rows / BLKSIZE;
+		return yrange;
+	}
+
+
+
+
+	static int ExtColorFeatureRGBOnly(IplImage*& pimg, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		if(pimg == NULL)
+		{
+			cerr<<"No image is loaded for feature extraction\n";
+			return 0;
+		}
+		cv::Mat img(pimg);
+		cv::Mat fimg;
+		img.convertTo(fimg, CV_32FC3);
+
+		for(int x = 0; x < img.cols / BLKSIZE; x++)
+		{
+			cv::Scalar fmeanxy, stddevxy;
+			cv::Scalar fmeanxyhsv, stddevxyhsv;
+			cv::Scalar fmeanxyx, stddevxyx;
+			cv::Scalar fmeanxyy, stddevxyy;
+			cv::Mat colx = fimg/*fres*/.colRange(x*BLKSIZE, (x+1)*BLKSIZE/*min((x+1)*8, img.cols - 1)*/); 
+			for(int y = 0; y < img.rows / BLKSIZE; y++)
+			{	
+				cv::Mat sub = colx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+				cv::Mat sub8bits;
+				sub.convertTo(sub8bits, CV_8UC3);
+				cv::Mat subhsv;
+				//cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+				cv::meanStdDev(sub, fmeanxy, stddevxy);
+				//cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+				//double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+				//double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+				double dbBMean = fmeanxy.val[0];
+				double dbGMean = fmeanxy.val[1];
+				double dbRMean = fmeanxy.val[2];
+				//double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+				//double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+				//double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+				//double dbVMean = fmeanxyhsv.val[2];
+				//double dbSMean = fmeanxyhsv.val[1];
+				//double dbHMean = fmeanxyhsv.val[0];
+				vector<double> vdbTemp;
+				//vdbTemp.push_back(dbAvgStdev);
+				//vdbTemp.push_back(dbIMean);
+				vdbTemp.push_back(dbBMean);
+				vdbTemp.push_back(dbGMean);
+				vdbTemp.push_back(dbRMean);
+				//vdbTemp.push_back(dbExBMean);
+				//vdbTemp.push_back(dbExGMean);
+				//vdbTemp.push_back(dbExRMean);
+				//vdbTemp.push_back(dbVMean);
+				//vdbTemp.push_back(dbSMean);
+				//vdbTemp.push_back(dbHMean);
+				vvFeatures.push_back(vdbTemp);
+			}
+		}
+		int yrange = img.rows / BLKSIZE;
+		fimg.release();
+		return yrange;
+	}
+
+	static int ExtColorFeatureEXRGBHSV(IplImage*& pimg, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		if(pimg == NULL)
+		{
+			cerr<<"No image is loaded for feature extraction\n";
+			return 0;
+		}
+		cv::Mat img(pimg);
+		cv::Mat fimg;
+		img.convertTo(fimg, CV_32FC3);
+
+		for(int x = 0; x < img.cols / BLKSIZE; x++)
+		{
+			cv::Scalar fmeanxy, stddevxy;
+			cv::Scalar fmeanxyhsv, stddevxyhsv;
+			cv::Scalar fmeanxyx, stddevxyx;
+			cv::Scalar fmeanxyy, stddevxyy;
+			cv::Mat colx = fimg/*fres*/.colRange(x*BLKSIZE, (x+1)*BLKSIZE/*min((x+1)*8, img.cols - 1)*/); 
+			for(int y = 0; y < img.rows / BLKSIZE; y++)
+			{	
+				cv::Mat sub = colx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+				cv::Mat sub8bits;
+				sub.convertTo(sub8bits, CV_8UC3);
+				cv::Mat subhsv;
+				//cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+				cv::meanStdDev(sub, fmeanxy, stddevxy);
+				//cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+				//double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+				//double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+				//double dbBMean = fmeanxy.val[0];
+				//double dbGMean = fmeanxy.val[1];
+				//double dbRMean = fmeanxy.val[2];
+				double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+				double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+				double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+				double dbVMean = fmeanxyhsv.val[2];
+				double dbSMean = fmeanxyhsv.val[1];
+				double dbHMean = fmeanxyhsv.val[0];
+				vector<double> vdbTemp;
+				//vdbTemp.push_back(dbAvgStdev);
+				//vdbTemp.push_back(dbIMean);
+				//vdbTemp.push_back(dbBMean);
+				//vdbTemp.push_back(dbGMean);
+				//vdbTemp.push_back(dbRMean);
+				vdbTemp.push_back(dbExBMean);
+				vdbTemp.push_back(dbExGMean);
+				vdbTemp.push_back(dbExRMean);
+				vdbTemp.push_back(dbVMean);
+				vdbTemp.push_back(dbSMean);
+				vdbTemp.push_back(dbHMean);
+				vvFeatures.push_back(vdbTemp);
+			}
+		}
+		int yrange = img.rows / BLKSIZE;
+		return yrange;
+	}
+
+
+
+
+	static int ExtColorFeatures(string szFileName, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		IplImage* pimg;
+	#ifdef LPF
+		CvMat* hlpf = cvCreateMat(3, 3, CV_32FC1);
+		cvSetReal2D(hlpf, 0, 0, 0.1);
+		cvSetReal2D(hlpf, 0, 1, 0.1);
+		cvSetReal2D(hlpf, 0, 2, 0.1);
+		cvSetReal2D(hlpf, 1, 0, 0.1);
+		cvSetReal2D(hlpf, 1, 1, 0.8);
+		cvSetReal2D(hlpf, 1, 2, 0.1);
+		cvSetReal2D(hlpf, 2, 0, 0.1);
+		cvSetReal2D(hlpf, 2, 1, 0.1);
+		cvSetReal2D(hlpf, 2, 2, 0.1);
+		IplImage* pimg0 = cvLoadImage(szFileName.c_str());
+		IplImage* pimg1 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		IplImage* pimg2 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		pimg = cvCreateImage(cvSize(pimg0->width,pimg0->height), pimg0->depth, pimg0->nChannels);
+		cvConvert(pimg0, pimg1);
+		cvFilter2D(pimg1, pimg2, hlpf);
+		cvConvert(pimg2, pimg);
+		cvReleaseImage(&pimg0);
+		cvReleaseImage(&pimg1);
+		cvReleaseImage(&pimg2);
+		cvReleaseMat(&hlpf);
+	#else
+		pimg = cvLoadImage(szFileName.c_str());
+	#endif
+
+		int yrange = ExtColorFeatures(pimg, vvFeatures, BLKSIZE);
+		cvReleaseImage(&pimg);
+		return yrange;
+	}
+
+	static int ExtColorFeatures_BS0(string szFileName,  vector< vector<double> >& vvFeatures, int BLKSIZE, IplImage*& pref, vector< vector<double> >& vvCorrs)
+	{
+		IplImage* pimg;
+	#ifdef LPF
+		CvMat* hlpf = cvCreateMat(3, 3, CV_32FC1);
+		cvSetReal2D(hlpf, 0, 0, 0.1);
+		cvSetReal2D(hlpf, 0, 1, 0.1);
+		cvSetReal2D(hlpf, 0, 2, 0.1);
+		cvSetReal2D(hlpf, 1, 0, 0.1);
+		cvSetReal2D(hlpf, 1, 1, 0.8);
+		cvSetReal2D(hlpf, 1, 2, 0.1);
+		cvSetReal2D(hlpf, 2, 0, 0.1);
+		cvSetReal2D(hlpf, 2, 1, 0.1);
+		cvSetReal2D(hlpf, 2, 2, 0.1);
+		IplImage* pimg0 = cvLoadImage(szFileName.c_str());
+		IplImage* pimg1 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		IplImage* pimg2 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		pimg = cvCreateImage(cvSize(pimg0->width,pimg0->height), pimg0->depth, pimg0->nChannels);
+		cvConvert(pimg0, pimg1);
+		cvFilter2D(pimg1, pimg2, hlpf);
+		cvConvert(pimg2, pimg);
+		cvReleaseImage(&pimg0);
+		cvReleaseImage(&pimg1);
+		cvReleaseImage(&pimg2);
+		cvReleaseMat(&hlpf);
+	#else
+		pimg = cvLoadImage(szFileName.c_str());
+	#endif
+		//ExtColorFeatures_BS0(IplImage*& pimg, vector< vector<double> >& vvFeatures, int BLKSIZE, IplImage*& pRefImg, vector< vector<double> >& vvCorrs)
+		int yrange = ExtColorFeatures_BS0(pimg, vvFeatures, BLKSIZE, pref, vvCorrs);
+		cvReleaseImage(&pimg);
+		return yrange;
+	}
+
+	static int ExtColorFeatureRGBOnly(string szFileName, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		IplImage* pimg;
+	#ifdef LPF
+		CvMat* hlpf = cvCreateMat(3, 3, CV_32FC1);
+		cvSetReal2D(hlpf, 0, 0, 0.1);
+		cvSetReal2D(hlpf, 0, 1, 0.1);
+		cvSetReal2D(hlpf, 0, 2, 0.1);
+		cvSetReal2D(hlpf, 1, 0, 0.1);
+		cvSetReal2D(hlpf, 1, 1, 0.8);
+		cvSetReal2D(hlpf, 1, 2, 0.1);
+		cvSetReal2D(hlpf, 2, 0, 0.1);
+		cvSetReal2D(hlpf, 2, 1, 0.1);
+		cvSetReal2D(hlpf, 2, 2, 0.1);
+		IplImage* pimg0 = cvLoadImage(szFileName.c_str());
+		IplImage* pimg1 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		IplImage* pimg2 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		pimg = cvCreateImage(cvSize(pimg0->width,pimg0->height), pimg0->depth, pimg0->nChannels);
+		cvConvert(pimg0, pimg1);
+		cvFilter2D(pimg1, pimg2, hlpf);
+		cvConvert(pimg2, pimg);
+		cvReleaseImage(&pimg0);
+		cvReleaseImage(&pimg1);
+		cvReleaseImage(&pimg2);
+		cvReleaseMat(&hlpf);
+	#else
+		pimg = cvLoadImage(szFileName.c_str());
+	#endif
+		int yrange = ExtColorFeatureRGBOnly(pimg, vvFeatures, BLKSIZE);
+		cvReleaseImage(&pimg);
+		return yrange;
+	}
+
+	static int ExtColorFeatureEXRGBHSV(string szFileName, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		IplImage* pimg;
+	#ifdef LPF
+		CvMat* hlpf = cvCreateMat(3, 3, CV_32FC1);
+		cvSetReal2D(hlpf, 0, 0, 0.1);
+		cvSetReal2D(hlpf, 0, 1, 0.1);
+		cvSetReal2D(hlpf, 0, 2, 0.1);
+		cvSetReal2D(hlpf, 1, 0, 0.1);
+		cvSetReal2D(hlpf, 1, 1, 0.8);
+		cvSetReal2D(hlpf, 1, 2, 0.1);
+		cvSetReal2D(hlpf, 2, 0, 0.1);
+		cvSetReal2D(hlpf, 2, 1, 0.1);
+		cvSetReal2D(hlpf, 2, 2, 0.1);
+		IplImage* pimg0 = cvLoadImage(szFileName.c_str());
+		IplImage* pimg1 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		IplImage* pimg2 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+		pimg = cvCreateImage(cvSize(pimg0->width,pimg0->height), pimg0->depth, pimg0->nChannels);
+		cvConvert(pimg0, pimg1);
+		cvFilter2D(pimg1, pimg2, hlpf);
+		cvConvert(pimg2, pimg);
+		cvReleaseImage(&pimg0);
+		cvReleaseImage(&pimg1);
+		cvReleaseImage(&pimg2);
+		cvReleaseMat(&hlpf);
+	#else
+		pimg = cvLoadImage(szFileName.c_str());
+	#endif
+		int yrange = ExtColorFeatureEXRGBHSV(pimg, vvFeatures, BLKSIZE);
+		cvReleaseImage(&pimg);
+		return yrange;
+	}
+	static void LoadMyBinMat(string szPathName, matrix<double>& mat)
+	{
+		FILE* f = NULL;
+		int n1 = 0;
+		int n2 = 0;
+		double dbBuf = 0.0;
+		f = fopen(szPathName.c_str(), "rb");
+		if(!f)
+		{
+			cerr<<"Cannot open "<<szPathName<<endl;
+			return;
+		}
+		fread(&n1, sizeof(int), 1, f);
+		fread(&n2, sizeof(int), 1, f);
+		mat.SetSize(n1, n2);
+		for(int i1 = 0; i1 < n1; ++i1)
+		{
+			for(int i2 = 0; i2 < n2; ++i2)
+			{
+				fread(&dbBuf, sizeof(double), 1, f);
+				mat(i1, i2) = dbBuf;
+			}
+		}
+		fclose(f);
+	}
+	
+	static void WriteMyBinMat(string szPathName, matrix<double>& mat)
+	{
+		FILE* f = NULL;
+		int n1 = (int)mat.RowNo();
+		int n2 = (int)mat.ColNo();
+		double dbBuf = 0.0;
+		f = fopen(szPathName.c_str(), "wb");
+		if(!f)
+		{
+			cerr<<"Cannot open "<<szPathName<<endl;
+			return;
+		}
+		fwrite(&n1, sizeof(int), 1, f);
+		fwrite(&n2, sizeof(int), 1, f);
+		for(int i1 = 0; i1 < n1; ++i1)
+		{
+			for(int i2 = 0; i2 < n2; ++i2)
+			{
+				dbBuf = mat(i1, i2);
+				fwrite(&dbBuf, sizeof(double), 1, f);
+			}
+		}
+		fclose(f);
+	}
+};
+#endif
+
+
diff --git a/GMM.h b/GMM.h
new file mode 100644
index 0000000..99a2a19
--- /dev/null
+++ b/GMM.h
@@ -0,0 +1,705 @@
+#pragma once
+
+#include "Defs.h"
+
+
+// Skin color GMM class
+class GMM
+{
+//friend class GMMHyperParam;
+public:
+	GMM()
+	{
+		m_nVecSize = 0;
+		m_nMixes = 0;
+		m_szCovType = "diagonal";
+		//m_ptheta = NULL;
+		m_vvTransp = vector< vector<double> >(3, vector<double>(3, 0.0));
+	}
+	GMM(int nVecSize, int nMixes = 1, string szCovType = "diagonal")
+	{
+		m_nVecSize = nVecSize;
+		m_nMixes = nMixes;
+		m_vmdMean.resize(m_nMixes);
+		if(0 == m_vmdCovar.size())
+			m_vmdCovar.resize(m_nMixes);
+		if(0 == m_vmdInvCovar.size())
+			m_vmdInvCovar.resize(m_nMixes);
+		m_szCovType = szCovType;
+		m_vMixWeights = vector<double>(nMixes, (1.0/(double)nMixes));
+		m_vlogMixWeights = vector<double>(nMixes, log(1.0/(double)nMixes));
+		for(int n = 0; n < m_nMixes; n++)
+		{
+			m_vmdMean[n].SetSize(m_nVecSize, 1);
+			m_vmdMean[n].Null();
+			m_vmdCovar[n].SetSize(m_nVecSize, m_nVecSize);
+			m_vmdInvCovar[n].SetSize(m_nVecSize, m_nVecSize);
+			m_vmdCovar[n].Null();
+			m_vmdInvCovar[n].Null();
+			for(int d = 0; d < m_nVecSize; d++)
+			{
+				m_vmdCovar[n](d,d) = 1.0;
+				m_vmdInvCovar[n](d,d) = 1.0;
+			}
+		}
+		m_vvTransp = vector< vector<double> >(3, vector<double>(3, 0.0));
+		//m_ptheta = NULL;
+	}
+	GMM(const GMM& rhs)
+	{
+		m_nVecSize = rhs.m_nVecSize;
+		m_nMixes = rhs.m_nMixes;
+		m_szCovType = rhs.m_szCovType;
+		m_szFeatureType = rhs.m_szFeatureType;
+		m_vdgconst = rhs.m_vdgconst;
+		m_vMixWeights = rhs.m_vMixWeights;
+		m_vmdMean = rhs.m_vmdMean;
+		m_vmdCovar = rhs.m_vmdCovar;
+		m_vmdInvCovar = rhs.m_vmdInvCovar;
+		m_vlogMixWeights = rhs.m_vlogMixWeights;
+		m_vvddiaggconst = rhs.m_vvddiaggconst;
+		m_vvTransp = rhs.m_vvTransp;
+		//m_ptheta = NULL;
+	}
+	~GMM()
+	{
+		//if(m_ptheta != NULL)
+		//{
+		//	delete m_ptheta;
+		//}
+	}
+	double LogAdd(double x, double y)
+	{
+	   double temp,diff,z;
+	   if (x<y) {
+		  temp = x; x = y; y = temp;
+	   }
+	   diff = y-x;
+	   if (diff<minLogExp) 
+		  return  (x<LSMALL)?LZERO:x;
+	   else {
+		  z = exp(diff);
+		  return x+log(1.0+z);
+	   }
+	}
+	void InitGMMMeans(int nVecSize, int nMixes = 1)
+	{
+		m_nVecSize = nVecSize;
+		m_nMixes = nMixes;
+		m_vmdMean.resize(m_nMixes);
+		double oneovern = 1.0/(double)nMixes;
+		double log1n = log(oneovern);
+		m_vMixWeights = vector<double>(nMixes, oneovern);
+		m_vlogMixWeights = vector<double>(nMixes, log1n);
+		for(int n = 0; n < m_nMixes; n++)
+		{
+			m_vmdMean[n].SetSize(m_nVecSize, 1);
+			m_vmdMean[n].Null();
+		}
+	}
+	void InitGMMVars(int nVecSize, int nMixIndex, string szCovType = "diagonal")
+	{
+		m_nVecSize = nVecSize;
+		m_szCovType = szCovType;
+		if(nMixIndex >= m_vmdCovar.size())
+		{
+			m_vmdCovar.resize(nMixIndex + 1);
+			m_vmdInvCovar.resize(nMixIndex + 1);
+		}
+		for(int n = 0; n < m_nMixes; n++)
+		{
+			m_vmdCovar[nMixIndex].SetSize(m_nVecSize, m_nVecSize);
+			m_vmdInvCovar[nMixIndex].SetSize(m_nVecSize, m_nVecSize);
+			m_vmdCovar[nMixIndex].Null();
+			m_vmdInvCovar[nMixIndex].Null();
+			for(int d = 0; d < m_nVecSize; d++)
+			{
+				m_vmdCovar[nMixIndex](d,d) = 1.0;
+				m_vmdInvCovar[nMixIndex](d,d) = 1.0;
+			}
+		}
+	}
+	void CompGconsts()
+	{
+		m_vdgconst.resize(m_nMixes, 0.0);
+		m_vvddiaggconst.resize(m_nMixes, vector<double>(m_nVecSize, 0.0));
+		for(int n = 0; n < m_nMixes; n++)
+		{
+			//cout<<n<<"-th mixture, "<<m_vmdCovar[n].ColNo()<<"x"<<m_vmdCovar[n].RowNo()<<endl;
+			if(m_vMixWeights[n] > 0)
+			{
+				size_t covtype = m_szCovType.compare("diagonal");
+				if(covtype)
+				{
+					m_vdgconst[n] = (double)m_nVecSize * log(TWOPI) + log(m_vmdCovar[n].Det());
+				}
+				else
+				{
+					m_vdgconst[n] = (double)m_nVecSize * log(TWOPI);
+					for(int d = 0; d < m_nVecSize; d++)
+					{
+						m_vdgconst[n] += log(m_vmdCovar[n](d,d));
+					}
+				}
+				for(int d = 0; d < m_nVecSize; d++)
+				{
+					m_vvddiaggconst[n][d] = log(TWOPI) + log(m_vmdCovar[n](d,d));
+				}			
+			}
+			else
+			{
+				m_vdgconst[n] = LZERO;			     
+				for(int d = 0; d < m_nVecSize; d++)
+				{
+					m_vvddiaggconst[n][d] = LZERO;
+				}
+			}
+		}
+	}
+	// Actually, return log likelihood instead of likelihood
+	double CompLikelihood(const vector<double>& vec)
+	{
+		matrix<double> mvec;
+		size_t nsize = vec.size();
+		mvec.SetSize(nsize, 1);
+		for(size_t n = 0; n < nsize; n++)
+		{
+			mvec(n, 0) = vec[n];
+		}
+		vector<double> vdTemp(m_nMixes, 0.0);
+		double dTemp = LZERO;
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				matrix<double> x = (mvec - m_vmdMean[n]);
+				if(m_szCovType == "diagonal")
+				{
+#ifndef DIAGONAL			
+					for(size_t j = 0; j < m_nVecSize; j++)
+					{
+						for(size_t i = j+1; i < m_nVecSize; i++)
+						{
+							vdTemp[n] += x(i, 0) * x(j, 0) * m_vmdInvCovar[n](i,j);
+						}
+					}
+					vdTemp[n] *= 2;
+					for(size_t i = 0; i < m_nVecSize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+					}
+					vdTemp[n] += m_vdgconst[n];
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#else
+					vdTemp[n] += m_vdgconst[n];
+					for(size_t i = 0; i < m_nVecSize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+					}
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#endif
+				}
+				else if(m_szCovType == "full")
+				{
+					vdTemp[n] += m_vdgconst[n];
+					matrix<double> mvectemp = ~x * m_vmdInvCovar[n] * x;
+					vdTemp[n] += mvectemp(0, 0);
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+				}
+				dTemp = LogAdd(dTemp, vdTemp[n]);
+			}
+		}
+		return dTemp; //exp(dTemp)
+	}
+	double CompLikelihood(const matrix<double>& mvec)
+	{
+		vector<double> vdTemp(m_nMixes, 0.0);
+		size_t nsize = mvec.ColNo();
+		double dTemp = LZERO;
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				matrix<double> x = (mvec - m_vmdMean[n]);
+				if(m_szCovType == "diagonal")
+				{
+#ifndef DIAGONAL			
+					for(size_t j = 0; j < m_nVecSize; j++)
+					{
+						for(size_t i = j+1; i < m_nVecSize; i++)
+						{
+							vdTemp[n] += x(i, 0) * x(j, 0) * m_vmdInvCovar[n](i,j);
+						}
+					}
+					vdTemp[n] *= 2;
+					for(size_t i = 0; i < m_nVecSize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+					}
+					vdTemp[n] += m_vdgconst[n];
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#else
+					vdTemp[n] += m_vdgconst[n];
+					for(size_t i = 0; i < m_nVecSize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+					}
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#endif
+				}
+				else if(m_szCovType == "full")
+				{
+					vdTemp[n] += m_vdgconst[n];
+					vdTemp[n] += (~x * m_vmdInvCovar[n] * x)(0, 0);
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+				}
+				dTemp = LogAdd(dTemp, vdTemp[n]);
+			}		
+		}
+		return dTemp; //exp(dTemp)
+	}
+	// the posterior probability ( not log )
+	void CompPosteriori(const vector<double>& vec, vector<double>& vPost)
+	{
+		matrix<double> mvec;
+		size_t nsize = vec.size();
+		mvec.SetSize(nsize, 1);
+		for(size_t n = 0; n < nsize; n++)
+		{
+			mvec(n, 0) = vec[n];
+		}
+		vector<double> vdTemp(m_nMixes, 0.0);
+		double dTemp = LZERO;
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				matrix<double> x = (mvec - m_vmdMean[n]);
+				if(m_szCovType == "diagonal")
+				{
+#ifndef DIAGONAL			
+					for(size_t j = 0; j < m_nVecSize; j++)
+					{
+						for(size_t i = j+1; i < m_nVecSize; i++)
+						{
+							vdTemp[n] += x(i, 0) * x(j, 0) * m_vmdInvCovar[n](i,j);
+						}
+					}
+					vdTemp[n] *= 2;
+					for(size_t i = 0; i < m_nVecSize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+					}
+					vdTemp[n] += m_vdgconst[n];
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#else
+					vdTemp[n] += m_vdgconst[n];
+					for(size_t i = 0; i < m_nVecSize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+					}
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#endif
+				}
+				else if(m_szCovType == "full")
+				{
+					vdTemp[n] += m_vdgconst[n];
+					vdTemp[n] += (~x * m_vmdInvCovar[n] * x)(0, 0);
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+				}
+				dTemp = LogAdd(dTemp, vdTemp[n]);
+			}
+		}
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				vdTemp[n] -= dTemp;
+				vdTemp[n] = exp(vdTemp[n]);
+			}
+			else
+			{
+				vdTemp[n] = 0.0;
+			}
+		}
+		vPost = vdTemp;
+	}
+	// Get mean vector for subspace, the space chosen is indicated by vDimConsidered
+	void GetPartialMeans(vector< matrix<double> >& PartialMeans, vector<int>& vDimConsidered)
+	{
+		PartialMeans.resize(m_nMixes);
+		for(size_t k = 0; k < m_vmdMean.size(); k++)
+		{
+			PartialMeans[k].SetSize(vDimConsidered.size(), 1);
+			for(size_t n = 0; n < vDimConsidered.size(); n++)
+			{
+				PartialMeans[k](n, 0) = m_vmdMean[k](vDimConsidered[n], 0);
+			}
+		}
+	}
+	// Get covariance matrix for subspace, the space chosen is indicated by vDimConsidered
+	void GetPartialVars(vector< matrix<double> >& PartialVars, vector< matrix<double> >& PartialInvVars, vector<double>& vPartialGconst, vector<int>& vDimConsidered)
+	{
+		PartialVars.resize(m_nMixes);
+		PartialInvVars.resize(m_nMixes);
+		for(size_t k = 0; k < m_vmdMean.size(); k++)
+		{
+			PartialVars[k].SetSize(vDimConsidered.size(), vDimConsidered.size());
+			PartialInvVars[k].SetSize(vDimConsidered.size(), vDimConsidered.size());
+			for(size_t n = 0; n < vDimConsidered.size(); n++)
+			{
+				for(size_t m = 0; m < vDimConsidered.size(); m++)
+				{
+					PartialVars[k](n, m) = m_vmdCovar[k](vDimConsidered[n], vDimConsidered[m]);
+					PartialInvVars[k](n, m) = m_vmdInvCovar[k](vDimConsidered[n], vDimConsidered[m]);
+				}
+			}
+		}
+		vPartialGconst.resize(m_nMixes, 0.0);
+		for(int n = 0; n < m_nMixes; n++)
+		{
+			vPartialGconst[n] = (double)vDimConsidered.size() * log(TWOPI)+log(PartialVars[n].Det());
+		}
+	}	
+    // obsolete function, don't use it
+	void CompPosterioriPartOld(const vector<double>& vec, vector<double>& vPost, vector<int>& vDimConsidered)
+	{
+		matrix<double> mvec;
+		vector< matrix<double> > PartialMeans;
+		vector< matrix<double> > PartialVars;
+		vector< matrix<double> > PartialInvVars;
+		vector<double> vPartialGconst;
+
+		size_t nsize = vDimConsidered.size();
+		mvec.SetSize(nsize, 1);
+		for(size_t n = 0; n < nsize; n++)
+		{
+			mvec(n, 0) = vec[vDimConsidered[n]];
+		}
+		
+		
+		GetPartialMeans(PartialMeans, vDimConsidered);
+		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+		
+		vector<double> vdTemp(m_nMixes, 0.0);
+		double dTemp = 0.0;
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				matrix<double> x = (mvec - PartialMeans[n]);
+				matrix<double> xt = ~x;
+				matrix<double> mval = 0.5 * xt * PartialInvVars[n] * x;
+				vdTemp[n] = -0.5 * vPartialGconst[n] - mval(0,0);
+				vdTemp[n] = m_vMixWeights[n] * exp(vdTemp[n]);
+				dTemp += vdTemp[n];
+			}
+		}
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				vdTemp[n] /= dTemp;
+			}
+		}
+		vPost = vdTemp;
+	}
+
+	// Compute posterior probability from subspace
+	void CompPosterioriPart(const vector<double>& vec, vector<double>& vPost, vector<int>& vDimConsidered)
+	{
+		matrix<double> mvec;
+		vector< matrix<double> > PartialMeans;
+		vector< matrix<double> > PartialVars;
+		vector< matrix<double> > PartialInvVars;
+		vector<double> vPartialGconst;
+
+		size_t nsize = vDimConsidered.size();
+
+		// mvec.SetSize(nsize, 1);
+		// for(size_t n = 0; n < nsize; n++)
+		// {
+			// mvec(n, 0) = vec[vDimConsidered[n]];
+		// }
+		vector<double> vdTemp(m_nMixes, 0.0);
+		double dTemp = LZERO;
+#ifndef DIAGONAL		
+		// mvec.SetSize(nsize, 1);
+		// for(size_t n = 0; n < nsize; n++)
+		// {
+			// mvec(n, 0) = mvec0(vDimConsidered[n], 0);
+		// }
+		//dw2 = timeGetTime();
+		//cout<<"CompLikelihoodPart: Prepare vector takes "<<dw2-dw1<<" ms"<<endl;
+		//dw1 = timeGetTime();
+		//GetPartialMeans(PartialMeans, vDimConsidered);
+		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+#endif
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				matrix<double> x(nsize, 1);
+				for(size_t d = 0; d < nsize; d++)
+					x(d,0) = (vec[vDimConsidered[d]] - m_vmdMean[n](vDimConsidered[d], 0));
+				if(m_szCovType == "diagonal")
+				{
+#ifndef DIAGONAL			
+				for(size_t j = 0; j < nsize; j++)
+				{
+					for(size_t i = j+1; i < nsize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(j, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[j]);
+					}
+				}
+				vdTemp[n] *= 2;
+				for(size_t i = 0; i < nsize; i++)
+				{
+					vdTemp[n] += x(i, 0) * x(i, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[i]);
+				}
+				vdTemp[n] += vPartialGconst[n];
+				vdTemp[n] *= -0.5;
+				vdTemp[n] += m_vlogMixWeights[n];
+#else
+				for(size_t d = 0; d < nsize; d++)
+					vdTemp[n] += m_vvddiaggconst[n][vDimConsidered[d]];
+				for(size_t i = 0; i < nsize; i++)
+				{
+					vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](vDimConsidered[i],vDimConsidered[i]);
+				}
+				vdTemp[n] *= -0.5;
+				vdTemp[n] += m_vlogMixWeights[n];
+#endif
+				}
+				else if(m_szCovType == "full")
+				{
+					vdTemp[n] += vPartialGconst[n];
+					vdTemp[n] += (~x * PartialInvVars[n] * x)(0, 0);
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];					
+				}
+				dTemp = LogAdd(dTemp, vdTemp[n]);
+			}
+		}
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				vdTemp[n] -= dTemp;
+				vdTemp[n] = exp(vdTemp[n]);
+			}
+		}
+		vPost = vdTemp;
+	}
+	// Obsolete function, don't use it
+	double CompLikelihoodPartOld(const vector<double>& vec, vector<int>& vDimConsidered)
+	{
+		DWORD dw1 = 0, dw2 = 0;
+		//dw1 = timeGetTime();
+		matrix<double> mvec;
+		vector< matrix<double> > PartialMeans;
+		vector< matrix<double> > PartialVars;
+		vector< matrix<double> > PartialInvVars;
+		vector<double> vPartialGconst;
+		
+		size_t nsize = vDimConsidered.size();
+		mvec.SetSize(nsize, 1);
+		for(size_t n = 0; n < nsize; n++)
+		{
+			mvec(n, 0) = vec[vDimConsidered[n]];
+		}
+		
+		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+		GetPartialMeans(PartialMeans, vDimConsidered);
+		vector<double> vdTemp(m_nMixes, 0.0);
+		double dTemp = 0;
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				matrix<double> x = mvec - PartialMeans[n];
+				matrix<double> xt = ~x;
+				matrix<double> mval = 0.5 * xt * PartialInvVars[n] * x;
+				vdTemp[n] = -0.5 * vPartialGconst[n] - mval(0,0);
+				vdTemp[n] = m_vMixWeights[n] * exp(vdTemp[n]);
+				dTemp += vdTemp[n];
+			}
+		}
+		return log(dTemp); //exp(dTemp);
+	}
+	// Compuete log likelihood from subspace
+	double CompLikelihoodPart(const vector<double>& vec, vector<int>& vDimConsidered)
+	{
+		DWORD dw1 = 0, dw2 = 0;
+		//dw1 = timeGetTime();
+		matrix<double> mvec;
+		vector< matrix<double> > PartialMeans;
+		vector< matrix<double> > PartialVars;
+		vector< matrix<double> > PartialInvVars;
+		vector<double> vPartialGconst;
+		
+		size_t nsize = vDimConsidered.size();
+#ifndef DIAGONAL		
+		// mvec.SetSize(nsize, 1);
+		// for(size_t n = 0; n < nsize; n++)
+		// {
+			// mvec(n, 0) = vec[vDimConsidered[n]];
+		// }
+		//dw2 = timeGetTime();
+		//cout<<"CompLikelihoodPart: Prepare vector takes "<<dw2-dw1<<" ms"<<endl;
+		//dw1 = timeGetTime();
+		//GetPartialMeans(PartialMeans, vDimConsidered);
+		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+#endif		
+		vector<double> vdTemp(m_nMixes, 0.0);
+		double dTemp = LZERO;
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)	
+			{
+				matrix<double> x(nsize, 1);
+				for(size_t d = 0; d < nsize; d++)
+					x(d,0) = (vec[vDimConsidered[d]] - m_vmdMean[n](vDimConsidered[d], 0));
+				if(m_szCovType == "diagonal")
+				{
+#ifndef DIAGONAL			
+					for(size_t j = 0; j < nsize; j++)
+					{
+						for(size_t i = j+1; i < nsize; i++)
+						{
+							vdTemp[n] += x(i, 0) * x(j, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[j]);
+						}
+					}
+					vdTemp[n] *= 2;
+					for(size_t i = 0; i < nsize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[i]);
+					}
+					vdTemp[n] += vPartialGconst[n];
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#else
+					for(size_t d = 0; d < nsize; d++)
+						vdTemp[n] += m_vvddiaggconst[n][vDimConsidered[d]];
+					for(size_t i = 0; i < nsize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](vDimConsidered[i],vDimConsidered[i]);
+					}
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#endif
+				}
+				else if(m_szCovType == "full")
+				{
+					vdTemp[n] += vPartialGconst[n];
+					vdTemp[n] += (~x * PartialInvVars[n] * x)(0, 0);
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];					
+				}
+				dTemp = LogAdd(dTemp, vdTemp[n]);
+			}
+		}
+		return dTemp; //exp(dTemp);
+	}
+	// Compute log likelihood from subspace
+	double CompLikelihoodPart(const matrix<double>& mvec0, vector<int>& vDimConsidered)
+	{
+		matrix<double> mvec;
+		vector< matrix<double> > PartialMeans;
+		vector< matrix<double> > PartialVars;
+		vector< matrix<double> > PartialInvVars;
+		vector<double> vPartialGconst;
+
+		size_t nsize = vDimConsidered.size();
+		
+#ifndef DIAGONAL		
+		// mvec.SetSize(nsize, 1);
+		// for(size_t n = 0; n < nsize; n++)
+		// {
+			// mvec(n, 0) = mvec0(vDimConsidered[n], 0);
+		// }
+		//dw2 = timeGetTime();
+		//cout<<"CompLikelihoodPart: Prepare vector takes "<<dw2-dw1<<" ms"<<endl;
+		//dw1 = timeGetTime();
+		//GetPartialMeans(PartialMeans, vDimConsidered);
+		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+#endif
+		vector<double> vdTemp(m_nMixes, 0.0);
+		double dTemp = LZERO;
+		for(size_t n = 0; n < m_nMixes; n++)
+		{
+			if(m_vMixWeights[n] > 0)
+			{
+				matrix<double> x(nsize, 1);
+				for(size_t d = 0; d < nsize; d++)
+					x(d,0) = (mvec0(vDimConsidered[d], 0) - m_vmdMean[n](vDimConsidered[d], 0));
+				if(m_szCovType == "diagonal")
+				{
+#ifndef DIAGONAL			
+					for(size_t j = 0; j < nsize; j++)
+					{
+						for(size_t i = j+1; i < nsize; i++)
+						{
+							vdTemp[n] += x(i, 0) * x(j, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[j]);
+						}
+					}
+					vdTemp[n] *= 2;
+					for(size_t i = 0; i < nsize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[i]);
+					}
+					vdTemp[n] += vPartialGconst[n];
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#else
+					for(size_t d = 0; d < nsize; d++)
+						vdTemp[n] += m_vvddiaggconst[n][vDimConsidered[d]];
+					for(size_t i = 0; i < nsize; i++)
+					{
+						vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](vDimConsidered[i],vDimConsidered[i]);
+					}
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];
+#endif
+				}
+				else if(m_szCovType == "full")
+				{
+					vdTemp[n] += vPartialGconst[n];
+					vdTemp[n] += (~x * PartialInvVars[n] * x)(0, 0);
+					vdTemp[n] *= -0.5;
+					vdTemp[n] += m_vlogMixWeights[n];					
+				}				
+				dTemp = LogAdd(dTemp, vdTemp[n]);
+			}
+		}
+		return dTemp;
+	}
+	//void InitHyperParams()
+	//{
+	//	m_theta.InitHyperParambyGMM(&this);
+	//}
+	int m_nVecSize;
+	int m_nMixes;
+	string m_szCovType;
+	string m_szFeatureType;
+	vector<double> m_vMixWeights;
+	vector< matrix<double> > m_vmdMean;
+	vector< matrix<double> > m_vmdCovar;
+	vector< matrix<double> > m_vmdInvCovar;
+	vector<double> m_vdgconst;
+	vector<double> m_vlogMixWeights;
+	vector< vector<double> > m_vvddiaggconst;
+	vector< vector<double> > m_vvTransp;
+	//GMMHyperParam m_hyperparam;
+	//GMMHyperParam* m_ptheta;
+};
+
diff --git a/GMMAdaptTool.h b/GMMAdaptTool.h
new file mode 100644
index 0000000..14e83da
--- /dev/null
+++ b/GMMAdaptTool.h
@@ -0,0 +1,9220 @@
+#pragma once
+#include "GMM.h"
+#include "connected.h"
+#include "LoadJPGLabelInfo.h"
+#include "ExtLowLevelImgFeature.h"
+#include "VideoFE.h"
+
+
+//class CVideoFE;
+//#include <tr1/unordered_map>
+//using namespace std::tr1;
+#define NUMITERATION 5
+#define WIDTH 16
+#define HEIGHT 12
+//==============================================================================//
+// inserted, 6/6/2011 You-Chi Cheng, and all 4096 are changed to MAXSTRLENGTH
+//===============================================================================//
+#define MAXSTRLENGTH 4096
+#define CCThreshold 0.5
+#define GMMITER 5
+//===============================================================================//
+extern vector<int> vDimConsidered;
+
+//class JPGLabelInfo
+//{
+//public:
+//	int m_nWidth;
+//	int m_nHeight;
+//	int m_nBlockWidth;
+//	int m_nBlockHeight;
+//	int** m_ppnLabel;
+//	vector< vector<int> > m_vvOnes;
+//	string m_szPathName;
+//
+//	JPGLabelInfo()
+//	{
+//		m_nWidth=0;
+//		m_nHeight=0;
+//		m_nBlockWidth = 0;
+//		m_nBlockHeight = 0;
+//		m_ppnLabel=0;
+//	}
+//	~JPGLabelInfo()
+//	{
+//		if(m_ppnLabel)
+//		{
+//			for(int n = 0; n < m_nBlockHeight; n++)
+//			{
+//				delete [] m_ppnLabel[n];
+//			}
+//			delete [] m_ppnLabel;
+//		}
+//		m_nWidth = 0;
+//		m_nHeight = 0;
+//		m_nBlockWidth = 0;
+//		m_nBlockHeight = 0;
+//	}
+//	void SetWidthHeight(int nWidth, int nHeight, int BLOCKSIZE)
+//	{
+//		m_nWidth = nWidth;
+//		m_nHeight = nHeight;
+//		m_nBlockWidth = (int)floor((double)nWidth/(double)BLOCKSIZE);
+//		m_nBlockHeight = (int)floor((double)nHeight/(double)BLOCKSIZE);
+//	
+//		m_ppnLabel = new int*[m_nBlockHeight];
+//		for(int n = 0; n < m_nBlockHeight; n++)
+//		{
+//			m_ppnLabel[n] = new int[m_nBlockWidth];
+//			for(int m = 0; m < m_nBlockWidth; m++)
+//			{
+//				m_ppnLabel[n][m] = 0;
+//			}
+//		}
+//	}
+//	void SetAsSkinPixel(int x, int y)
+//	{
+//		if(m_ppnLabel && x < m_nBlockWidth && y < m_nBlockHeight)
+//		{
+//			m_ppnLabel[y][x] = 1;
+//			vector<int> vPt(2,0);
+//			vPt[0] = x;
+//			vPt[1] = y;
+//			m_vvOnes.push_back(vPt);
+//		}
+//	}
+//	void SetAsNotSurePixel(int x, int y)
+//	{
+//		if(m_ppnLabel && x < m_nBlockWidth && y < m_nBlockHeight)
+//		{
+//			m_ppnLabel[y][x] = -1;
+//		}
+//	}
+//	void SetAsNonSkinPixel(int x, int y)
+//	{
+//		if(m_ppnLabel && x < m_nBlockWidth && y < m_nBlockHeight)
+//		{
+//			m_ppnLabel[y][x] = 0;
+//		}
+//	}
+//};
+//
+
+class GMMAdaptTool
+{
+public:
+	GMMAdaptTool(void)
+	{	
+	}
+
+	~GMMAdaptTool(void)
+	{
+	}
+
+	static std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
+		std::stringstream ss(s);
+		std::string item;
+		while(std::getline(ss, item, delim)) {
+			elems.push_back(item);
+		}
+		return elems;
+	}
+	static std::vector<std::string> split(const std::string &s, char delim) {
+		std::vector<std::string> elems;
+		return split(s, delim, elems);
+	}
+	static std::vector<double> vecstr2vecdb(vector<string>& vdata)
+	{
+		vector<double> results = vector<double>(vdata.size(), 0.0);
+		for(size_t n = 0; n < vdata.size(); n++)
+		{
+			results[n] = atof(vdata[n].c_str());
+		}
+		return results;
+	}
+	static void LoadLogData(string szPathName, vector< vector<double> >& vvdata, vector<int>& vclasses)
+	{
+		ifstream fin;
+		fin.open(szPathName.c_str());
+		char szbuf[65535];
+		memset(szbuf, 0, 65535);
+		if(fin.is_open())
+		{
+			while(fin.getline(szbuf, 65535))
+			{
+				string strbuf = string(szbuf);
+				vector<string> data = split(strbuf, ',');
+				vector<double> vdata = vecstr2vecdb(data);
+				vector<double> vdatan = vector<double>(vdata.size() - 1, 0.0);
+				for(size_t n = 1; n < vdata.size(); n++)
+				{
+					vdatan[n-1] = vdata[n];
+				}
+				vvdata.push_back(vdatan);
+				vclasses.push_back(atoi(data[0].c_str()));
+			}
+			fin.close();
+		}
+		else
+		{
+			cerr<<"Cannot open "<<szPathName<<endl;
+		}
+	}
+
+	static int LoadGMM(string szGMM, unordered_map<string, GMM>& hGMMs)
+	{
+		ifstream fin;
+		fin.open(szGMM.c_str());
+		string szBuf;
+		unordered_map<string, GMM> hMixtureMacro;
+		if(fin.is_open())
+		{
+			int nVecSize = 0;
+			while(getline(fin, szBuf))
+			{
+				string strName = "";
+				string szFeatureType = "";
+				int nfindtilt = -1;
+				int nMixes = 0;
+
+				if(szBuf.npos != (nfindtilt = szBuf.find("~o")))
+				{	
+					while(1)
+					{
+						getline(fin, szBuf);
+						int nfoundpos = -1;
+						if(szBuf.npos != (nfoundpos = szBuf.find("<VECSIZE>")))
+						{
+							int npos01 = szBuf.find_last_of("<");
+							int npos02 = szBuf.find_last_of(">");
+							string szVecSize = szBuf.substr(nfoundpos + 9, npos01 - nfoundpos - 9);
+							nVecSize = atoi(szVecSize.c_str());
+							szFeatureType = szBuf.substr(npos01 + 1, npos02 - npos01 - 1);
+							break;
+						}
+					}
+				}
+				// mixture macro
+				else if(szBuf.npos != (nfindtilt = szBuf.find("~m")))
+				{
+					string szMacroName = szBuf.substr(nfindtilt+2, szBuf.length() - nfindtilt - 2);
+					int npos1 = szMacroName.find_first_of('\"');
+					int npos2 = szMacroName.find_last_of('\"');
+					szMacroName = szMacroName.substr(npos1, npos2-npos1 + 1);
+					int nVecSizeMacro = 0;
+					fin>>szBuf>>nVecSizeMacro;
+					std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+					if(szBuf.npos != szBuf.find("<MEAN>"))
+					{
+						hMixtureMacro[szMacroName].InitGMMMeans(nVecSizeMacro, 1);
+						hMixtureMacro[szMacroName].m_vmdCovar.resize(1);
+						hMixtureMacro[szMacroName].m_vmdInvCovar.resize(1);
+						hMixtureMacro[szMacroName].m_vMixWeights[0] = 0;
+						hMixtureMacro[szMacroName].m_vlogMixWeights[0] = LZERO;
+						hMixtureMacro[szMacroName].m_vmdMean[0].Null();										
+						for(int d = 0; d < nVecSizeMacro; d++)
+						{
+							double db1 = 0.0;
+							fin>>db1;
+							hMixtureMacro[szMacroName].m_vmdMean[0](d, 0) = db1;
+						}
+						fin>>szBuf>>nVecSizeMacro;
+						std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+						if(szBuf.npos != szBuf.find("<VARIANCE>"))
+						{
+							hMixtureMacro[szMacroName].InitGMMVars(nVecSizeMacro, 0);
+							//cout<<"in hGMMs["<<strName<<"], the size of the var is "<<hGMMs[strName].m_vmdCovar[nMixIndex].RowNo()<<"x"<<hGMMs[strName].m_vmdCovar[nMixIndex].ColNo()<<endl;
+							for(int d = 0; d < nVecSizeMacro; d++)
+							{
+								fin>>hMixtureMacro[szMacroName].m_vmdCovar[0](d,d);
+								hMixtureMacro[szMacroName].m_vmdInvCovar[0](d,d) = 1.0 /hMixtureMacro[szMacroName].m_vmdCovar[0](d,d);
+							}
+						}
+						else if(szBuf.npos != szBuf.find("<INVCOVAR>"))
+						{
+							hMixtureMacro[szMacroName].InitGMMVars(nVecSizeMacro, 0, "full");
+							for(int d = 0; d < nVecSizeMacro; d++)
+							{
+								for(int dd = d; dd < nVecSizeMacro; dd++)
+								{
+									fin>>hMixtureMacro[szMacroName].m_vmdInvCovar[0](d,dd);
+									hMixtureMacro[szMacroName].m_vmdInvCovar[0](dd, d) = hMixtureMacro[szMacroName].m_vmdInvCovar[0](d,dd);
+								}
+							}
+							hMixtureMacro[szMacroName].m_vmdCovar[0] = !hMixtureMacro[szMacroName].m_vmdInvCovar[0];
+						}
+						double dbgconst = 0.0;
+						fin>>szBuf>>dbgconst;
+						hMixtureMacro[szMacroName].CompGconsts();
+					}
+				}
+				else if(szBuf.npos != (nfindtilt = szBuf.find("~h")))
+				{
+					strName = szBuf.substr(nfindtilt+2, szBuf.length() - nfindtilt - 2);
+					int npos1 = strName.find_first_of('\"');
+					int npos2 = strName.find_last_of('\"');
+					strName = strName.substr(npos1+1, npos2-npos1-1);
+					getline(fin, szBuf);
+					while(1)
+					{
+						int nfoundpos = -1;
+						bool bforcestop = false;
+						if(szBuf.npos != szBuf.find('<') && szBuf.npos != szBuf.find('>'))
+						{
+							std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+							if(szBuf.npos != szBuf.find("<BEGINHMM>"))
+							{
+							}
+							else if(szBuf.npos != (nfoundpos = szBuf.find("<VECSIZE>")))
+							{
+								int npos01 = szBuf.find_last_of("<");
+								int npos02 = szBuf.find_last_of(">");
+								string szVecSize = szBuf.substr(nfoundpos + 9, npos01 - nfoundpos - 9);
+								nVecSize = atoi(szVecSize.c_str());
+								szFeatureType = szBuf.substr(npos01 + 1, npos02 - npos01 - 1);
+							}
+							else if(szBuf.npos != (nfoundpos = szBuf.find("<NUMMIXES>")))
+							{
+								int npos01 = szBuf.length() - 1;
+								string szMixes = szBuf.substr(nfoundpos + 10, npos01 - nfoundpos - 9);
+								nMixes = atoi(szMixes.c_str());
+								hGMMs[strName].InitGMMMeans(nVecSize, nMixes);
+								int nMixIndex = 0;
+								int nDims = 0;
+								double dMixWeight;
+								int nlastload = -1;
+								hGMMs[strName].m_vmdCovar.resize(nMixes);
+								hGMMs[strName].m_vmdInvCovar.resize(nMixes);
+								
+								for(int kk = 0; kk < nMixes; kk++)
+								{
+									//fin>>szBuf>>nMixIndex>>dMixWeight;
+									fin>>szBuf;
+									if(szBuf.npos != szBuf.find("<TRANSP>"))
+									{
+										bforcestop = true;
+										for(int kkk = nlastload + 1; kkk < nMixes; kkk++)
+										{
+											hGMMs[strName].m_vMixWeights[kkk] = 0;
+											hGMMs[strName].m_vlogMixWeights[kkk] = LZERO;
+											hGMMs[strName].m_vmdMean[kkk].Null();										
+											hGMMs[strName].m_vmdCovar[kkk].SetSize(nVecSize, nVecSize);
+											hGMMs[strName].m_vmdCovar[kkk].Null();
+											hGMMs[strName].m_vmdInvCovar[kkk].SetSize(nVecSize, nVecSize);
+											hGMMs[strName].m_vmdInvCovar[kkk].Null();
+										}
+										break;
+									}
+									else if(szBuf.npos != szBuf.find("<MIXTURE>"))
+									{
+										fin>>nMixIndex>>dMixWeight;
+										nMixIndex--;
+										if(nMixIndex - nlastload > 1)
+										{
+											int nstartkkk = max(0, nlastload + 1);
+											for(int kkk = nstartkkk; kkk < nMixIndex; kkk++)
+											{
+												hGMMs[strName].m_vMixWeights[kkk] = 0;
+												hGMMs[strName].m_vlogMixWeights[kkk] = LZERO;
+												hGMMs[strName].m_vmdMean[kkk].Null();
+												hGMMs[strName].m_vmdCovar[kkk].SetSize(nVecSize, nVecSize);
+												hGMMs[strName].m_vmdCovar[kkk].Null();
+												hGMMs[strName].m_vmdInvCovar[kkk].SetSize(nVecSize, nVecSize);
+												hGMMs[strName].m_vmdInvCovar[kkk].Null();
+											}
+											kk = nMixIndex;
+										}
+										nlastload = kk;										
+										hGMMs[strName].m_vMixWeights[nMixIndex] = dMixWeight;
+										hGMMs[strName].m_vlogMixWeights[nMixIndex] = log(dMixWeight);
+										//fin>>szBuf>>nDims;
+										getline(fin, szBuf);
+										while(0 == szBuf.length() || 0 == szBuf.compare("\r"))
+											getline(fin, szBuf);
+										string szBuf02 = szBuf;
+										std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+										if(szBuf.npos != szBuf.find("<MEAN>"))
+										{
+											stringstream ss;
+											ss.str(szBuf);
+											string sz1;
+											ss>>sz1>>nDims;											
+											//ss.open()
+											//hGMMs[strName].InitGMMMeans(nVecSize, nMixes);
+											for(int d = 0; d < nDims; d++)
+											{
+												double db1 = 0.0;
+												fin>>db1;
+												hGMMs[strName].m_vmdMean[nMixIndex](d, 0) = db1;
+											}
+											fin>>szBuf>>nDims;
+											std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+											if(szBuf.npos != szBuf.find("<VARIANCE>"))
+											{
+												hGMMs[strName].InitGMMVars(nVecSize, nMixIndex);
+												//cout<<"in hGMMs["<<strName<<"], the size of the var is "<<hGMMs[strName].m_vmdCovar[nMixIndex].RowNo()<<"x"<<hGMMs[strName].m_vmdCovar[nMixIndex].ColNo()<<endl;
+												for(int d = 0; d < nDims; d++)
+												{
+													fin>>hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+													hGMMs[strName].m_vmdInvCovar[nMixIndex](d,d) = 1.0 / hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+												}
+											}
+											else if(szBuf.npos != szBuf.find("<INVCOVAR>"))
+											{
+												hGMMs[strName].InitGMMVars(nVecSize, nMixIndex, "full");
+												for(int d = 0; d < nDims; d++)
+												{
+													for(int dd = d; dd < nDims; dd++)
+													{
+														fin>>hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+														hGMMs[strName].m_vmdInvCovar[nMixIndex](dd, d) = hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+													}
+												}
+												hGMMs[strName].m_vmdCovar[nMixIndex] = !hGMMs[strName].m_vmdInvCovar[nMixIndex];
+											}
+											double dbgconst = 0.0;
+											fin>>szBuf>>dbgconst;
+										}
+										else if(szBuf.npos != szBuf.find("<VARIANCE>"))
+										{
+											stringstream ss;
+											ss.str(szBuf);
+											string sz1;
+											ss>>sz1>>nDims;
+											hGMMs[strName].InitGMMVars(nVecSize, nMixIndex);
+											for(int d = 0; d < nDims; d++)
+											{
+												fin>>hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+												hGMMs[strName].m_vmdInvCovar[nMixIndex](d,d) = 1.0 / hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+											}
+											fin>>szBuf>>nDims;
+											std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+											if(szBuf.npos != szBuf.find("<MEAN>"))
+											{
+												for(int d = 0; d < nDims; d++)
+												{
+													fin>>hGMMs[strName].m_vmdMean[nMixIndex](d, 0);
+												}
+											}
+											double dbgconst = 0.0;
+											fin>>szBuf>>dbgconst;
+										}
+										else if(szBuf.npos != szBuf.find("<INVCOVAR>"))
+										{
+											stringstream ss;
+											ss.str(szBuf);
+											string sz1;
+											ss>>sz1>>nDims;
+											hGMMs[strName].InitGMMVars(nVecSize, nMixIndex, "full");
+											for(int d = 0; d < nDims; d++)
+											{
+												for(int dd = d; dd < nDims; dd++)
+												{
+													fin>>hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+													hGMMs[strName].m_vmdInvCovar[nMixIndex](dd, d) = hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+												}
+											}									
+											hGMMs[strName].m_vmdCovar[nMixIndex] = !hGMMs[strName].m_vmdInvCovar[nMixIndex];
+											fin>>szBuf>>nDims;
+											std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+											if(szBuf.npos != szBuf.find("<MEAN>"))
+											{
+												for(int d = 0; d < nDims; d++)
+												{
+													fin>>hGMMs[strName].m_vmdMean[nMixIndex](d, 0);
+												}
+											}
+											double dbgconst = 0.0;
+											fin>>szBuf>>dbgconst;
+										
+										}
+										else if(szBuf.npos != szBuf.find("~M"))
+										{
+											stringstream ss;
+											ss.str(szBuf02);
+											string sz1, sz2;
+											ss>>sz1>>sz2;
+											if(hMixtureMacro.find(sz2) == hMixtureMacro.end())
+											{
+												cerr<<"The specified macro was not defined!!!"<<endl;
+												return -1;
+											}
+											else
+											{
+												
+												hGMMs[strName].m_vmdMean[nMixIndex] = hMixtureMacro[sz2].m_vmdMean[0];
+												hGMMs[strName].m_vmdCovar[nMixIndex] = hMixtureMacro[sz2].m_vmdCovar[0];
+												hGMMs[strName].m_vmdInvCovar[nMixIndex] = hMixtureMacro[sz2].m_vmdInvCovar[0];
+												if(hGMMs[strName].m_vdgconst.size() != nMixes)
+													hGMMs[strName].m_vdgconst.resize(nMixes);
+												if(hGMMs[strName].m_vvddiaggconst.size() != nMixes)
+													hGMMs[strName].m_vvddiaggconst.resize(nMixes);
+												hGMMs[strName].m_vdgconst[nMixIndex] =  hMixtureMacro[sz2].m_vdgconst[0];
+												hGMMs[strName].m_vvddiaggconst[nMixIndex] =  hMixtureMacro[sz2].m_vvddiaggconst[0];
+											}
+										}
+									}
+								}
+							}
+						}
+						int nNumStates = 0;
+						if(bforcestop)
+						{
+							fin>>nNumStates;
+						}
+						else
+						{
+							getline(fin, szBuf);
+						}
+						if(szBuf.npos != szBuf.find("<TRANSP>"))
+						{
+							if(!bforcestop)
+							{
+								int npos00 = szBuf.find_last_of(">");
+								string szNumStates = szBuf.substr(npos00 + 1, szBuf.length() - npos00);
+								nNumStates = atoi(szNumStates.c_str());
+							}
+							hGMMs[strName].m_vvTransp.resize(nNumStates);
+							for(int nt = 0; nt < nNumStates; nt++)
+							{
+								hGMMs[strName].m_vvTransp[nt].resize(nNumStates);
+								double db1 = 0.0;
+								for(int nt1 = 0; nt1 < nNumStates; nt1++)
+								{
+									fin>>db1;
+									hGMMs[strName].m_vvTransp[nt][nt1] = db1;
+								}
+							}
+
+						}
+						if(szBuf.npos != szBuf.find("<ENDHMM>"))
+						{
+							break;
+						}
+					}
+				}
+			}
+		}
+		fin.close();
+		unordered_map<string, GMM>::iterator itr;
+		for(itr = hGMMs.begin(); itr != hGMMs.end(); itr++)
+		{
+			string szKey = itr->first;
+			hGMMs[szKey].CompGconsts();
+		}
+		return 1;
+	}
+
+	static int WriteGMM(string szOutGMM, unordered_map<string, GMM>& hGMMs)
+	{
+			// Current version for Diag covariance only, with dormat tag "USER"
+			ofstream fout;
+		if(0 == hGMMs.size())
+		{
+			cerr<<"Cannot write empty model!"<<endl;
+			return -1;
+		}
+			fout.open(szOutGMM.c_str());
+		unordered_map<string, GMM>::iterator itr = hGMMs.begin();
+			string firstgmm = itr->first;
+			int nVecSize = hGMMs[firstgmm].m_nVecSize;
+			if(fout.is_open())
+			{
+					fout<<"~o"<<endl;
+					fout<<"<STREAMINFO> 1 "<<nVecSize<<endl;
+					fout<<"<VECSIZE> "<<nVecSize<<"<NULLD><USER><DIAGC>"<<endl;
+					for(;itr != hGMMs.end();itr++)
+					{
+							string szKey = itr->first;
+							fout<<"~h \""<<szKey<<"\""<<endl;
+							fout<<"<BEGINHMM>"<<endl;
+							// We are gmms, we only have one state
+							fout<<"<NUMSTATES> 3"<<endl;
+							fout<<"<STATE> 2"<<endl;
+				fout<<"<NUMMIXES> "<<hGMMs[szKey].m_nMixes<<endl;
+				for(int n = 0; n < hGMMs[szKey].m_nMixes; n++)
+				{
+					if(hGMMs[szKey].m_vMixWeights[n] > 0)
+					{
+						fout<<"<MIXTURE> "<<(n+1)<<" ";
+						fout.setf(ios::scientific, ios::floatfield);
+						fout<<hGMMs[szKey].m_vMixWeights[n]<<endl;
+						fout.unsetf(ios::floatfield);
+						fout<<"<MEAN> "<<hGMMs[szKey].m_nVecSize<<endl;
+						fout.setf(ios::scientific, ios::floatfield);
+						for(int m = 0; m < hGMMs[szKey].m_nVecSize; m++)
+						{
+							fout<<" "<<hGMMs[szKey].m_vmdMean[n](m, 0);
+						}
+						fout<<endl;
+						fout.unsetf(ios::floatfield);
+						fout<<"<VARIANCE> "<<hGMMs[szKey].m_nVecSize<<endl;
+						fout.setf(ios::scientific, ios::floatfield);
+						for(int m = 0; m < hGMMs[szKey].m_nVecSize; m++)
+										{
+												fout<<" "<<hGMMs[szKey].m_vmdCovar[n](m, m);
+										}
+						fout<<endl;
+						fout<<"<GCONST> "<<hGMMs[szKey].m_vdgconst[n]<<endl;
+						fout.unsetf(ios::floatfield);
+					}
+				}
+				fout<<"<TRANSP> "<<hGMMs[szKey].m_vvTransp.size()<<endl;
+				fout.setf(ios::scientific, ios::floatfield);
+				for(int n = 0; n < hGMMs[szKey].m_vvTransp.size(); n++)
+				{
+					for(int n1 = 0; n1 < hGMMs[szKey].m_vvTransp[n].size(); n1++)
+					{
+						fout<<" "<<hGMMs[szKey].m_vvTransp[n][n1];
+					}
+					fout<<endl;
+				}
+				fout<<"<ENDHMM>"<<endl;
+					}
+			}
+			else
+			{
+					cerr<<"Cannot open "<<szOutGMM<<" for writing GMM"<<endl;
+					return -1;
+			}
+
+			return 0;
+	}
+
+	static int GMMHash2VectBH(unordered_map<string, GMM>& hGMMs, vector<GMM>& vGMMs)
+	{
+		vGMMs.resize(2);
+		vGMMs[0] = GMM(hGMMs["BkGnd"]);
+		vGMMs[1] = GMM(hGMMs["Hand"]);
+		return 1;
+	}
+	
+	static int RecognizeByGMMs(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses)
+	{
+		int N = (int)vvData.size();
+		if(N == 0)
+		{
+			cerr<<"Empty data for GMM recognition!"<<endl;
+			return 0;
+		}
+		recogClasses.resize(N, 0);
+		int I = (int)GMMs.size();
+		for(int n = 0; n < N; n++)
+		{
+			double maxni = GMMs[0].CompLikelihood(vvData[n]);
+			int argmaxni = 0;
+			for(int i = 1; i < I ;i++)
+			{
+				double dbi = GMMs[i].CompLikelihood(vvData[n]);
+				if(dbi > maxni)
+				{
+					maxni = dbi;
+					argmaxni = i;
+				}
+			}
+			recogClasses[n] = argmaxni;
+		}
+		return 1;
+	}
+
+	static int GMMsScores(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector< vector<double> >& vvrecogScores)
+	{
+		int N = (int)vvData.size();
+		if(N == 0)
+		{
+			cerr<<"Empty data for GMM recognition!"<<endl;
+			return 0;
+		}
+		int I = (int)GMMs.size();
+		vvrecogScores.resize(N, vector<double>(I, 0.0));
+		for(int n = 0; n < N; n++)
+		{
+			for(int i = 0; i < I ;i++)
+			{
+				vvrecogScores[n][i] = GMMs[i].CompLikelihood(vvData[n]);				
+			}
+		}
+		return 1;
+	}
+
+
+	static int GMMsScoresRecog(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses, vector< vector<double> >& vvrecogScores)
+	{
+		int N = (int)vvData.size();
+		if(N == 0)
+		{
+			cerr<<"Empty data for GMM recognition!"<<endl;
+			return 0;
+		}
+		int I = (int)GMMs.size();
+		vvrecogScores.resize(N, vector<double>(I, 0.0));
+		recogClasses.resize(N, 0);
+		for(int n = 0; n < N; n++)
+		{
+			double dbMaxLL = LZERO;
+			for(int i = 0; i < I ;i++)
+			{
+				vvrecogScores[n][i] = GMMs[i].CompLikelihood(vvData[n]);
+				if(vvrecogScores[n][i] > dbMaxLL)
+				{
+					dbMaxLL = vvrecogScores[n][i];
+					recogClasses[n] = i;
+				}
+			}
+		}
+		return 1;
+	}
+	// Must make sure vvvDecisionTable is 256*256*256
+	static int ApproxRecognizeByTable(vector< vector<double> >& vvData, bool*** vvvDecisionTable, vector<int>& recogClasses)
+	{
+		int N = (int)vvData.size();
+		if(N == 0)
+		{
+			cerr<<"Empty data for recognition!"<<endl;
+			return 0;
+		}
+		recogClasses.resize(N, 0);
+		for(int n = 0; n < N; n++)
+		{
+			int nIndex1 = (int)floor(vvData[n][0] + 0.5);
+			int nIndex2 = (int)floor(vvData[n][1] + 0.5);
+			int nIndex3 = (int)floor(vvData[n][2] + 0.5);
+			if(nIndex1 > 255)
+				nIndex1 = 255;
+			if(nIndex2 > 255)
+				nIndex2 = 255;
+			if(nIndex3 > 255)
+				nIndex3 = 255;
+				recogClasses[n] = (vvvDecisionTable[nIndex1][nIndex2][nIndex3])?1:0;
+		}
+		return 1;
+	}	
+
+	static int RecognizeByGMMsPart(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses)
+	{
+		int N = (int)vvData.size();
+		if(N == 0)
+		{
+			cerr<<"Empty data for GMM recognition!"<<endl;
+			return 0;
+		}
+		recogClasses.resize(N, 0);
+		int I = (int)GMMs.size();
+		for(int n = 0; n < N; n++)
+		{
+			double maxni = GMMs[0].CompLikelihoodPart(vvData[n], vDimConsidered);
+			int argmaxni = 0;
+			for(int i = 1; i < I ;i++)
+			{
+				double dbi = GMMs[i].CompLikelihoodPart(vvData[n], vDimConsidered);
+				if(dbi > maxni)
+				{
+					maxni = dbi;
+					argmaxni = i;
+				}
+			}
+			recogClasses[n] = argmaxni;
+		}
+		return 1;
+	}
+
+	static int Test2ClassesGMMs(vector< vector<double> >& vvData, vector<int>& classes, vector<GMM>& GMMs, vector<int>& recogClasses, double& Acc, vector<int>& confres)
+	{
+		if(!RecognizeByGMMs(vvData, GMMs, recogClasses))
+		{
+			return 0;
+		}
+		int N = (int)vvData.size();
+
+		//recogClasses.resize(N, 0);
+		//int I = (int)GMMs.size();
+		//int ErrCount = 0;
+		//for(int n = 0; n < N; n++)
+		//{
+		//	//double maxni = GMMs[0].CompLikelihoodPart(vvData[n], vDimConsidered);//GMMs[0].CompLikelihood(vvData[n]);
+		//	double maxni = GMMs[0].CompLikelihood(vvData[n]);
+		//	int argmaxni = 0;
+		//	for(int i = 1; i < I ;i++)
+		//	{
+		//		//double dbi = GMMs[i].CompLikelihoodPart(vvData[n], vDimConsidered);//GMMs[i].CompLikelihood(vvData[n]);
+		//		double dbi = GMMs[i].CompLikelihood(vvData[n]);
+		//		if(dbi > maxni)
+		//		{
+		//			maxni = dbi;
+		//			argmaxni = i;
+		//		}
+		//	}
+		//	recogClasses[n] = argmaxni;
+		//	//if(argmaxni != 0)
+		//	//{
+		//	//	if(maxni - GMMs[0].CompLikelihood(vvData[n]) < log(1.0))
+		//	//		recogClasses[n] = 0;
+		//	//}
+		//	
+		//	//if(recogClasses[n] != classes[n])
+		//	//{
+		//	//	ErrCount++;
+		//	//}
+		//}
+		//int nN = N / (WIDTH*HEIGHT);
+		//for(int nn = 0; nn < nN; nn++)
+		//{
+		//	vector<int> recogresn = vector<int>(WIDTH*HEIGHT, 0);
+		//	for(int mm = 0; mm < WIDTH*HEIGHT; mm++)
+		//	{
+		//		recogresn[mm] = recogClasses[nn * WIDTH*HEIGHT + mm];
+		//	}
+		//	vector<int> recogresn2;
+		//	GetLargestConnectedComponents(recogresn, recogresn2);
+		//	for(int mm = 0; mm < WIDTH*HEIGHT; mm++)
+			//        {
+			//                recogClasses[nn * WIDTH*HEIGHT + mm] = recogresn2[mm];
+			//        }
+		//}
+		int nTP = 0;
+		int nFP = 0;
+		int nFN = 0;
+		int nTN = 0;
+		int ErrCount = 0;
+		for(int n = 0; n < N; n++)
+		{
+			if(classes[n] == 1 && recogClasses[n] == 1)
+			{
+				nTP++;
+			}
+			if(classes[n] != 1 && recogClasses[n] == 1)
+			{
+				nFP++;
+			}
+			if(classes[n] == 1 && recogClasses[n] != 1)
+			{
+				nFN++;
+			}
+			if(classes[n] != 1 && recogClasses[n] != 1)
+			{
+				nTN++;
+			}
+			if(recogClasses[n] != classes[n])
+			{
+				ErrCount++;
+			}	
+		}
+		confres.resize(4);
+		confres[0] = nTP;
+		confres[1] = nFP;
+		confres[2] = nFN;
+		confres[3] = nTN;
+		Acc = (double)(N - ErrCount) / (double) N;
+		return 1;
+	}
+
+	static int Test2ClassesGMMs(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses)
+	{
+		return RecognizeByGMMs(vvData, GMMs, recogClasses);
+	}
+
+	static int Test2ClassesGMMsPart(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses)
+	{
+		return RecognizeByGMMsPart(vvData, GMMs, recogClasses);
+	}
+	
+	static int Test2ClassesGMMsFull(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses)
+	{
+		return RecognizeByGMMs(vvData, GMMs, recogClasses);
+	}	
+	
+	static int GMMBiasAdapt(vector< vector<double> >& vvData, matrix<double>& newmub, vector<GMM>& oldGMMs, vector<GMM>& newGMMs)
+	{
+		//==================================================================================//
+		// Get dimension and number of data
+		//==================================================================================//
+		int N = (int)vvData.size();
+		if(N < 1)
+		{
+			cerr<<"Empty Data vector for adaptation"<<endl;
+			return 0;
+		}
+		int D = (int)vvData[1].size();
+		for(int n = 0; n < N; n++)
+		{
+			int Dn = (int)vvData[n].size();
+			if(Dn != D)
+			{
+				cerr<<"Data components have different dimensions"<<endl;
+				return 0;
+			}
+		}
+		int I = (int) oldGMMs.size();
+		//==================================================================================//
+		// Compute posterior probability and get first recognition result
+		//==================================================================================//
+		vector< vector< vector<double> > > gammank = vector< vector< vector<double> > >(I);
+		for(int i = 0; i < I ; i++)
+		{
+			gammank[i] = vector< vector<double> >(N, vector<double>(D, 0.0));
+			for(int n = 0; n < N; n++)
+			{
+				oldGMMs[i].CompPosterioriPart(vvData[n], gammank[i][n], vDimConsidered);
+			}
+		}
+		vector<int> modelseq(N, 1);
+		for(int n = 0; n < N; n++)
+		{
+			double dbLik = LZERO;
+			for(int i = 0; i < I ; i++)
+			{
+				double db = oldGMMs[i].CompLikelihoodPart(vvData[n], vDimConsidered);
+				if(db > dbLik)
+				{
+					dbLik = db;
+					modelseq[n] = i;
+				}
+			}
+		}
+		//==================================================================================//
+		// EM core
+		//==================================================================================//
+		matrix<double> b1 = matrix<double>(D, D);
+		matrix<double> b2 = matrix<double>(D, 1);
+		b1.Null();
+		b2.Null();
+		matrix<double> oldb1 = matrix<double>(D, D);
+		matrix<double> oldb2 = matrix<double>(D, 1);
+		oldb1.Null();
+		oldb2.Null();
+		for(int n = 0; n < N; n++)
+		{
+			int modeli = modelseq[n];
+
+			matrix<double> mvec;
+			mvec.SetSize(D, 1);
+			for(size_t d = 0; d < D; d++)
+			{
+				mvec(d, 0) = vvData[n][d];
+			}
+
+			for(int k = 0; k < oldGMMs[modeli].m_nMixes; k++)
+			{
+	#ifndef DIAGONAL
+				b1 += gammank[modeli][n][k] * oldGMMs[modeli].m_vmdInvCovar[k];
+				b2 += gammank[modeli][n][k] * oldGMMs[modeli].m_vmdInvCovar[k] * (mvec - oldGMMs[modeli].m_vmdMean[k]);
+	#else
+				for(int d1 = 0; d1 < D; d1++)
+				{
+					b1(d1, d1) += gammank[modeli][n][k] * oldGMMs[modeli].m_vmdInvCovar[k](d1, d1);
+					b2(d1, 0) += gammank[modeli][n][k] * oldGMMs[modeli].m_vmdInvCovar[k](d1, d1) * (mvec(d1, 0) - oldGMMs[modeli].m_vmdMean[k](d1, 0));
+				}
+	#endif
+			}
+		}
+	#ifndef DIAGONAL
+		newmub = !b1 * b2;
+	#else
+		newmub.SetSize(D,1);
+		for(int d1 = 0; d1 < D; d1++)
+		{
+			newmub(d1, 0) = b2(d1, 0)/b1(d1, d1);
+		}
+	#endif
+		//==================================================================================//
+		// Update Model, M step
+		//==================================================================================//
+		newGMMs.resize(I);
+		for(int i = 0; i < I; i++)
+		{
+			newGMMs[i] = GMM(oldGMMs[i]);
+			for(int k = 0; k < newGMMs[i].m_nMixes; k++)
+			{
+				newGMMs[i].m_vmdMean[k] += newmub;
+			}
+		}
+		return 1;
+	}
+
+	static int GMMBiasAdapt2(vector< vector<double> >& vvData, matrix<double>& Sigmab, matrix<double>& newmub, matrix<double>& newSigmab, vector<GMM>& oldGMMs, vector<GMM>& newGMMs, int nIter)
+	{
+		//==================================================================================//
+		// Get dimension and number of data
+		//==================================================================================//
+		int N = (int)vvData.size();
+		if(N < 1)
+		{
+			cerr<<"Empty Data vector for adaptation"<<endl;
+			return 0;
+		}
+		int D = (int)vvData[1].size();
+		for(int n = 0; n < N; n++)
+		{
+			int Dn = (int)vvData[n].size();
+			if(Dn != D)
+			{
+				cerr<<"Data components have different dimensions"<<endl;
+				return 0;
+			}
+		}
+		int I = (int) oldGMMs.size();
+		//==================================================================================//
+		// Compute posterior probability and get first recognition result
+		//==================================================================================//
+		vector< vector< vector<double> > > gammank = vector< vector< vector<double> > >(I);
+		for(int i = 0; i < I ; i++)
+		{
+			gammank[i] = vector< vector<double> >(N);
+			for(int n = 0; n < N; n++)
+			{
+				 oldGMMs[i].CompPosterioriPart(vvData[n], gammank[i][n], vDimConsidered);//oldGMMs[i].CompPosteriori(vvData[n], gammank[i][n]);
+			}
+		}
+		vector<int> modelseq(N, 0);
+		for(int n = 0; n < N; n++)
+		{
+			double dbLik = 0;
+			for(int i = 0; i < I ; i++)
+			{
+				double db = oldGMMs[i].CompLikelihoodPart(vvData[n], vDimConsidered);//oldGMMs[i].CompLikelihood(vvData[n]);
+				if(db > dbLik)
+				{
+					dbLik = db;
+					modelseq[n] = i;
+				}
+			}
+		}
+		if(nIter == 0)
+		{
+			Sigmab.SetSize(D, D);
+			Sigmab.Null();
+			matrix<double> diagVar;
+			CompDiagVar(vvData, diagVar);
+			for(int n = 0; n < N; n++)
+			{
+				for(int k = 0; k < oldGMMs[modelseq[n]].m_nMixes; k++)
+				{
+					for(int d = 0; d < D; d++)
+					{
+						double dbnkd = oldGMMs[modelseq[n]].m_vmdCovar[k](d,d);
+						double dbnkd1 = diagVar(d,d);
+						double dbnkd2 = 0.001 * dbnkd;
+						if(dbnkd1 - dbnkd >= 0.001 * dbnkd)
+						{
+							dbnkd2 = dbnkd1 - dbnkd;
+						}
+						Sigmab(d,d) += gammank[modelseq[n]][n][k] * dbnkd2 / (double)N;
+					}
+				}
+			}
+		}
+
+		//==================================================================================//
+		// EM core
+		//==================================================================================//
+		matrix<double> b1 = matrix<double>(D, D);
+		matrix<double> b2 = matrix<double>(D, 1);
+		b1.Null();
+		b2.Null();
+		vector< matrix<double> > vmvec = vector< matrix<double> >(N);
+		double N2 = 0.0;
+		for(int n = 0; n < N; n++)
+		{
+			int modeli = modelseq[n];
+			vmvec[n].SetSize(D, 1);
+			for(size_t d = 0; d < D; d++)
+			{
+				vmvec[n](d, 0) = vvData[n][d];
+			}
+			for(int k = 0; k < oldGMMs[modeli].m_nMixes; k++)
+			{
+				N2 += gammank[modeli][n][k];
+				b1 += gammank[modeli][n][k] * oldGMMs[modeli].m_vmdInvCovar[k];
+				b2 += gammank[modeli][n][k] * oldGMMs[modeli].m_vmdInvCovar[k] * (vmvec[n] - oldGMMs[modeli].m_vmdMean[k]);
+			}
+		}
+		// Compute posteroir probability
+		newmub = !b1 * b2;
+		newSigmab.SetSize(D, D);
+		newSigmab.Null();
+		for(int n = 0; n < N; n++)
+		{
+			int modeli = modelseq[n];
+			for(int k = 0; k < oldGMMs[modeli].m_nMixes; k++)
+			{
+				matrix<double> Sigman = Sigmab + oldGMMs[modeli].m_vmdCovar[k];
+				matrix<double> InvSigman = !Sigman;
+				matrix<double> Eb = newmub + Sigmab * InvSigman * (vmvec[n] - newmub - oldGMMs[modeli].m_vmdMean[k]);
+				matrix<double> Eb2 = Sigmab *  InvSigman * oldGMMs[modeli].m_vmdCovar[k] + Eb * ~Eb;
+				newSigmab += gammank[modeli][n][k] / N2 * Eb2;
+			}
+			//Eb = mubp + (Sigmab * inv(Sigmab + sk)*(X(n,:) - mubp - gmms{i}.mu(k,:))')';
+			//Eb2 = Sigmab * inv(Sigmab + sk) * sk + Eb' * Eb;
+			//Sigmab2 = Sigmab2 + gammank{i}(n, k) * Eb2;
+
+		}
+		newSigmab -= newmub * ~newmub;
+		//==================================================================================//
+		// Update Model
+		//==================================================================================//
+		newGMMs.resize(I);
+		for(int i = 0; i < I; i++)
+		{
+			newGMMs[i] = GMM(oldGMMs[i]);
+			for(int k = 0; k < newGMMs[i].m_nMixes; k++)
+			{
+				newGMMs[i].m_vmdMean[k] += newmub;
+				if(newGMMs[i].m_szCovType == "diagonal")
+				{
+					for(int d = 0; d < D; d++)
+					{
+						if(newGMMs[i].m_vmdCovar[k](d,d) + newSigmab(d,d) > 0)
+						{
+							newGMMs[i].m_vmdCovar[k](d,d) += newSigmab(d,d);
+						}
+						else
+						{
+							newGMMs[i].m_vmdCovar[k](d,d) += 0;
+						}
+					}
+				}
+				else
+				{
+					newGMMs[i].m_vmdCovar[k] += newSigmab;
+				}
+			}
+		}
+		return 1;
+	}
+
+	static int GenEpsilon(matrix<double>& mat, int nDims, double eps)
+	{
+		mat.SetSize(nDims, nDims);
+		mat.Null();
+		for(int d = 0; d < nDims; d++)
+		{
+			mat(d, d) = eps;
+		}
+		return 1;
+	}
+
+	static int GMMAdaptRcogbyFrame(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vclasses, double& Acc, int nFrameSize)
+	{
+		vector<int> vrecogclasses(vclasses.size(), 0);
+		int N = (int)vvData.size();
+		int nN = (int) ceil((double)N / (double)nFrameSize );
+		int nErrCount = 0;
+		for(int n = 0; n < nN; n++)
+		{
+			int nStart = n * nFrameSize;
+			int nStop = min((n + 1) * nFrameSize - 1, N - 1);
+			if(nStart > nStop)
+			{
+				break;
+			}
+			vector< vector<double> > vvSub = vector< vector<double> >(nStop-nStart+1, vector<double>(vvData[0].size(), 0.0));
+			for(int i = nStart; i <= nStop; i++)
+			{
+				vvSub[i-nStart] = vvData[i];
+			}
+			//matrix<double> newmub;
+			//vector<GMM> newGMMs;
+			//GMMAdaptTool::GMMBiasAdapt(vvSub, newmub, oldGMMs, newGMMs);
+			vector<int> recogClassesn;
+			//GMMAdaptTool::Test2ClassesGMMs(vvSub, newGMMs, recogClassesn);
+			vector<int> recogClassesn2;
+			GMMAdaptTool::GMMAdaptRcogAFrame(oldGMMs, vvSub, recogClassesn);
+			GMMAdaptTool::GetLargestConnectedComponents(recogClassesn, recogClassesn2);
+			for(int i = nStart; i <= nStop; i++)
+			{
+				vrecogclasses[i] = recogClassesn2[i-nStart];
+				if(vrecogclasses[i] != vclasses[i])
+				{
+					nErrCount++;
+				}
+			}
+		}
+		Acc = (double)(N - nErrCount)/(double)N;
+		return 1;
+	}
+
+	static int GMMAdaptRcogbyFrame2(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vclasses, double& Acc, int nFrameSize)
+	{
+		vector<int> vrecogclasses(vclasses.size(), 0);
+		int N = (int)vvData.size();
+		int nN = (int) ceil((double)N / (double)nFrameSize );
+		int nErrCount = 0;
+		for(int n = 0; n < nN; n++)
+		{
+			int nStart = n * nFrameSize;
+			int nStop = min((n + 1) * nFrameSize - 1, N - 1);
+			if(nStart > nStop)
+			{
+				break;
+			}
+			vector< vector<double> > vvSub = vector< vector<double> >(nStop-nStart+1, vector<double>(vvData[0].size(), 0.0));
+			for(int i = nStart; i <= nStop; i++)
+			{
+				vvSub[i-nStart] = vvData[i];
+			}
+			matrix<double> newmub;
+			vector< vector<GMM> > vnewGMMs;
+			vnewGMMs.push_back(oldGMMs);
+			vector< matrix<double> > vnewSigmab;
+			vector< matrix<double> > vnewmub;
+			matrix<double> Sigmab;
+			// init Sigmab here
+			GMMAdaptTool::GenEpsilon(Sigmab, vvData[0].size(), 1);
+			vnewSigmab.push_back(Sigmab);
+			
+			for(int itr = 0; itr < NUMITERATION; itr++)
+			{
+				vector<GMM> newGMMs;
+				matrix<double> newmub;
+				matrix<double> newSigmab;
+				GMMAdaptTool::GMMBiasAdapt2(vvSub, vnewSigmab[itr], newmub, newSigmab, vnewGMMs[itr], newGMMs, itr);
+				vnewmub.push_back(newmub);
+				vnewSigmab.push_back(newSigmab);
+
+				//GMMBiasAdapt2(vvSub, newmub, vnewGMMs[itr], newGMMs);
+				vnewGMMs.push_back(newGMMs);
+			}
+			vector<int> recogClassesn;
+			GMMAdaptTool::Test2ClassesGMMs(vvSub, vnewGMMs[vnewGMMs.size() - 1], recogClassesn);
+			vector<int> recogClassesn2;
+			GMMAdaptTool::GetLargestConnectedComponents(recogClassesn, recogClassesn2);
+			for(int i = nStart; i <= nStop; i++)
+			{
+				vrecogclasses[i] = recogClassesn2[i-nStart];
+				if(vrecogclasses[i] != vclasses[i])
+				{
+					nErrCount++;
+				}
+			}
+		}
+		Acc = (double)(N - nErrCount)/(double)N;
+		return 1;
+	}
+
+	static int GMMAdaptRcogbyFrame(string GMMPaths, string DataPaths, double& Acc, int nFrameSize)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		vector< vector<double> > vvData;
+		vector<int> vClasses;
+		GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+		GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+		GMMAdaptTool::LoadLogData(DataPaths, vvData, vClasses);
+		return GMMAdaptTool::GMMAdaptRcogbyFrame(GMMs, vvData, vClasses, Acc, nFrameSize);
+	}
+
+	static int GMMAdaptRcogbyFrame2(string GMMPaths, string DataPaths, double& Acc, int nFrameSize)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		vector< vector<double> > vvData;
+		vector<int> vClasses;
+		GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+		GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+		GMMAdaptTool::LoadLogData(DataPaths, vvData, vClasses);
+		return GMMAdaptTool::GMMAdaptRcogbyFrame2(GMMs, vvData, vClasses, Acc, nFrameSize);
+	}
+
+	// Stochastic matching on feature space
+	static int GMMAdaptRcogAFrame(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vrecogclasses)
+	{
+		vrecogclasses.resize(vvData.size());
+		int nFrameSize = (int)vvData.size();
+		int nErrCount = 0;
+		int n = 0;
+		int nStart = 0;
+		int nStop = nFrameSize - 1;
+		matrix<double> newmub;
+		vector<GMM> newGMMs;
+		GMMAdaptTool::GMMBiasAdapt(vvData, newmub, oldGMMs, newGMMs);
+		GMMAdaptTool::Test2ClassesGMMs(vvData, newGMMs, vrecogclasses);
+		// Doing grouping elimination, pick the largest one
+		return 1;
+	}
+	
+	static void AutoLabelRGBOnly(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio, int& nHandModelIndex)
+	{
+		vector< vector<double> > vvData;
+		int yrange = ExtLowLevelImgFeature::ExtColorFeatureRGBOnly(szPath, vvData, shrinkratio);
+
+		//DWORD dw1 = 0, dw2 = 0;
+		//IplImage* pimg;
+		//pimg = cvLoadImage(szPath.c_str());
+		////IplImage* pfimg = cvCreateImage(cvSize(pimg->width, pimg->height), IPL_DEPTH_32F, pimg->nChannels);
+		//cv::Mat img = cv::Mat(pimg);
+		////cvConvert(pimg, pfimg);
+		//cv::Mat fimg; // = cv::Mat(pfimg);
+		//img.convertTo(fimg, CV_32FC3);
+		//
+		//int nratio = (int) shrinkratio;
+		//double dbBlkNum = (double)(img.cols * img.rows/ shrinkratio);
+		//double dbLLR = 1.0;
+		//int xrange = img.cols / shrinkratio;
+		//int yrange = img.rows / shrinkratio;
+		//mask = cv::Mat(yrange, xrange, CV_8UC1, cv::Scalar(0, 0, 0, 0));
+		//DWORD dwcol = 0; 
+		//DWORD dwrow = 0; 
+		//DWORD dwcvt = 0;
+		//DWORD dwmv = 0; 
+		//DWORD dwfet = 0; 
+		//DWORD dwlik = 0; 
+		//vector< vector<double> > vvData;
+
+		//for(int x = 0; x < xrange; x++)
+		//{
+		//	cv::Scalar fmeanxy, stddevxy;
+		//	cv::Scalar fmeanxyhsv, stddevxyhsv;
+		//	cv::Scalar fmeanxyx, stddevxyx;
+		//	cv::Scalar fmeanxyy, stddevxyy;
+		//	cv::Mat colx = fimg.colRange(x*shrinkratio, (x+1)*shrinkratio); 
+		//	// Compute color feature, note that 
+		//	// we only need some part of the feature
+		//	// but the current code is not flexible enough to just compute them
+		//	// so this may need to be changed to enhance speed
+		//	for(int y = 0; y < yrange; y++)
+		//	{	
+		//		cv::Mat sub = colx.rowRange(y*shrinkratio, (y+1)*shrinkratio);
+		//		cv::Mat sub8bits;
+		//		sub.convertTo(sub8bits, CV_8UC3);
+		//		cv::Mat subhsv;
+		//		cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+		//		cv::meanStdDev(sub, fmeanxy, stddevxy);
+		//		cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+		//		double dbBMean = fmeanxy.val[0];
+		//		double dbGMean = fmeanxy.val[1];
+		//		double dbRMean = fmeanxy.val[2];
+		//		vector<double> vdbTemp;
+		//		vdbTemp.push_back(dbBMean);
+		//		vdbTemp.push_back(dbGMean);
+		//		vdbTemp.push_back(dbRMean);
+		//		vvData.push_back(vdbTemp);
+		//	}
+		//}
+
+		vector<int> vrecogclasses;
+		// classifying skin/nonskin for thes blocks
+		vrecogclasses.resize(vvData.size());
+		Test2ClassesGMMsFull(vvData, vGMMs, vrecogclasses);
+		size_t nResultsSize = vrecogclasses.size();
+		mask = cv::Mat(yrange, nResultsSize/yrange, CV_8UC1);
+		for(size_t nn = 0; nn < nResultsSize; nn++)
+		{
+			int x = nn / yrange;
+			int y = nn - x * yrange;
+			uchar* uptr = mask.ptr<uchar>(y);
+			if(vrecogclasses[nn] == nHandModelIndex)
+			{
+				uptr[x] = 255;
+			}
+			else
+			{
+				uptr[x] = 0;
+			}
+		}
+		//cvReleaseImage(&pimg);
+		//cvReleaseImage(&pfimg);
+	}
+
+
+
+	static void AutoLabel_BS0(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio, int& nHandModelIndex, cv::Mat& ref)
+	{
+		vector< vector<double> > vvData;
+		//ExtLowLevelImgFeature::ExtColorFeatures_BS0(IplImage*& pimg, vector< vector<double> >& vvFeatures, int BLKSIZE, IplImage*& pRefImg, vector< vector<double> >& vvCorrs);
+		IplImage iplref = ref.operator IplImage();
+		IplImage* pref = &iplref;
+		vector< vector<double> > vvCorrs;
+		int yrange = ExtLowLevelImgFeature::ExtColorFeatures_BS0(szPath, vvData, shrinkratio, pref, vvCorrs);
+
+		//DWORD dw1 = 0, dw2 = 0;
+		//IplImage* pimg;
+		//pimg = cvLoadImage(szPath.c_str());
+		////IplImage* pfimg = cvCreateImage(cvSize(pimg->width, pimg->height), IPL_DEPTH_32F, pimg->nChannels);
+		//cv::Mat img = cv::Mat(pimg);
+		////cvConvert(pimg, pfimg);
+		//cv::Mat fimg; // = cv::Mat(pfimg);
+		//img.convertTo(fimg, CV_32FC3);
+		//
+		//int nratio = (int) shrinkratio;
+		//double dbBlkNum = (double)(img.cols * img.rows/ shrinkratio);
+		//double dbLLR = 1.0;
+		//int xrange = img.cols / shrinkratio;
+		//int yrange = img.rows / shrinkratio;
+		//mask = cv::Mat(yrange, xrange, CV_8UC1, cv::Scalar(0, 0, 0, 0));
+		//DWORD dwcol = 0; 
+		//DWORD dwrow = 0; 
+		//DWORD dwcvt = 0;
+		//DWORD dwmv = 0; 
+		//DWORD dwfet = 0; 
+		//DWORD dwlik = 0; 
+		//vector< vector<double> > vvData;
+
+		//for(int x = 0; x < xrange; x++)
+		//{
+		//	cv::Scalar fmeanxy, stddevxy;
+		//	cv::Scalar fmeanxyhsv, stddevxyhsv;
+		//	cv::Scalar fmeanxyx, stddevxyx;
+		//	cv::Scalar fmeanxyy, stddevxyy;
+		//	cv::Mat colx = fimg.colRange(x*shrinkratio, (x+1)*shrinkratio); 
+		//	// Compute color feature, note that 
+		//	// we only need some part of the feature
+		//	// but the current code is not flexible enough to just compute them
+		//	// so this may need to be changed to enhance speed
+		//	for(int y = 0; y < yrange; y++)
+		//	{	
+		//		cv::Mat sub = colx.rowRange(y*shrinkratio, (y+1)*shrinkratio);
+		//		cv::Mat sub8bits;
+		//		sub.convertTo(sub8bits, CV_8UC3);
+		//		cv::Mat subhsv;
+		//		cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+		//		cv::meanStdDev(sub, fmeanxy, stddevxy);
+		//		cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+		//		double dbBMean = fmeanxy.val[0];
+		//		double dbGMean = fmeanxy.val[1];
+		//		double dbRMean = fmeanxy.val[2];
+		//		vector<double> vdbTemp;
+		//		vdbTemp.push_back(dbBMean);
+		//		vdbTemp.push_back(dbGMean);
+		//		vdbTemp.push_back(dbRMean);
+		//		vvData.push_back(vdbTemp);
+		//	}
+		//}
+
+		vector<int> vrecogclasses;
+		// classifying skin/nonskin for thes blocks
+		vrecogclasses.resize(vvData.size());
+		Test2ClassesGMMsFull(vvData, vGMMs, vrecogclasses);
+		size_t nResultsSize = vrecogclasses.size();
+		mask = cv::Mat(yrange, nResultsSize/yrange, CV_8UC1);
+		for(size_t nn = 0; nn < nResultsSize; nn++)
+		{
+			int x = nn / yrange;
+			int y = nn - x * yrange;
+			uchar* uptr = mask.ptr<uchar>(y);
+			double Corr = 0.1140 * vvCorrs[nn][0] + 0.5870 * vvCorrs[nn][1] + 0.2989 * vvCorrs[nn][2];
+			if(vrecogclasses[nn] == nHandModelIndex && Corr < CCThreshold)
+			{
+				uptr[x] = 255;
+			}
+			else
+			{
+				uptr[x] = 0;
+			}
+		}
+		//cvReleaseImage(&pimg);
+		//cvReleaseImage(&pfimg);
+	}
+
+	static void AutoLabelHTKMAP_BS0_Fusion(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath, cv::Mat& ref, vector<GMM>& vFusionGMMs, bool bFrameBatch, int nAdaptMode, int nStartSeq, int nStopSeq)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		vector< vector< vector<double> > > vvvCorrs;
+		string szFolder = "";
+		string szDelim = "";
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		HTKGMMMAP_BS0_Fusion(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange, ref, vFusionGMMs, bFrameBatch, nAdaptMode, nStartSeq, nStopSeq);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+					int x = nn / yrange;
+					int y = nn - x * yrange;
+					uchar* uptr = vMasks[n].ptr<uchar>(y);
+					if(vvRecogClasses[n][nn] == nHandModelIndex)
+					{
+							uptr[x] = 255;
+					}
+					else
+					{
+							uptr[x] = 0;
+					}
+			}
+		}
+
+	}
+
+	static void AutoLabelHTKMAP_BS0_Fusion_with_Scores(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath, cv::Mat& ref, vector<GMM>& vFusionGMMs, bool bFrameBatch, int nAdaptMode, int nStartSeq, int nStopSeq, vector<cv::Mat>& vScore0, vector<cv::Mat>& vScore1)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		vector< vector< vector<double> > > vvvCorrs;
+		string szFolder = "";
+		string szDelim = "";
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		vector< vector<double> > vvScore0;
+		vector< vector<double> > vvScore1;
+		//HTKGMMMAP_BS0_Fusion(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange, ref, vFusionGMMs, bFrameBatch, nAdaptMode, nStartSeq, nStopSeq);
+		HTKGMMMAP_BS0_Fusion_With_Scores(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange, ref, vFusionGMMs, bFrameBatch, nAdaptMode, nStartSeq, nStopSeq, vvScore0, vvScore1);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		vScore0.resize(N);
+		vScore1.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			// Scores0
+			vScore0[n] = cv::Mat(cv::Size(xrange, yrange), CV_64FC1);
+			// Scores1
+			vScore1[n] = cv::Mat(cv::Size(xrange, yrange), CV_64FC1);
+			// Decision
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+					int x = nn / yrange;
+					int y = nn - x * yrange;
+					uchar* uptr = vMasks[n].ptr<uchar>(y);
+					double* ptr0 = vScore0[n].ptr<double>(y);
+					double* ptr1 = vScore1[n].ptr<double>(y);
+					ptr0[x] = vvScore0[n][nn];
+					ptr1[x] = vvScore1[n][nn];
+					if(vvRecogClasses[n][nn] == nHandModelIndex)
+					{
+							uptr[x] = 255;
+					}
+					else
+					{
+							uptr[x] = 0;
+					}
+			}
+		}
+
+	}
+
+	static void Approx_AutoLabel_BS0(string szPath, bool*** vvvDecisionTable, cv::Mat& mask, int shrinkratio, int& nHandModelIndex, cv::Mat& ref)
+	{
+		vector< vector<double> > vvData;
+		IplImage iplref = ref.operator IplImage();
+		IplImage* pref = &iplref;
+		vector< vector<double> > vvCorrs;
+		int yrange = ExtLowLevelImgFeature::ExtColorFeatures_BS0(szPath, vvData, shrinkratio, pref, vvCorrs);
+
+		vector<int> vrecogclasses;
+		// classifying skin/nonskin for thes blocks
+		vrecogclasses.resize(vvData.size());
+		ApproxRecognizeByTable(vvData, vvvDecisionTable, vrecogclasses);
+		size_t nResultsSize = vrecogclasses.size();
+		mask = cv::Mat(yrange, nResultsSize/yrange, CV_8UC1);
+		for(size_t nn = 0; nn < nResultsSize; nn++)
+		{
+			int x = nn / yrange;
+			int y = nn - x * yrange;
+			uchar* uptr = mask.ptr<uchar>(y);
+			double Corr = 0.1140 * vvCorrs[nn][0] + 0.5870 * vvCorrs[nn][1] + 0.2989 * vvCorrs[nn][2];
+			if(vrecogclasses[nn] == nHandModelIndex && Corr < CCThreshold)
+			{
+				uptr[x] = 255;
+			}
+			else
+			{
+				uptr[x] = 0;
+			}
+		}
+		//cvReleaseImage(&pimg);
+		//cvReleaseImage(&pfimg);
+
+	}
+
+	static void AutoLabelHTKMAPPerFrame(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		string szFolder = "";
+		string szDelim = "";
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+                struct stat st;
+                if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		HTKGMMAdaptPerFrame(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+				int x = nn / yrange;
+				int y = nn - x * yrange;
+				uchar* uptr = vMasks[n].ptr<uchar>(y);
+				if(vvRecogClasses[n][nn] == nHandModelIndex)
+				{
+					uptr[x] = 255;
+				}
+				else
+				{
+					uptr[x] = 0;
+				}
+			}
+		}
+	}
+
+	static void AutoLabelHTKMAPASeq(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		string szFolder = "";
+		string szDelim = "";
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		HTKGMMAdaptASeq(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+				int x = nn / yrange;
+				int y = nn - x * yrange;
+				uchar* uptr = vMasks[n].ptr<uchar>(y);
+				if(vvRecogClasses[n][nn] == nHandModelIndex)
+				{
+					uptr[x] = 255;
+				}
+				else
+				{
+					uptr[x] = 0;
+				}
+			}
+		}
+	}
+	static void AutoLabelSMAPPerFrame(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		HTKGMMSMAPPerFrame(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+				int x = nn / yrange;
+				int y = nn - x * yrange;
+				uchar* uptr = vMasks[n].ptr<uchar>(y);
+				if(vvRecogClasses[n][nn] == nHandModelIndex)
+				{
+					uptr[x] = 255;
+				}
+				else
+				{
+					uptr[x] = 0;
+				}
+			}
+		}
+	}
+
+	static void AutoLabelSMAPPerFrame_BS0(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath, cv::Mat& ref)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		vector< vector< vector<double> > > vvvCorrs;
+		string szFolder = "";
+		string szDelim = "";
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		HTKGMMSMAPPerFrame_BS0(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange, ref, vvvCorrs);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+				int x = nn / yrange;
+				int y = nn - x * yrange;
+				uchar* uptr = vMasks[n].ptr<uchar>(y);
+				if(vvRecogClasses[n][nn] == nHandModelIndex)
+				{
+						uptr[x] = 255;
+				}
+				else
+				{
+						uptr[x] = 0;
+				}
+			}
+		}
+	}
+
+
+	static void AutoLabelSMAPASeq(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		string szFolder = "";
+		string szDelim = "";
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		HTKGMMSMAPASeq(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+				int x = nn / yrange;
+				int y = nn - x * yrange;
+				uchar* uptr = vMasks[n].ptr<uchar>(y);
+				if(vvRecogClasses[n][nn] == nHandModelIndex)
+				{
+					uptr[x] = 255;
+				}
+				else
+				{
+					uptr[x] = 0;
+				}
+			}
+		}
+	}
+
+	static void AutoLabelSMAPASeq_BS0(vector<string>& vszImagePathNames, vector<GMM>& vGMMs, vector<cv::Mat>& vMasks, int shrinratio, int& nHandModelIndex, string& GMMPath, cv::Mat& ref)
+	{
+		string szFEFolder;
+		vector< vector<int> > vvRecogClasses;
+		vector<string> vszLoadadFiles;
+		vector< vector<int> > vvxyrange;
+		vector< vector< vector<double> > > vvvCorrs;
+		string szFolder = "";
+		string szDelim = "";
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		HTKGMMSMAPASeq_BS0(vGMMs, GMMPath, szFEFolder, vszImagePathNames, vvRecogClasses, vszLoadadFiles, shrinratio, vvxyrange, ref, vvvCorrs);
+		size_t N = vvRecogClasses.size();
+		vMasks.resize(N);
+		for(size_t n = 0; n < N; n++)
+		{
+			size_t nResultsSize = vvRecogClasses[n].size();
+			int xrange = (vvxyrange[n][0] / shrinratio);
+			int yrange = (vvxyrange[n][1] / shrinratio);
+			vMasks[n] = cv::Mat(cv::Size(xrange, yrange), CV_8UC1);
+			for(size_t nn = 0; nn < nResultsSize; nn++)
+			{
+					int x = nn / yrange;
+					int y = nn - x * yrange;
+					uchar* uptr = vMasks[n].ptr<uchar>(y);
+					if(vvRecogClasses[n][nn] == nHandModelIndex)
+					{
+							uptr[x] = 255;
+					}
+					else
+					{
+							uptr[x] = 0;
+					}
+			}
+		}
+	}
+
+
+
+	// Get skin/nonskin color label, only consider RGB mean
+	static void AutoLabelPart(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio, int& nHandModelIndex)
+	{
+		vector< vector<double> > vvData;
+		int yrange = ExtLowLevelImgFeature::ExtColorFeatureRGBOnly(szPath, vvData, shrinkratio);
+
+		//DWORD dw1 = 0, dw2 = 0;
+		//IplImage* pimg;
+		//pimg = cvLoadImage(szPath.c_str());
+		//cv::Mat img(pimg);
+		//cv::Mat fimg;
+		//img.convertTo(fimg, CV_32FC3);
+		//int nratio = (int) shrinkratio;
+		//double dbBlkNum = (double)(img.cols * img.rows/ shrinkratio);
+		//double dbLLR = 1.0;
+		//int xrange = img.cols / shrinkratio;
+		//int yrange = img.rows / shrinkratio;
+		//mask = cv::Mat(yrange, xrange, CV_8UC1, cv::Scalar(0, 0, 0, 0));
+		//DWORD dwcol = 0; 
+		//DWORD dwrow = 0; 
+		//DWORD dwcvt = 0;
+		//DWORD dwmv = 0; 
+		//DWORD dwfet = 0; 
+		//DWORD dwlik = 0; 
+		//vector< vector<double> > vvData;
+
+		//for(int x = 0; x < xrange; x++)
+		//{
+		//	cv::Scalar fmeanxy, stddevxy;
+		//	cv::Scalar fmeanxyhsv, stddevxyhsv;
+		//	cv::Scalar fmeanxyx, stddevxyx;
+		//	cv::Scalar fmeanxyy, stddevxyy;
+		//	cv::Mat colx = fimg.colRange(x*shrinkratio, (x+1)*shrinkratio); 
+		//	// Compute color feature, note that 
+		//	// we only need some part of the feature
+		//	// but the current code is not flexible enough to just compute them
+		//	// so this may need to be changed to enhance speed
+		//	for(int y = 0; y < yrange; y++)
+		//	{	
+		//		cv::Mat sub = colx.rowRange(y*shrinkratio, (y+1)*shrinkratio);
+		//		cv::Mat sub8bits;
+		//		sub.convertTo(sub8bits, CV_8UC3);
+		//		cv::Mat subhsv;
+		//		cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+		//		cv::meanStdDev(sub, fmeanxy, stddevxy);
+		//		cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+		//		double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+		//		double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+		//		double dbBMean = fmeanxy.val[0];
+		//		double dbGMean = fmeanxy.val[1];
+		//		double dbRMean = fmeanxy.val[2];
+		//		double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+		//		double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+		//		double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+		//		double dbVMean = fmeanxyhsv.val[2];
+		//		double dbSMean = fmeanxyhsv.val[1];
+		//		double dbHMean = fmeanxyhsv.val[0];
+		//		vector<double> vdbTemp;
+		//		vdbTemp.push_back(dbAvgStdev);
+		//		vdbTemp.push_back(dbIMean);
+		//		vdbTemp.push_back(dbBMean);
+		//		vdbTemp.push_back(dbGMean);
+		//		vdbTemp.push_back(dbRMean);
+		//		vdbTemp.push_back(dbExBMean);
+		//		vdbTemp.push_back(dbExGMean);
+		//		vdbTemp.push_back(dbExRMean);
+		//		vdbTemp.push_back(dbVMean);
+		//		vdbTemp.push_back(dbSMean);
+		//		vdbTemp.push_back(dbHMean);
+		//		vvData.push_back(vdbTemp);
+		//	}
+		//}
+		vector<int> vrecogclasses;
+		// classifying skin/nonskin for thes blocks
+		vrecogclasses.resize(vvData.size());
+		Test2ClassesGMMsPart(vvData, vGMMs, vrecogclasses);
+		size_t nResultsSize = vrecogclasses.size();
+		for(size_t nn = 0; nn < nResultsSize; nn++)
+		{
+			int x = nn / yrange;
+			int y = nn - x * yrange;
+			uchar* uptr = mask.ptr<uchar>(y);
+			if(vrecogclasses[nn] == nHandModelIndex)
+			{
+				uptr[x] = 255;
+			}
+			else
+			{
+				uptr[x] = 0;
+			}
+		}
+		//cvReleaseImage(&pimg);
+	}
+
+	// Get skin/nonskin color label with stochastic feature matching
+	static void AutoLabelPartSM(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio, int& nHandModelIndex)
+	{
+		vector< vector<double> > vvData;
+		int yrange = ExtLowLevelImgFeature::ExtColorFeatureRGBOnly(szPath, vvData, shrinkratio);
+
+		//DWORD dw1 = 0, dw2 = 0;
+		//IplImage* pimg;
+		//pimg = cvLoadImage(szPath.c_str());
+		//cv::Mat img(pimg);
+		//cv::Mat fimg;
+		//img.convertTo(fimg, CV_32FC3);
+		//int nratio = (int) shrinkratio;
+		//double dbBlkNum = (double)(img.cols * img.rows/ shrinkratio);
+		//double dbLLR = 1.0;
+		//int xrange = img.cols / shrinkratio;
+		//int yrange = img.rows / shrinkratio;
+		//mask = cv::Mat(yrange, xrange, CV_8UC1, cv::Scalar(0, 0, 0, 0));
+		//DWORD dwcol = 0; 
+		//DWORD dwrow = 0; 
+		//DWORD dwcvt = 0;
+		//DWORD dwmv = 0; 
+		//DWORD dwfet = 0; 
+		//DWORD dwlik = 0; 
+		//vector< vector<double> > vvData;
+
+		//for(int x = 0; x < xrange; x++)
+		//{
+		//	cv::Scalar fmeanxy, stddevxy;
+		//	cv::Scalar fmeanxyhsv, stddevxyhsv;
+		//	cv::Scalar fmeanxyx, stddevxyx;
+		//	cv::Scalar fmeanxyy, stddevxyy;
+		//	cv::Mat colx = fimg.colRange(x*shrinkratio, (x+1)*shrinkratio); 
+		//	// Compute color feature, note that 
+		//	// we only need some part of the feature
+		//	// but the current code is not flexible enough to just compute them
+		//	// so this may need to be changed to enhance speed
+		//	for(int y = 0; y < yrange; y++)
+		//	{	
+		//		cv::Mat sub = colx.rowRange(y*shrinkratio, (y+1)*shrinkratio);
+		//		cv::Mat sub8bits;
+		//		sub.convertTo(sub8bits, CV_8UC3);
+		//		cv::Mat subhsv;
+		//		cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+		//		cv::meanStdDev(sub, fmeanxy, stddevxy);
+		//		cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+		//		double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+		//		double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+		//		double dbBMean = fmeanxy.val[0];
+		//		double dbGMean = fmeanxy.val[1];
+		//		double dbRMean = fmeanxy.val[2];
+		//		double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+		//		double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+		//		double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+		//		double dbVMean = fmeanxyhsv.val[2];
+		//		double dbSMean = fmeanxyhsv.val[1];
+		//		double dbHMean = fmeanxyhsv.val[0];
+		//		vector<double> vdbTemp;
+		//		vdbTemp.push_back(dbAvgStdev);
+		//		vdbTemp.push_back(dbIMean);
+		//		vdbTemp.push_back(dbBMean);
+		//		vdbTemp.push_back(dbGMean);
+		//		vdbTemp.push_back(dbRMean);
+		//		vdbTemp.push_back(dbExBMean);
+		//		vdbTemp.push_back(dbExGMean);
+		//		vdbTemp.push_back(dbExRMean);
+		//		vdbTemp.push_back(dbVMean);
+		//		vdbTemp.push_back(dbSMean);
+		//		vdbTemp.push_back(dbHMean);
+		//		vvData.push_back(vdbTemp);
+		//	}
+		//}
+
+		vector<int> vrecogclasses0;
+		vector<int> vrecogclasses;
+		// classifying skin/nonskin for thes blocks
+		GMMAdaptRcogAFrame(vGMMs, vvData, vrecogclasses);
+		size_t nResultsSize = vrecogclasses.size();
+		for(size_t nn = 0; nn < nResultsSize; nn++)
+		{
+			int x = nn / yrange;
+			int y = nn - x * yrange;
+			uchar* uptr = mask.ptr<uchar>(y);
+			if(vrecogclasses[nn] == nHandModelIndex)
+			{
+				uptr[x] = 255;
+			}
+			else
+			{
+				uptr[x] = 0;
+			}
+		}
+		//cvReleaseImage(&pimg);
+	}
+	
+	static int GMMHTKMAPBySCP(string GMMPaths, string DataSCPPaths, double& Acc)
+	{
+		unordered_map<string, GMM> hGMMs;
+			vector<GMM> GMMs;
+			GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+			GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+		
+		char caBuf1[4096];
+		char caBuf2[4096];
+		memset(caBuf1, 0, 4096);
+		memset(caBuf2, 0, 4096);
+		ifstream fin;
+		fin.open(DataSCPPaths.c_str());
+		string szTmp = DataSCPPaths + "_Tmp";
+		string szTmpMLF = DataSCPPaths + "_Tmp.mlf";
+		//string HERest = "/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+		//string config = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+		//string words = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+		//string GMMCopy = GMMPaths + "_Tmp";
+		//string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+		string GMMCopy = GMMPaths + "_Tmp";
+	#ifdef _MSC_VER
+		string HERest = "C:\\CollectedDataCopy\\recognizer\\HTK\\bin.win32\\HERest.exe";
+		string config = "H:\\Transfer\\AdjustGMMNew\\config";
+		string words = "H:\\Transfer\\AdjustGMMNew\\words";
+		string szCopyGMM = "copy " + GMMPaths + " " + GMMCopy;
+	#elif defined(__GNUC__)
+		string HERest = "HERest"; //"/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+		string config = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/config"; //"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+		string words = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/words"; //"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+		string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+	#endif
+		Acc = 0.0;
+		double Acc0 = 0.0;
+		double N_1 = 0;
+		if(fin.is_open())
+		{
+			while(fin.getline(caBuf2, 4096) && fin.getline(caBuf1, 4096))
+			{
+				
+							string szHand(caBuf1);
+							string szBkGnd(caBuf2);
+				if(szHand[szHand.length() - 1] == '\r' || szHand[szHand.length() - 1] == '\n')
+				{
+					caBuf1[szHand.length() - 1] = '\0';
+					szHand = caBuf1;
+				}
+							if(szBkGnd[szBkGnd.length() - 1] == '\r' || szBkGnd[szBkGnd.length() - 1] == '\n')
+							{
+									caBuf2[szBkGnd.length() - 1] = '\0';
+					szBkGnd = caBuf2;
+							}
+				ofstream fout;
+				fout.open(szTmp.c_str());
+				if(!fout.is_open())
+				{
+					cerr<<"Cannot Open Temp File so stop it"<<endl;
+					return -1;
+				}
+				fout<<caBuf1<<endl<<caBuf2<<endl;
+				fout.close();
+				ofstream fout02;
+				fout02.open(szTmpMLF.c_str());
+				if(!fout02.is_open())
+				{
+					cerr<<"Cannot open mlf file for written!"<<endl;
+					return -1;
+				}
+				fout02<<"#!MLF!#"<<endl;
+							vector< vector<double> > vvDataHand;
+							vector< vector<double> > vvDataBkGnd;			
+							GMMAdaptTool::ReadHTKMFCCFeature(vvDataHand, szHand);
+							GMMAdaptTool::ReadHTKMFCCFeature(vvDataBkGnd, szBkGnd);
+				if(vvDataHand.size())
+				{
+					string szOutFileName1;
+					int nPos001 = szHand.find_last_of("/");
+					int nPos002 = szHand.find_last_of(".");
+					szOutFileName1 = szHand.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+					fout02<<"\"*/"<<szOutFileName1<<".lab\""<<endl;
+					fout02<<"Hand\n.\n";
+				}
+				if(vvDataBkGnd.size())
+				{
+									string szOutFileName2;
+									int nPos001 = szBkGnd.find_last_of("/");
+									int nPos002 = szBkGnd.find_last_of(".");
+									szOutFileName2 = szBkGnd.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+									fout02<<"\"*/"<<szOutFileName2<<".lab\""<<endl;
+									fout02<<"BkGnd\n.\n";			
+				}
+				fout02.close();
+				system(szCopyGMM.c_str());
+				string sysCmd = HERest;
+				sysCmd.append(" -C ");
+				sysCmd.append(config);
+				sysCmd.append(" -S ");
+				sysCmd.append(szTmp);
+				sysCmd.append(" -I ");
+				sysCmd.append(szTmpMLF);
+				sysCmd.append(" -H ");
+				sysCmd.append(GMMCopy);
+				sysCmd.append(" -u mpw ");
+				sysCmd.append(words);					
+				system(sysCmd.c_str());
+				unordered_map<string, GMM> hGMMsTmp;
+				vector<GMM> GMMsTmp;
+				GMMAdaptTool::LoadGMM(GMMCopy, hGMMsTmp);
+				GMMAdaptTool::GMMHash2VectBH(hGMMsTmp, GMMsTmp);
+				double AccHand = 0.0;
+				double AccBkGnd = 0.0;
+				double AccHand0 = 0.0;
+				double AccBkGnd0 = 0.0;
+				if(vvDataHand.size())
+				{
+					vector<int> vHandClasses(vvDataHand.size(), 1);
+					vector<int> vRecogHandClasses, vRecogHandClasses0;
+					vector<int> confres, confres0;
+					Test2ClassesGMMs(vvDataHand, vHandClasses, GMMsTmp, vRecogHandClasses, AccHand, confres);
+					Test2ClassesGMMs(vvDataHand, vHandClasses, GMMs, vRecogHandClasses0, AccHand0, confres0);
+				}
+				if(vvDataBkGnd.size())
+				{
+					vector<int> vBkGndClasses(vvDataBkGnd.size(), 0);
+					vector<int> vRecogBkGndClasses, vRecogBkGndClasses0;
+					vector<int> confres, confres0;
+					Test2ClassesGMMs(vvDataBkGnd, vBkGndClasses, GMMsTmp, vRecogBkGndClasses, AccBkGnd, confres);
+					Test2ClassesGMMs(vvDataBkGnd, vBkGndClasses, GMMs, vRecogBkGndClasses0, AccBkGnd0, confres0);
+				}
+				double N1 = (double) vvDataHand.size();
+				double N2 = (double) vvDataBkGnd.size();
+				double Accn = (AccHand * N1 + AccBkGnd * N2)/(N1+N2);
+				double Accn0 = (AccHand0 * N1 + AccBkGnd0 * N2)/(N1+N2);
+				Acc = (Accn * (N1+N2) + Acc * N_1)/(N_1+N1+N2);
+				Acc0 = (Accn0 * (N1+N2) + Acc0 * N_1)/(N_1+N1+N2);
+				N_1 += (N1+N2);
+			}
+			fin.close();
+			cout<<"Original accuracy is "<<Acc0<<endl;
+			cout<<"After framewise adjustment, accuracy is "<<Acc<<endl;
+		}
+		return 0;
+	}
+
+	static int GMMHTKMAPBySCP2(string GMMPaths, string DataSCPPaths, double& Acc)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+		GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+		char caBuf1[4096];
+		char caBuf2[4096];
+		memset(caBuf1, 0, 4096);
+
+		memset(caBuf2, 0, 4096);
+		ifstream fin;
+		fin.open(DataSCPPaths.c_str());
+		string szTmp = DataSCPPaths + "_Tmp";
+		string szTmpMLF = DataSCPPaths + "_Tmp.mlf";
+		//string HERest = "/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+		//string config = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+		//string words = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+		//string GMMCopy = GMMPaths + "_Tmp";
+		//string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+		string GMMCopy = GMMPaths + "_Tmp";
+	#ifdef _MSC_VER
+		string HERest = "C:\\CollectedDataCopy\\recognizer\\HTK\\bin.win32\\HERest.exe";
+		string config = "H:\\Transfer\\AdjustGMMNew\\config";
+		string words = "H:\\Transfer\\AdjustGMMNew\\words";
+		string szCopyGMM = "copy " + GMMPaths + " " + GMMCopy;
+	#elif defined(__GNUC__)
+		string HERest = "HERest"; //"/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+		string config = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/config";//"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+		string words = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/words";//"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+		string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+	#endif
+		Acc = 0.0;
+		double N_1 = 0;
+		unordered_map< string, vector<string> > hvFiles;
+		vector<string> vszKeys;
+		double Acc0 = 0;
+		if(fin.is_open())
+		{
+			while(fin.getline(caBuf1, 4096))
+			{
+							string sz1(caBuf1);
+				if(caBuf1[sz1.length() - 1] == '\r' || caBuf1[sz1.length() - 1] == '\n')
+				{
+					caBuf1[sz1.length() - 1] = '\0';
+					sz1 = caBuf1;
+				}
+							int nPos01 = (int)sz1.find_last_of("_");
+							int nPos00 = (int)sz1.find_last_of("/");
+							string szSub1 = sz1.substr(nPos00 + 1, nPos01 - nPos00 - 1);
+							int nPos02 = (int) szSub1.find_last_of("_");
+							string szKey = szSub1.substr(0, nPos02);
+				if(hvFiles.find(szKey) == hvFiles.end())
+				{
+					vszKeys.push_back(szKey);
+				}
+				hvFiles[szKey].push_back(sz1);
+			}
+			fin.close();
+			for(size_t n = 0; n < vszKeys.size(); n++)
+			{
+				size_t nFiles = hvFiles[vszKeys[n]].size();
+				ofstream fout001, fout002;
+				fout001.open(szTmp.c_str());
+				fout002.open(szTmpMLF.c_str());
+				double Accn = 0.0;
+				if(!fout001.is_open())
+				{
+					cerr<<"Cannot open scp file for writing"<<endl;
+					return -1;
+				}
+				if(!fout002.is_open())
+				{
+					cerr<<"Cannot open mlf file for writing"<<endl;
+					return -1;
+				}
+				fout002<<"#!MLF!#"<<endl;
+				vector< vector<double> > vvData;
+				vector<int> vClasses, vRecogClasses;
+				for(size_t m = 0; m < nFiles; m++)
+				{
+					vector< vector<double> > vvDatam;
+					string szName = hvFiles[vszKeys[n]][m];
+					GMMAdaptTool::ReadHTKMFCCFeature(vvDatam, szName);
+					fout001<<szName<<endl;
+					int nPos0001 = (int)szName.find_last_of("/");
+					int nPos0002 = (int)szName.find_last_of(".");
+					string szNameSub = szName.substr(nPos0001 + 1, nPos0002 - nPos0001 - 1);
+					int c = 0;
+					fout002<<"\"*/"<<szNameSub<<".lab\""<<endl;
+					if(0 <= (int)szName.find("Hand"))
+					{
+						c = 1;
+						fout002<<"Hand\n.\n";
+					}
+					else
+					{
+						fout002<<"BkGnd\n.\n";
+					}
+					for(size_t i = 0; i < vvDatam.size(); i++)
+					{
+						vvData.push_back(vvDatam[i]);
+						vClasses.push_back(c);	
+					}
+					
+				}
+				fout001.close();
+				fout002.close();
+				system(szCopyGMM.c_str());
+							string sysCmd = HERest;
+							sysCmd.append(" -C ");
+							sysCmd.append(config);
+							sysCmd.append(" -S ");
+							sysCmd.append(szTmp);
+							sysCmd.append(" -I ");
+							sysCmd.append(szTmpMLF);
+							sysCmd.append(" -H ");
+							sysCmd.append(GMMCopy);
+							sysCmd.append(" -u mpw ");
+							sysCmd.append(words);
+							system(sysCmd.c_str());
+				unordered_map<string, GMM> hGMMsTmp;
+				vector<GMM> GMMsTmp;
+				GMMAdaptTool::LoadGMM(GMMCopy, hGMMsTmp);
+				GMMAdaptTool::GMMHash2VectBH(hGMMsTmp, GMMsTmp);
+				vector<int> vRecogClasses0;
+				double Accn0 = 0.0;
+				vector<int> confres0, confres;
+				Test2ClassesGMMs(vvData, vClasses, GMMs, vRecogClasses0, Accn0, confres0);
+				Test2ClassesGMMs(vvData, vClasses, GMMsTmp, vRecogClasses, Accn, confres);							
+				double Nn = (double)vClasses.size();
+				Acc0 = (Accn0 * Nn + Acc0 * N_1)/(N_1 + Nn);
+				Acc = (Accn * Nn + Acc * N_1)/(N_1 + Nn);
+				N_1 += Nn;
+			}	
+			fin.close();
+			cout<<"Original accuracy is "<<Acc0<<endl;
+			cout<<"After adjust through all frames, accuracy is "<<Acc<<endl;
+		}
+		return 0;
+	}
+
+
+	static int GMMHTKMAPByLABTestNonSkinAdaptOnly(string GMMPaths, string DataLABPaths, string szRefImgList, double& Acc, ofstream& fout)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+		GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+		int nPos0001 = DataLABPaths.find_last_of("/");
+		int nPob0001 = DataLABPaths.find_last_of("\\");
+		int nPos01 = (nPob0001>nPos0001)?nPob0001:nPos0001;
+		string szCurrFolder = DataLABPaths.substr(0, nPos01);
+		string szDelim = "";
+		if(nPos01 == nPob0001) szDelim = "\\";
+		else if(nPos01 == nPos0001) szDelim = "/";
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		string sysMkDirFE = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(sysMkDirFE.c_str());
+		string szTmp = DataLABPaths + "_Tmp";
+		string szTmpMLF = DataLABPaths + "_Tmp.mlf";
+		string GMMCopy = GMMPaths + "_Tmp";
+		string GMMCopyCopy  = GMMPaths + "_TmpTmp";
+	#ifdef _MSC_VER
+		string HERest = "C:\\CollectedDataCopy\\recognizer\\HTK\\bin.win32\\HERest.exe";
+		string config = "H:\\Transfer\\AdjustGMMNew\\config";
+		string words = "H:\\Transfer\\AdjustGMMNew\\words";
+		string szCopyGMM = "copy " + GMMPaths + " " + GMMCopy;
+	#elif defined(__GNUC__)
+		string HERest = "HERest"; //"/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+		string config = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/config";//"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+		string words = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/words"; //"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+		string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+	#endif
+		string sysCmd = HERest;
+		sysCmd.append(" -C ");
+		sysCmd.append(config);
+		sysCmd.append(" -S ");
+		sysCmd.append(szTmp);
+		sysCmd.append(" -I ");
+		sysCmd.append(szTmpMLF);
+		sysCmd.append(" -H ");
+		string sysCmd2 = sysCmd;
+		sysCmd.append(GMMCopy);
+		sysCmd.append(" -u mpw ");
+		sysCmd.append(words);					
+		sysCmd2.append(GMMCopy);
+		sysCmd2.append(" -u mpw ");
+		sysCmd2.append(words);					
+		Acc = 0.0;
+		double Acc0 = 0.0;
+		double N_1 = 0;
+		int BLKSIZE = 16;
+		// Now, load label
+		int nCountX = 0;
+		int nCountO = 0;
+		unordered_map<string, int> hszJPGFiles;
+		unordered_map<string, int> hszJPGFiles1;
+		unordered_map<string, int> hszJPGFiles0;
+		//unordered_map<string, int> hszCurrJPGFiles;
+		//unordered_map<string, JPGLabelInfo> hJPGLavelInfo;
+		//unordered_map< string, vector<int> > hJPGClasses;
+		//vector<string> vszKeyOrder;
+		string szLabelPathName = DataLABPaths;
+		//unordered_map<string, unordered_map<string, int> > hhTrainFiles;
+
+		//int nCountO1 = 0;
+		//int nCountX1 = 0;
+		//int nCountO10 = 0;
+		//int nCountX10 = 0;
+		//unordered_map<string, JPGLabelInfo> hJPGLavelInfo1;
+		//unordered_map<string, JPGLabelInfo> hJPGLavelInfo0;
+		LoadJPGLabelInfo lb, lb0, lb1;
+		string szLabelPathName1 = DataLABPaths + "_BKGNDMAPPFHTK";
+		string szLabelPathName0 = DataLABPaths + "_Orig01";
+		//==============================================================================//
+		// inserted, 6/7/2011 You-Chi Cheng
+		//===============================================================================//
+		vector<string> vszKeyOrderTmp;
+		//===============================================================================//
+		//GMMAdaptTool::LoadJPGInfo(BLKSIZE, 4, nCountX, nCountO,
+		//							hszJPGFiles,
+		//							//hszCurrJPGFiles,
+		//							hJPGLavelInfo,
+		//							hJPGClasses, 
+		//							vszKeyOrderTmp,
+		//							szLabelPathName,
+		//							hhTrainFiles);
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		//==============================================================================//
+		// inserted, 6/7/2011 You-Chi Cheng
+		//===============================================================================//
+		FixlabelInfoByRefFileList(lb.m_hJPGLavelInfo, lb.m_hJPGClasses, lb.m_vszKeyOrder, szRefImgList, BLKSIZE);
+		unordered_map<string, int> hSeqStart;
+		unordered_map<string, int> hSeqStop;
+		unordered_map<string, vector<string> > hvSeqs;
+		vector<string> vSeqs;
+		TestImageStartStop(lb.m_vszKeyOrder, hSeqStart, hSeqStop, hvSeqs, vSeqs);
+		// New Version:
+		vector< vector<double> > vvCurrFeaturesTmp0001;
+		for(size_t n = 0; n < vSeqs.size(); n++)
+		{
+			// Adaptation using estimated background only:
+			vector< vector<double> > vvRecog1Tmp0001;
+			string szCurrFE01Tmp = szFEFolder + vSeqs[n] +"_BkGnd_Not_Skin.fe";	
+			for(size_t i = 0; i < hSeqStart[vSeqs[n]]; i++)
+			{
+				string szCurrFilePath = hvSeqs[vSeqs[n]][i];
+				string szImagePath;
+				string szImageName;
+				string szSeqName;
+				string szExt;
+				GetFileNameInfo(szCurrFilePath, szImagePath, szImageName, szSeqName, szExt);
+				vector<int> vTmpRecogClasses0001;
+				double Accn0Tmp = 0.0;
+				JPGLabelInfo* pinfo = &lb.m_hJPGLavelInfo[szCurrFilePath];
+				vector< vector<double> > vvCurrFeaturesTmp0001;
+				ExtColorFeature(szCurrFilePath, pinfo, vvCurrFeaturesTmp0001, BLKSIZE);
+				vector<int> vTmpClasses0001(vvCurrFeaturesTmp0001.size(), 0);
+				//vector<int> vTmpRecogClasses0001;
+				//double Accn0Tmp = 0.0;
+				vector<int> confres0Tmp;
+				Test2ClassesGMMs(vvCurrFeaturesTmp0001, vTmpClasses0001, GMMs, vTmpRecogClasses0001, Accn0Tmp, confres0Tmp);
+				for(size_t n000101 = 0; n000101 < vvCurrFeaturesTmp0001.size(); n000101++)
+				{
+					if(vTmpRecogClasses0001[n000101] != 0)
+					{
+						vvRecog1Tmp0001.push_back(vvCurrFeaturesTmp0001[n000101]);
+					}
+				}			
+			}
+			ofstream foutTmp;
+			foutTmp.open(szTmp.c_str());
+			if(!foutTmp.is_open())
+			{
+				cerr<<"Cannot Open Temp File so stop it"<<endl;
+				return -1;
+			}
+			ofstream fout02Tmp;
+			fout02Tmp.open(szTmpMLF.c_str());
+			if(!fout02Tmp.is_open())
+			{
+				cerr<<"Cannot open mlf file for written!"<<endl;
+				return -1;
+			}
+			fout02Tmp<<"#!MLF!#"<<endl;
+			if(0 < vvRecog1Tmp0001.size())
+			{
+				WriteFeatureAsHTKMFCC(vvRecog1Tmp0001, szCurrFE01Tmp, 9);
+				foutTmp<<szCurrFE01Tmp<<endl;
+				fout02Tmp<<"\"*/"<<vSeqs[n]<<"_BkGnd_Not_Skin.lab\""<<endl;
+				fout02Tmp<<"BkGnd\n.\n";
+			}
+			foutTmp.close();
+			fout02Tmp.close();
+			// Perform HTK:
+			if(0 < vvRecog1Tmp0001.size())
+			{
+				system(szCopyGMM.c_str());
+				system(sysCmd.c_str());
+			}
+			// 
+			unordered_map<string, GMM> hGMMsTmp;
+			vector<GMM> GMMsTmp;
+			GMMAdaptTool::LoadGMM(GMMCopy, hGMMsTmp);
+			GMMAdaptTool::GMMHash2VectBH(hGMMsTmp, GMMsTmp);
+			// Now that the model is updated, let's go back to skin block decision:
+			for(size_t i = 0; i < hvSeqs[vSeqs[n]].size(); i++)
+			{
+				string szCurrFilePath = hvSeqs[vSeqs[n]][i];
+				string szImagePathi, szImageNamei, szSeqNamei, szExti;
+				GetFileNameInfo(szCurrFilePath, szImagePathi, szImageNamei, szSeqNamei, szExti);
+						string szCurrFE1 = szFEFolder + szImageNamei +"_Hand.fe";
+						string szCurrFE0 = szFEFolder + szImageNamei +"_BkGnd.fe";
+				JPGLabelInfo* pinfo = &lb.m_hJPGLavelInfo[szCurrFilePath];
+				vector< vector<double> > vvCurrFeatures;
+				ExtColorFeature(szCurrFilePath, pinfo, vvCurrFeatures, BLKSIZE);
+				int nHeight = pinfo->m_nBlockHeight;
+				int nWidth = pinfo->m_nBlockWidth;
+				vector<int> vCurrRecogClasses0, vCurrRecogClasses;
+				double Accn0 = 0.0;
+				double Accn = 0.0;
+				vector<int> confres0;
+				Test2ClassesGMMs(vvCurrFeatures, lb.m_hJPGClasses[szCurrFilePath], GMMsTmp, vCurrRecogClasses0, Accn0, confres0);
+				vector< vector<double> > vvRecog0, vvRecog1;
+				// Collect those recognized as background and hand, respectively
+				for(int k1 = 0; k1 < nWidth; k1++)
+				{
+					for(int k2 = 0; k2 < nHeight; k2++)
+					{
+						int nCurrIndex = k1 * nHeight + k2;
+						if(vCurrRecogClasses0[nCurrIndex] == 0)
+						{
+							vvRecog0.push_back(vvCurrFeatures[nCurrIndex]);
+						}
+						else if(vCurrRecogClasses0[nCurrIndex] == 1)
+						{
+							vvRecog1.push_back(vvCurrFeatures[nCurrIndex]);
+							lb0.MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1, nWidth, nHeight);
+							if(lb0.m_hszJPGFiles.find(szCurrFilePath) == lb0.m_hszJPGFiles.end())
+							{
+								lb0.m_vszKeyOrder.push_back(szCurrFilePath);
+							}					
+							lb0.m_hszJPGFiles[szCurrFilePath] = 1;
+							//GMMAdaptTool::MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1,
+												//											hJPGLavelInfo0,
+												//											nCountO10,
+												//											nCountX10,
+												//											nWidth,
+												//											nHeight,
+												//											BLKSIZE);
+						}
+					}
+				}
+				
+				if(/*hJPGLavelInfo0*/lb0.m_hJPGLavelInfo.find(szCurrFilePath) == lb0.m_hJPGLavelInfo/*hJPGLavelInfo0*/.end())
+				{
+					/*hJPGLavelInfo0*/lb0.m_hJPGLavelInfo[szCurrFilePath].SetWidthHeight(nWidth*BLKSIZE, nHeight*BLKSIZE, BLKSIZE);
+					/*hJPGLavelInfo0*/lb0.m_hJPGLavelInfo[szCurrFilePath].m_szPathName = szCurrFilePath;				
+				}
+				// Prepare mlf and scp for HTK
+				ofstream fout;
+				fout.open(szTmp.c_str());
+				if(!fout.is_open())
+				{
+					cerr<<"Cannot Open Temp File so stop it"<<endl;
+					return -1;
+				}
+				ofstream fout02;
+				fout02.open(szTmpMLF.c_str());
+				if(!fout02.is_open())
+				{
+					cerr<<"Cannot open mlf file for written!"<<endl;
+					return -1;
+				}
+				fout02<<"#!MLF!#"<<endl;
+				if(0 < vvRecog0.size())
+				{
+					WriteFeatureAsHTKMFCC(vvRecog0, szCurrFE0, 9);
+					fout<<szCurrFE0<<endl;
+					fout02<<"\"*/"<<szImageNamei<<"_BkGnd.lab\""<<endl;
+					fout02<<"BkGnd\n.\n";
+				}
+				if(0 < vvRecog1.size())
+				{
+					WriteFeatureAsHTKMFCC(vvRecog1, szCurrFE1, 9);
+					fout<<szCurrFE1<<endl;
+					fout02<<"\"*/"<<szImageNamei<<"_Hand.lab\""<<endl;
+					fout02<<"Hand\n.\n";
+				}
+				fout.close();
+				fout02.close();
+				// Run HTK 
+				system(sysCmd.c_str());
+				//cout<<szImageNamei<<endl;
+				unordered_map<string, GMM> hGMMsTmpTmp;
+				vector<GMM> GMMsTmpTmp;
+				GMMAdaptTool::LoadGMM(GMMCopy, hGMMsTmpTmp);
+				GMMAdaptTool::GMMHash2VectBH(hGMMsTmpTmp, GMMsTmpTmp);
+				//vector<int> vCurrRecogClasses;
+				vector<int> confres;
+				Test2ClassesGMMs(vvCurrFeatures, lb.m_hJPGClasses[szCurrFilePath], GMMsTmpTmp, vCurrRecogClasses, Accn, confres);
+				hszJPGFiles1[szCurrFilePath] = 1;
+				hszJPGFiles0[szCurrFilePath] = 1;
+				for(int k1 = 0; k1 < nWidth; k1++)
+				{
+					for(int k2 = 0; k2 < nHeight; k2++)
+					{
+						int nCurrIndex = k1 * nHeight + k2;
+						if(vCurrRecogClasses[nCurrIndex] == 1)
+						{
+							lb1.MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1, nWidth, nHeight);
+							if(lb1.m_hszJPGFiles.find(szCurrFilePath) == lb0.m_hszJPGFiles.end())
+							{
+								lb1.m_vszKeyOrder.push_back(szCurrFilePath);
+							}					
+							lb1.m_hszJPGFiles[szCurrFilePath] = 1;
+							//GMMAdaptTool::MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1, 
+							//												hJPGLavelInfo1, 	
+							//												nCountO1,
+							//												nCountX1,
+							//												nWidth,
+							//												nHeight,
+							//												BLKSIZE);
+						}
+					}
+				}
+				if(/*hJPGLavelInfo1*/lb0.m_hJPGLavelInfo.find(szCurrFilePath) == /*hJPGLavelInfo1*/lb0.m_hJPGLavelInfo.end())
+				{
+					/*hJPGLavelInfo1*/lb0.m_hJPGLavelInfo[szCurrFilePath].SetWidthHeight(nWidth*BLKSIZE, nHeight*BLKSIZE, BLKSIZE);
+					/*hJPGLavelInfo1*/lb0.m_hJPGLavelInfo[szCurrFilePath].m_szPathName = szCurrFilePath;				
+				}
+				double NN = (double)(nWidth * nHeight);
+				Acc = (Accn * NN + Acc * N_1)/(N_1+NN);
+				Acc0 = (Accn0 * NN + Acc0 * N_1)/(N_1+NN);
+				N_1 += NN;	
+			}
+		}
+		if(fout.is_open())
+		{
+			fout<<"Original result is "<<Acc0<<endl;
+			fout<<"HTK MAP for each frame, result is "<<Acc<<endl;
+		}
+		else
+		{
+			cout<<"Original result is "<<Acc0<<endl;
+			cout<<"HTK MAP for each frame, result is "<<Acc<<endl;
+		}
+		lb1.SaveJPGInfo(szLabelPathName1);
+		lb0.SaveJPGInfo(szLabelPathName0);
+
+		//GMMAdaptTool::SaveJPGInfo(szLabelPathName1, 
+		//			hJPGLavelInfo1,
+		//			vszKeyOrder, 
+		//			hszJPGFiles1);
+	 //   GMMAdaptTool::SaveJPGInfo(szLabelPathName0,
+	 //                               hJPGLavelInfo0,
+	 //                               vszKeyOrder,
+	 //                               hszJPGFiles0);
+
+		return 0;
+	}
+
+	static void FindCurrentFolderANDDelim(string& szFileName, string& szFolder, string& szDelim)
+	{
+		int nPos0001 = szFileName.find_last_of("/");
+		int nPob0001 = szFileName.find_last_of("\\");
+		int nPos01 = (nPob0001>nPos0001)?nPob0001:nPos0001;
+		szDelim = (nPob0001>nPos0001)?"\\":"/";
+		szFolder = (nPos01 <= 0)?"":szFileName.substr(0, nPos01);
+	}
+
+	static void FindCurrentFileName(string& szPathName, string& szName)
+	{
+		int nPos001s = szPathName.find_last_of("/");
+		int nPos001b = szPathName.find_last_of("\\");
+		int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+		int nPos002 = szPathName.find_last_of(".");
+		nPos002 = (nPos002 > 0)?nPos002:(szPathName.length() - 1);
+		szName = szPathName.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+	}
+
+	static void FindCurrentSeqNamePath(string& szPathName, string& szName, string& szPath)
+	{
+		int nPos001s = szPathName.find_last_of("/");
+		int nPos001b = szPathName.find_last_of("\\");
+		int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+		int nPos002 = szPathName.find_last_of("_");
+		nPos002 = (nPos002 > 0)?nPos002:(szPathName.length() - 1);
+		szName = szPathName.substr(nPos001 + 1, nPos002 - nPos001);
+		szPath = szPathName.substr(0, nPos001 + 1);
+	}
+
+	static long LoadImagesFromPaths(vector<string>& vszPaths, vector<cv::Mat>& vImgs, vector<string>& vszLoadedFiles)
+	{
+		long N = (long) vszPaths.size();
+		if(N <= 0)
+		{
+			cerr<<"Cannot load images, no path specified"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		for(long n = 0; n < N; n++)
+		{
+			cv::Mat img = cv::imread(vszPaths[n]);
+			if(img.rows > 0 && img.cols > 0)
+			{
+				vImgs.push_back(img);
+				vszLoadedFiles.push_back(vszPaths[n]);
+			}
+		}
+		return S_OK;
+	}
+
+	static long ExtColorFeaturesFromImages(vector<cv::Mat>& vImgs, vector< vector< vector<double> > >& vvvFeatures, int BLOCKSIZE)
+	{
+		long N = (long) vImgs.size();
+		if(N <= 0)
+		{
+			cerr<<"No images for feature extraction"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvvFeatures.resize(N);
+		for(long n = 0; n < N; n++)
+		{
+			IplImage img = vImgs[n].operator IplImage();
+			IplImage* pimg = &img;
+			ExtLowLevelImgFeature::ExtColorFeatures(pimg, vvvFeatures[n], BLOCKSIZE);
+		}
+		return S_OK;
+	}
+
+	static long ExtColorFeaturesFromImages_BS0(vector<cv::Mat>& vImgs, vector< vector< vector<double> > >& vvvFeatures, int BLOCKSIZE, cv::Mat& ref, vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vImgs.size();
+		if(N <= 0)
+		{
+			cerr<<"No images for feature extraction"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvvFeatures.resize(N);
+		vvvCorrs.resize(N);
+		IplImage iplref = ref.operator IplImage();
+		IplImage* pref = &iplref;
+		for(long n = 0; n < N; n++)
+		{
+			IplImage img = vImgs[n].operator IplImage();
+			IplImage* pimg = &img;
+			int yrange = ExtLowLevelImgFeature::ExtColorFeatures_BS0(pimg, vvvFeatures[n], BLOCKSIZE, pref, vvvCorrs[n]);
+		}
+		return S_OK;
+	}
+
+
+	static long ExtColorFeaturesFromImagesStartStop(vector<cv::Mat>& vImgs, vector< vector< vector<double> > >& vvvFeatures, int BLOCKSIZE, int nStart, int nStop, IplImage*& pRefImg, vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vImgs.size();
+		if(N <= 0)
+		{
+			cerr<<"No images for feature extraction"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvvFeatures.resize(N);
+		vvvCorrs.resize(N);
+		for(long n = nStart; n < nStop; n++)
+		{
+			IplImage img = vImgs[n].operator IplImage();
+			IplImage* pimg = &img;
+			ExtLowLevelImgFeature::ExtColorFeatures_BS0(pimg, vvvFeatures[n], BLOCKSIZE, pRefImg, vvvCorrs[n]);
+			//ExtLowLevelImgFeature::ExtColorFeatures(pimg, vvvFeatures[n], BLOCKSIZE);
+		}
+		return S_OK;
+	}
+
+	static long TestAFrameFeatures(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector<int>& vRecogClasses, 
+								vector< vector< vector<double> > >& vvvRecogVec , long index)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+
+		long I = (long)GMMs.size();
+		if(vvvRecogVec.size() != I)
+		{
+			vvvRecogVec.resize(I);
+		}
+		long n = index;
+		RecognizeByGMMs(vvvFeatures[n], GMMs, vRecogClasses);
+		long M = (long)vRecogClasses.size();
+		for(long m = 0; m < M; m++)
+		{
+			int i = vRecogClasses[m];
+			vvvRecogVec[i].push_back(vvvFeatures[n][m]);
+		}
+		return 0;
+	}
+
+	static long TestAFrameFeatures_Cheat(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector<int>& vRecogClasses_Cheat, 
+								vector< vector< vector<double> > >& vvvRecogVec , long index)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+
+		long I = (long)GMMs.size();
+		if(vvvRecogVec.size() != I)
+		{
+			vvvRecogVec.resize(I);
+		}
+		long n = index;
+		long M = (long)vRecogClasses_Cheat.size();
+		for(long m = 0; m < M; m++)
+		{
+			int i = vRecogClasses_Cheat[m];
+			vvvRecogVec[i].push_back(vvvFeatures[n][m]);
+		}
+		return 0;
+	}
+
+	static long TestAFrameFeatures_BS0_Cheat(vector< vector< vector<double> > >& vvvFeatures,
+					vector<GMM>& GMMs,
+					vector<int>& vRecogClassesCheat,
+					vector< vector< vector<double> > >& vvvRecogVec , long index, 
+					vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+				cerr<<"No features for recognition"<<endl;
+				return ERROR_INVALID_DATA;
+		}
+
+		long I = (long)GMMs.size();
+		if(vvvRecogVec.size() != I)
+		{
+				vvvRecogVec.resize(I);
+		}
+		long n = index;
+		//RecognizeByGMMs(vvvFeatures[n], GMMs, vRecogClasses);
+		//vector<int> vRecogClasses(vRecogClassesCheat.size(), 0);
+		for(size_t kk = 0; kk < vRecogClassesCheat.size(); kk++)
+		{
+			double dbCorr = 0.1140 * vvvCorrs[n][kk][0] + 0.5870 * vvvCorrs[n][kk][1] + 0.2989 * vvvCorrs[n][kk][2];
+			//vvRecogClasses[n][kk] = (dbCorr < 0.5)?vvRecogClasses[n][kk]:0;
+			if(vRecogClassesCheat[kk] == 1)
+			{
+				if(dbCorr < CCThreshold)
+				{
+					vvvRecogVec[1].push_back(vvvFeatures[n][kk]);
+				}
+			}
+			else if(vRecogClassesCheat[kk] == 0)
+			{
+				if(dbCorr >= CCThreshold)
+				{
+					vvvRecogVec[0].push_back(vvvFeatures[n][kk]);
+				}
+			}
+		}
+	}
+
+
+	static long TestAFrameFeatures_BS0_Scores(vector< vector< vector<double> > >& vvvFeatures,
+					vector<GMM>& GMMs,
+					vector< vector<double> >& vvRecogScores,
+					long index, 
+					vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+				cerr<<"No features for recognition"<<endl;
+				return ERROR_INVALID_DATA;
+		}
+
+		long I = (long)GMMs.size();
+		long n = index;
+		GMMsScores(vvvFeatures[n], GMMs, vvRecogScores);
+		for(size_t kk = 0; kk < vvRecogScores.size(); kk++)
+		{
+			vvRecogScores[kk].push_back(vvvCorrs[n][kk][0]);
+			vvRecogScores[kk].push_back(vvvCorrs[n][kk][1]);
+			vvRecogScores[kk].push_back(vvvCorrs[n][kk][2]);
+		}
+	}
+
+	static long TestAFrameFeatures_BS0(vector< vector< vector<double> > >& vvvFeatures,
+					vector<GMM>& GMMs,
+					vector<int>& vRecogClasses,
+					vector< vector< vector<double> > >& vvvRecogVec , long index, 
+					vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+				cerr<<"No features for recognition"<<endl;
+				return ERROR_INVALID_DATA;
+		}
+
+		long I = (long)GMMs.size();
+		if(vvvRecogVec.size() != I)
+		{
+				vvvRecogVec.resize(I);
+		}
+		long n = index;
+		RecognizeByGMMs(vvvFeatures[n], GMMs, vRecogClasses);
+		for(size_t kk = 0; kk < vRecogClasses.size(); kk++)
+		{
+			double dbCorr = 0.1140 * vvvCorrs[n][kk][0] + 0.5870 * vvvCorrs[n][kk][1] + 0.2989 * vvvCorrs[n][kk][2];
+			//vvRecogClasses[n][kk] = (dbCorr < 0.5)?vvRecogClasses[n][kk]:0;
+			if(vRecogClasses[kk] == 1)
+			{
+				if(dbCorr >= CCThreshold)
+				{
+					vRecogClasses[kk] = 0;
+				}
+			}
+		}
+		long M = (long)vRecogClasses.size();
+		for(long m = 0; m < M; m++)
+		{
+			int i = vRecogClasses[m];
+			vvvRecogVec[i].push_back(vvvFeatures[n][m]);
+		}
+	}
+
+	static long TestAFrameFeatures_BS0_V2(vector< vector< vector<double> > >& vvvFeatures,
+					vector<GMM>& GMMs,
+					vector<int>& vRecogClasses,
+					vector< vector< vector<double> > >& vvvRecogVec , long index, 
+					vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+				cerr<<"No features for recognition"<<endl;
+				return ERROR_INVALID_DATA;
+		}
+
+		long I = (long)GMMs.size();
+		if(vvvRecogVec.size() != I)
+		{
+				vvvRecogVec.resize(I);
+		}
+		long n = index;
+		RecognizeByGMMs(vvvFeatures[n], GMMs, vRecogClasses);
+		for(size_t kk = 0; kk < vRecogClasses.size(); kk++)
+		{
+			double dbCorr = 0.1140 * vvvCorrs[n][kk][0] + 0.5870 * vvvCorrs[n][kk][1] + 0.2989 * vvvCorrs[n][kk][2];
+			//vvRecogClasses[n][kk] = (dbCorr < 0.5)?vvRecogClasses[n][kk]:0;
+			if(vRecogClasses[kk] == 1)
+			{
+				if(dbCorr < CCThreshold)
+				{
+					vvvRecogVec[1].push_back(vvvFeatures[n][kk]);
+				}
+				else
+				{
+					vRecogClasses[kk] = 0;
+				}
+			}
+			else if(vRecogClasses[kk] == 0)
+			{
+				if(dbCorr >= CCThreshold)
+				{
+					vvvRecogVec[0].push_back(vvvFeatures[n][kk]);
+				}
+			}
+		}
+	}
+
+	static long TestAllFeatures(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector<int> >& vvRecogClasses)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvRecogClasses.resize(N);
+
+		for(long n = 0; n < N; n++)
+		{
+			RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+		}
+	}
+
+	static long TestAllFeatures_Scores(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector<int> >& vvRecogClasses,
+								vector< vector< vector<double> > >& vvvRecogScores
+								)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvRecogClasses.resize(N);
+		vvvRecogScores.resize(N);
+		for(long n = 0; n < N; n++)
+		{
+			GMMsScoresRecog(vvvFeatures[n], GMMs, vvRecogClasses[n], vvvRecogScores[n]);
+			//RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+		}
+	}
+
+	static long TestAllFeatures_BS0_Corrs_Only(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector<int> >& vvRecogClasses,
+								vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvRecogClasses.resize(N);
+
+		for(long n = 0; n < N; n++)
+		{
+			if(vvvFeatures[n].size())
+			{
+				//RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+				//cout<<"n is "<<n<<endl;
+				vvRecogClasses[n] = vector<int>(vvvFeatures[n].size(), 0);
+				for(size_t kk = 0; kk < vvRecogClasses[n].size(); kk++)
+				{
+					//cerr<<"n is "<<n<<", kk is "<<kk<<endl;
+					double dbCorr = 0.1140 * vvvCorrs[n][kk][0] + 0.5870 * vvvCorrs[n][kk][1] + 0.2989 * vvvCorrs[n][kk][2];
+					//vvRecogClasses[n][kk] = (dbCorr < 0.5)?vvRecogClasses[n][kk]:0;
+					if(dbCorr < CCThreshold)
+					{
+						vvRecogClasses[n][kk] = 1;
+					}
+				}
+			}
+		}
+	}
+
+	static long TestAllFeatures_BS0(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector<int> >& vvRecogClasses,
+								vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvRecogClasses.resize(N);
+
+		for(long n = 0; n < N; n++)
+		{
+			if(vvvFeatures[n].size())
+			{
+				RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+				//cout<<"n is "<<n<<endl;
+				for(size_t kk = 0; kk < vvRecogClasses[n].size(); kk++)
+				{
+					//cerr<<"n is "<<n<<", kk is "<<kk<<endl;
+					double dbCorr = 0.1140 * vvvCorrs[n][kk][0] + 0.5870 * vvvCorrs[n][kk][1] + 0.2989 * vvvCorrs[n][kk][2];
+					//vvRecogClasses[n][kk] = (dbCorr < 0.5)?vvRecogClasses[n][kk]:0;
+					if(vvRecogClasses[n][kk] == 1)
+					{
+						if(dbCorr >= CCThreshold)
+						{
+							vvRecogClasses[n][kk] = 0;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	static long AllFeatures_BS0_Scores(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector< vector<double> > >& vvvRecogScores,
+								vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvvRecogScores.resize(N);
+
+		for(long n = 0; n < N; n++)
+		{
+			if(vvvFeatures[n].size())
+			{
+				GMMsScores(vvvFeatures[n], GMMs, vvvRecogScores[n]);
+				//RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+				//cout<<"n is "<<n<<endl;
+				for(size_t kk = 0; kk < vvvRecogScores[n].size(); kk++)
+				{
+					vvvRecogScores[n][kk].push_back(vvvCorrs[n][kk][0]);
+					vvvRecogScores[n][kk].push_back(vvvCorrs[n][kk][1]);
+					vvvRecogScores[n][kk].push_back(vvvCorrs[n][kk][2]);
+				}
+			}
+		}
+	}
+
+	static long TestAllFeatures(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector<int> >& vvRecogClasses, 
+								vector< vector< vector<double> > >& vvvRecogVec )
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvRecogClasses.resize(N);
+
+		long I = (long)GMMs.size();
+		if(vvvRecogVec.size() != I)
+		{
+			vvvRecogVec.resize(I);
+		}
+		for(long n = 0; n < N; n++)
+		{
+			RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+			long M = (long)vvRecogClasses[n].size();
+			for(long m = 0; m < M; m++)
+			{
+				int i = vvRecogClasses[n][m];
+				vvvRecogVec[i].push_back(vvvFeatures[n][m]);
+			}
+		}
+	}
+	
+	static long TestAllFeatures_BS0(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector<int> >& vvRecogClasses,
+								vector< vector< vector<double> > >& vvvRecogVec, 
+								vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvRecogClasses.resize(N);
+                long I = (long)GMMs.size();
+                if(vvvRecogVec.size() != I)
+                {
+                                vvvRecogVec.resize(I);
+                }
+		for(long n = 0; n < N; n++)
+		{
+			//cerr<<"n is "<<n<<endl;
+			if(vvvFeatures[n].size())
+			{
+				RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+				for(size_t kk = 0; kk < vvRecogClasses[n].size(); kk++)
+				{
+					//cerr<<"n is "<<n<<", kk is "<<kk<<endl;
+					double dbCorr = 0.1140 * vvvCorrs[n][kk][0] + 0.5870 * vvvCorrs[n][kk][1] + 0.2989 * vvvCorrs[n][kk][2];
+					//vvRecogClasses[n][kk] = (dbCorr < 0.5)?vvRecogClasses[n][kk]:0;
+					if(vvRecogClasses[n][kk] == 1)
+					{
+						if(dbCorr >= CCThreshold)
+						{
+							vvRecogClasses[n][kk] = 0;
+						}
+					}
+				}
+				long M = (long)vvRecogClasses[n].size();
+				for(long m = 0; m < M; m++)
+				{
+					int i = vvRecogClasses[n][m];
+					vvvRecogVec[i].push_back(vvvFeatures[n][m]);
+				}
+			}
+		}
+	}
+
+
+
+	static long TestAllFeatures_BS0_V2(vector< vector< vector<double> > >& vvvFeatures, 
+								vector<GMM>& GMMs, 
+								vector< vector<int> >& vvRecogClasses,
+								vector< vector< vector<double> > >& vvvRecogVec, 
+								vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vvvFeatures.size();
+		if(N <= 0)
+		{
+			cerr<<"No features for recognition"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vvRecogClasses.resize(N);
+                long I = (long)GMMs.size();
+                if(vvvRecogVec.size() != I)
+                {
+                                vvvRecogVec.resize(I);
+                }
+		for(long n = 0; n < N; n++)
+		{
+			//cerr<<"n is "<<n<<endl;
+			if(vvvFeatures[n].size())
+			{
+				RecognizeByGMMs(vvvFeatures[n], GMMs, vvRecogClasses[n]);
+				for(size_t kk = 0; kk < vvRecogClasses[n].size(); kk++)
+				{
+					//cerr<<"n is "<<n<<", kk is "<<kk<<endl;
+					double dbCorr = 0.1140 * vvvCorrs[n][kk][0] + 0.5870 * vvvCorrs[n][kk][1] + 0.2989 * vvvCorrs[n][kk][2];
+					//vvRecogClasses[n][kk] = (dbCorr < 0.5)?vvRecogClasses[n][kk]:0;
+
+
+					if(vvRecogClasses[n][kk] == 1)
+					{
+						if(dbCorr < CCThreshold)
+						{
+							vvvRecogVec[1].push_back(vvvFeatures[n][kk]);
+						}
+						else
+						{
+							vvRecogClasses[n][kk] = 0;
+						}
+					}
+					else if(vvRecogClasses[n][kk] == 0)
+					{
+						if(dbCorr >= CCThreshold)
+						{
+							vvvRecogVec[0].push_back(vvvFeatures[n][kk]);
+						}
+					}
+
+				}
+			}
+		}
+	}
+
+
+
+
+	static long PrepareHTKMAPCommands(string GMMPaths, string DataPaths, string& GMMCopy, string& szTmpSCP, string& szTmpMLF, string& szCmd, int nIter = 1)
+	{
+		szTmpSCP = DataPaths + "_Tmp.scp";
+		szTmpMLF = DataPaths + "_Tmp.mlf";
+		string GMMCopyTmp; 
+		char buf1[256];
+		char buf2[256];
+		memset(buf1, 0, 256);
+		memset(buf2, 0, 256);
+		if(nIter == 1)
+		{
+			char buf1[256];
+			sprintf(buf2, "%i", nIter);
+			//itoa(nIter, buf2,10);
+			GMMCopyTmp = GMMPaths;
+			GMMCopy = GMMCopyTmp + "_Tmp" + string(buf2);
+		}
+		else
+		{
+			int nIterLast = nIter - 1;
+			sprintf(buf1, "%i", nIterLast); //itoa(nIterLast, buf1,10);
+			sprintf(buf2, "%i", nIter); //itoa(nIter, buf2,10);
+			GMMCopyTmp = GMMPaths + "_Tmp" + string(buf1);
+			GMMCopy = GMMPaths + "_Tmp" + string(buf2);
+		}
+	#ifdef _MSC_VER
+		string HERest = "C:\\CollectedDataCopy\\recognizer\\HTK\\bin.win32\\HERest.exe";
+		string config = "C:\\Transfer\\AdjustGMMNew\\config";
+		string words = "C:\\Transfer\\AdjustGMMNew\\words";
+		string szCopyGMM = "copy " + GMMCopyTmp + " " + GMMCopy;
+	#elif defined(__GNUC__)
+		string HERest = "HERest"; //"/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+		string config = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/config"; //"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+		string words = "/nv/pec1/ycheng31/local/include/AdjustGMMNew/words"; //"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+		string szCopyGMM = "cp " + GMMCopyTmp + " " + GMMCopy;
+	#endif
+		// Copy GMM as Temp
+		system(szCopyGMM.c_str());
+		szCmd = HERest;
+		szCmd.append(" -C ");
+		szCmd.append(config);
+		szCmd.append(" -S ");
+		szCmd.append(szTmpSCP);
+		szCmd.append(" -I ");
+		szCmd.append(szTmpMLF);
+		szCmd.append(" -H ");
+		szCmd.append(GMMCopy);
+		szCmd.append(" -u mpw ");
+		szCmd.append(words);
+		return 0;
+	}
+
+	static long PrepareTempDocsForAdapt(vector< vector< vector<double> > >& vvvRecogVecm, vector<string>& vszClassLabs, string& szName, string& szPath, string& szTmpSCP, string& szTmpMLF)
+	{
+		ofstream fout1, fout2;
+		fout1.open(szTmpSCP.c_str());
+		fout2.open(szTmpMLF.c_str());
+		if(!fout1.is_open())
+		{
+			cerr<<"Cannot open temp scp file for writing!\n"<<szTmpSCP<<endl;
+			return S_FALSE;
+		}
+		if(!fout2.is_open())
+		{
+			cerr<<"Cannot open temp mlf file for writing!\n"<<szTmpSCP<<endl;
+			return S_FALSE;
+		}
+		long I1 = (long) vvvRecogVecm.size();
+		long I2 = (long) vszClassLabs.size();
+		if(I1 != I2)
+		{
+			cerr<<"# Labels and # names didn't match!"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		fout2<<"#!MLF!#"<<endl;
+		bool bHasAdapt = false;
+		for(long i = 0; i < I1; i++)
+		{
+			string szOutFE = szPath + szName + "_" + vszClassLabs[i] + ".fe";
+			
+			if(vvvRecogVecm[i].size())
+			{
+				WriteFeatureAsHTKMFCC(vvvRecogVecm[i], szOutFE, 9);
+				fout1<<szOutFE<<endl;
+				fout2<<"\"*/"<<szName<<"_"<<vszClassLabs[i]<<".lab\""<<endl;
+				fout2<<vszClassLabs[i]<<"\n.\n";
+				bHasAdapt = true;
+			}
+
+		}
+		fout1.close();
+		fout2.close();
+		if(bHasAdapt)
+			return S_OK;
+		else
+			return ERROR_EMPTY;
+	}
+
+	static long Do_Skin_HTKMAP(vector< vector< vector<double> > >& vvvRecogVecm, string GMMPaths, string szFEFolder, string szImagePathName, unordered_map<string, GMM>& hNewGMMs, int nIter = 1)
+	{
+		string GMMCopy;
+		string szTmpSCP;
+		string szTmpMLF; 
+		string szCmd;
+		string szDelim = "";
+		string szCurrFolder = "";
+		string szName;
+		
+		//FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		FindCurrentFileName(szImagePathName, szName);
+		//string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		string szDataPaths = szFEFolder + szName;
+		string szmkdir = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(szmkdir.c_str());
+		long hr = PrepareHTKMAPCommands(GMMPaths, szDataPaths, GMMCopy, szTmpSCP, szTmpMLF, szCmd, nIter);
+		if(hr != S_OK)
+		{
+			return hr;
+		}
+		vector<string> vszLab(2);
+		vszLab[0] = "BkGnd";
+		vszLab[1] = "Hand";
+		hr = PrepareTempDocsForAdapt(vvvRecogVecm, vszLab, szName, szFEFolder, szTmpSCP, szTmpMLF);
+		if(hr != S_OK)
+		{
+			return hr;
+		}
+		system(szCmd.c_str());
+		LoadGMM(GMMCopy, hNewGMMs);
+	}
+
+	static long PrepareSMAPCommands(string GMMPaths, string DataPaths, string& GMMCopy, string& szTmpSCP, string& szTmpMLF, string& szCmd)
+	{
+		szTmpSCP = DataPaths + "_Tmp.scp";
+		szTmpMLF = DataPaths + "_Tmp.mlf";
+		GMMCopy = GMMPaths + "_Tmp_SMAP";
+
+#ifdef _MSC_VER
+		string treeadapt_smap = "";
+		cerr<<"Current version didn't support windows OS\n";
+		return E_NOTIMPL;
+#else
+		string treeadapt_smap = "/cluster/users/ycheng31/SMAP/treeadapt_smap/treeadapt_smap";
+		string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+#endif
+		// Copy GMM as Temp
+		//system(szCopyGMM.c_str());
+		szCmd = treeadapt_smap;
+		szCmd.append(" -i ");
+		szCmd.append(GMMPaths);
+		szCmd.append(" -o ");
+		szCmd.append(GMMCopy);
+		szCmd.append(" -m ");
+		szCmd.append(szTmpMLF);
+		szCmd.append(" -s ");
+		szCmd.append(szTmpSCP);
+		szCmd.append(" -d 1");
+		return 0;
+	}
+
+	static long Do_Skin_SMAP(vector< vector< vector<double> > >& vvvRecogVecm, string GMMPaths, string szFEFolder, string szImagePathName, unordered_map<string, GMM>& hNewGMMs)
+	{
+		string GMMCopy;
+		string szTmpSCP;
+		string szTmpMLF; 
+		string szCmd;
+		string szDelim = "";
+		string szCurrFolder = "";
+		string szName;
+		
+		//FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		FindCurrentFileName(szImagePathName, szName);
+		//string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		string szDataPaths = szFEFolder + szName;
+		string szmkdir = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(szmkdir.c_str());
+
+		long hr = PrepareSMAPCommands(GMMPaths, szDataPaths, GMMCopy, szTmpSCP, szTmpMLF, szCmd);
+		if(hr != S_OK)
+		{
+			return hr;
+		}
+		vector<string> vszLab(2);
+		vszLab[0] = "BkGnd";
+		vszLab[1] = "Hand";
+		hr = PrepareTempDocsForAdapt(vvvRecogVecm, vszLab, szName, szFEFolder, szTmpSCP, szTmpMLF);
+		if(hr != S_OK)
+		{
+			return hr;
+		}
+		system(szCmd.c_str());
+		LoadGMM(GMMCopy, hNewGMMs);
+		return S_OK;
+	}
+
+	
+	static long BaselineASeq(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+
+		TestAllFeatures(vvvFeatures, GMMs, vvRecogClasses) ;
+		return S_OK;
+	}
+
+	static long BaselineASeq_NOBS(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+
+		TestAllFeatures(vvvFeatures, GMMs, vvRecogClasses) ;
+		//cvReleaseImage(&pBkGnd);
+		return S_OK;
+	}
+
+	static long BaselineASeq_BS0_Corrs_Only(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+
+		TestAllFeatures_BS0_Corrs_Only(vvvFeatures, GMMs, vvRecogClasses, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		return S_OK;
+	}
+
+
+
+
+	static long BaselineASeq_BS0(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+
+		TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		return S_OK;
+	}
+
+
+	static long HTKGMMAdaptPerFrame_Cheat(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, vector< vector<int> >& vvRecogClassesCheat)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		for(long n = 0; n < NN; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			//TestAFrameFeatures(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n);
+			// Cheating here:
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			for(int nIter = 1; nIter <= GMMITER; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				TestAFrameFeatures(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n);
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			//TestAFrameFeatures_BS0(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n, vvvCorrs);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		return S_OK;
+	}
+
+
+
+	static long HTKGMMAdaptPerFrame(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		for(long n = 0; n < NN; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			for(int nIter = 1; nIter <= GMMITER; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				TestAFrameFeatures(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n);
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		return S_OK;
+	}
+
+	static long HTKGMMAdaptPerFrame(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, vector< vector<int> >& vvxyrange)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		for(long n = 0; n < NN; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			for(int nIter = 1; nIter <= GMMITER; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				TestAFrameFeatures(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n);
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+	static long HTKGMMAdaptASeq(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		vector< vector<int> > vvRecogClasses0;
+
+		vector< vector< vector<double> > > vvvRecogVec0;
+		vector< vector< vector<double> > > vvvRecogVec1;
+
+		vector<GMM> GMMsCopy;
+		GMMsCopy = GMMs;
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+		for(int nIter = 1; nIter <= GMMITER; nIter++)
+		{
+			vvvRecogVec0.clear();
+			hNewGMMs.clear();
+			newGMMs.clear();
+			TestAllFeatures(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0) ;
+			Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs, nIter);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			GMMsCopy.clear();
+			GMMsCopy = newGMMs;
+		}
+
+		//TestAllFeatures(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0) ;
+		//unordered_map<string, GMM> hNewGMMs;
+		//vector<GMM> newGMMs;
+		//string szSeqName, szCurrPath;
+		//FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		//string szTmpName = szCurrPath + szSeqName;
+		//Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs);
+		//GMMHash2VectBH(hNewGMMs, newGMMs);
+		TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		return S_OK;
+	}
+
+	static long HTKGMMAdaptASeq(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, vector< vector<int> >& vvxyrange)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		vector< vector<int> > vvRecogClasses0;
+
+		vector< vector< vector<double> > > vvvRecogVec0;
+		vector< vector< vector<double> > > vvvRecogVec1;
+
+		vector<GMM> GMMsCopy;
+		GMMsCopy = GMMs;
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		for(int nIter = 1; nIter <= GMMITER; nIter++)
+		{
+			vvvRecogVec0.clear();
+			hNewGMMs.clear();
+			newGMMs.clear();
+			TestAllFeatures(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0) ;
+			string szSeqName, szCurrPath;
+			FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+			string szTmpName = szCurrPath + szSeqName;
+			Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs, nIter);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			GMMsCopy.clear();
+			GMMsCopy = newGMMs;
+		}
+		TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+	static long HTKGMMSMAPPerFrame(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		for(long n = 0; n < NN; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			TestAFrameFeatures(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n);
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		return S_OK;
+	}
+
+	static long HTKGMMSMAPPerFrame(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, vector< vector<int> >& vvxyrange)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		for(long n = 0; n < NN; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			TestAFrameFeatures(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n);
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+	static long HTKGMMMAPPerFrame_BS0_Cheat(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq, string& GMMPath, vector< vector<int> >& vvRecogClassesCheat)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		string szFolder, szDelim;
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		string szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		for(long n = nStartSeq; n < nStopSeq; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			for(int nIter = 1; nIter <= GMMITER; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				TestAFrameFeatures_BS0_Cheat(vvvFeatures, GMMsCopy, vvRecogClassesCheat[n], vvvRecogVec0, n, vvvCorrs);
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			TestAFrameFeatures_BS0(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n, vvvCorrs);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		//TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		return S_OK;
+	}
+
+
+
+
+	static long HTKGMMMAPPerFrame_BS0_Scores(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector< vector<double> > >& vvvRecogScores, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq, string& GMMPath)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		string szFolder, szDelim;
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		string szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		for(long n = nStartSeq; n < nStopSeq; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			//TestAFrameFeatures_BS0_V2(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+
+
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			for(int nIter = 1; nIter <= GMMITER; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				TestAFrameFeatures_BS0_V2(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+				//TestAFrameFeatures_BS0(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			//TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			if(GMMITER < 1)
+			{
+				newGMMs = GMMs;
+			}
+			vector< vector<double> > vvScores;
+			TestAFrameFeatures_BS0_Scores(vvvFeatures, newGMMs, vvScores, n, vvvCorrs);
+			vvvRecogScores.push_back(vvScores);
+			//TestAFrameFeatures_BS0(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n, vvvCorrs);
+			//vvRecogClasses.push_back(vRecogClasses1);
+		}
+		//TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses, vvvCosrrs) ;
+		//cvReleaseImage(&pBkGnd);
+		return S_OK;
+	}
+
+
+	static long HTKGMMMAPPerFrame_BS0(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq, string& GMMPath)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		string szFolder, szDelim;
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		string szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		for(long n = nStartSeq; n < nStopSeq; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			//TestAFrameFeatures_BS0_V2(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+
+
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			for(int nIter = 1; nIter <= GMMITER; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				TestAFrameFeatures_BS0_V2(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			//TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			TestAFrameFeatures_BS0(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n, vvvCorrs);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		//TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		return S_OK;
+	}
+
+	static long HTKGMMMAPASeq_BS0_Scores(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector< vector<double> > >& vvvRecogScores, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq, string& GMMPath)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		
+		vector< vector<int> > vvRecogClasses0;
+		vector< vector< vector<double> > > vvvRecogVec0;
+		//vector< vector<int> > vvRecogVec0;
+		//TestAllFeatures_BS0_V2(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+        	string szFolder, szDelim;
+	        FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+        	string szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+	        string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+		        system(mkdirFolder.c_str());
+
+		vector<GMM> GMMsCopy;
+		GMMsCopy = GMMs;
+		//unordered_map<string, GMM> hNewGMMs;
+		//vector<GMM> newGMMs;
+		for(int nIter = 1; nIter <= GMMITER; nIter++)
+		{
+			vvvRecogVec0.clear();
+			hNewGMMs.clear();
+			newGMMs.clear();
+			TestAllFeatures_BS0_V2(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+			//TestAllFeatures_BS0(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+			Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs, nIter);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			GMMsCopy.clear();
+			GMMsCopy = newGMMs;
+		}
+		if(GMMITER < 1)
+		{
+			newGMMs = GMMs;
+		}
+		//TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		//TestAllFeatures_BS0(vvvFeatures, newGMMs, vvRecogClasses, vvvCorrs);
+		AllFeatures_BS0_Scores(vvvFeatures, newGMMs, vvvRecogScores, vvvCorrs);
+
+		return S_OK;
+	}
+
+
+
+
+
+
+
+	static long HTKGMMMAPASeq_BS0(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq, string& GMMPath)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		
+		vector< vector<int> > vvRecogClasses0;
+		vector< vector< vector<double> > > vvvRecogVec0;
+		//vector< vector<int> > vvRecogVec0;
+		//TestAllFeatures_BS0_V2(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+	        string szFolder, szDelim;    
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		string szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+
+		vector<GMM> GMMsCopy;
+		GMMsCopy = GMMs;
+		//unordered_map<string, GMM> hNewGMMs;
+		//vector<GMM> newGMMs;
+		for(int nIter = 1; nIter <= GMMITER; nIter++)
+		{
+			vvvRecogVec0.clear();
+			hNewGMMs.clear();
+			newGMMs.clear();
+			TestAllFeatures_BS0_V2(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+			Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs, nIter);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			GMMsCopy.clear();
+			GMMsCopy = newGMMs;
+		}
+		//TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		TestAllFeatures_BS0(vvvFeatures, newGMMs, vvRecogClasses, vvvCorrs);
+
+		return S_OK;
+	}
+
+
+
+
+
+	static long HTKGMMSMAPPerFrame_BS0(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq, string& GMMPath)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		string szFolder, szDelim;
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		string szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+		for(long n = nStartSeq; n < nStopSeq; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			TestAFrameFeatures_BS0(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			//TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			TestAFrameFeatures_BS0(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n, vvvCorrs);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		//TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		return S_OK;
+	}
+
+
+	static long HTKGMMSMAPPerFrame_BS0(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, vector< vector<int> >& vvxyrange, cv::Mat& ref, vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages_BS0(vImgs, vvvFeatures, BLOCKSIZE, ref, vvvCorrs); 
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		for(long n = 0; n < NN; n++)
+		{
+			vector<int> vRecogClasses0;
+			vector<int> vRecogClasses1;
+			vector< vector< vector<double> > > vvvRecogVec0;
+			vector< vector< vector<double> > > vvvRecogVec1;
+			TestAFrameFeatures_BS0(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs);
+			GMMHash2VectBH(hNewGMMs, newGMMs);
+			//TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+			TestAFrameFeatures_BS0(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n, vvvCorrs);
+			vvRecogClasses.push_back(vRecogClasses1);
+		}
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+	static long HTKGMMSMAPASeq(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		vector< vector<int> > vvRecogClasses0;
+
+		vector< vector< vector<double> > > vvvRecogVec0;
+		vector< vector< vector<double> > > vvvRecogVec1;
+		TestAllFeatures(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0) ;
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+		Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs);
+		GMMHash2VectBH(hNewGMMs, newGMMs);
+		TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		return S_OK;
+	}
+
+	static long HTKGMMSMAPASeq(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, vector< vector<int> >& vvxyrange)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages(vImgs, vvvFeatures, BLOCKSIZE);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		vector< vector<int> > vvRecogClasses0;
+
+		vector< vector< vector<double> > > vvvRecogVec0;
+		vector< vector< vector<double> > > vvvRecogVec1;
+		TestAllFeatures(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0) ;
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+		Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs);
+		GMMHash2VectBH(hNewGMMs, newGMMs);
+		TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+	static long HTKGMMSMAPASeq_BS0(vector<GMM>& GMMs, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, int& nStartSeq, int& nStopSeq, string& GMMPath)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		vector< vector< vector<double> > > vvvCorrs;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		int nDetStopBkGnd = 0;
+		int nStop = 0;
+		TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		nStartSeq = nDetStopBkGnd + 1;
+		nStopSeq = nStop;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		
+		vector< vector<int> > vvRecogClasses0;
+		vector< vector< vector<double> > > vvvRecogVec0;
+		//vector< vector<int> > vvRecogVec0;
+		TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+		//cvReleaseImage(&pBkGnd);
+		
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+
+	        string szFolder, szDelim;
+                FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+                string szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+                string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+                	system(mkdirFolder.c_str());
+	
+		Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs);
+		GMMHash2VectBH(hNewGMMs, newGMMs);
+		//TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		TestAllFeatures_BS0(vvvFeatures, newGMMs, vvRecogClasses, vvvCorrs);
+		return S_OK;
+	}
+
+	static long HTKGMMSMAPASeq_BS0(vector<GMM>& GMMs, string& GMMPath, string& szFEFolder, vector<string>& vszImagePathNames, vector< vector<int> >& vvRecogClasses, vector<string>& vszLoadadFiles, int BLOCKSIZE, vector< vector<int> >& vvxyrange, cv::Mat& ref, vector< vector< vector<double> > >& vvvCorrs)
+	{
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		hr = ExtColorFeaturesFromImages_BS0(vImgs, vvvFeatures, BLOCKSIZE, ref, vvvCorrs);
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		vector< vector<int> > vvRecogClasses0;
+
+		vector< vector< vector<double> > > vvvRecogVec0;
+		vector< vector< vector<double> > > vvvRecogVec1;
+		TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0, vvvCorrs);
+	
+		unordered_map<string, GMM> hNewGMMs;
+		vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+		Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs);
+		GMMHash2VectBH(hNewGMMs, newGMMs);
+		//TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		TestAllFeatures_BS0(vvvFeatures, newGMMs, vvRecogClasses, vvvCorrs);
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+
+
+	static long HTKGMMMAP_BS0_Fusion(
+		vector<GMM>& GMMs, 
+		string& GMMPath, 
+		string& szFEFolder, 
+		vector<string>& vszImagePathNames, 
+		vector< vector<int> >& vvRecogClasses, 
+		vector<string>& vszLoadadFiles, 
+		int BLOCKSIZE, 
+		vector< vector<int> >& vvxyrange, 
+		cv::Mat& ref, 
+		vector<GMM>& vFusionGMMs, 
+		bool bFrameBatch, 
+		int nAdaptMode, 
+		int nStartSeq,
+		int nStopSeq
+		)
+	{
+		vector< vector< vector<double> > > vvvCorrs;
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+//		hr = ExtColorFeaturesFromImages_BS0(vImgs, vvvFeatures, BLOCKSIZE, ref, vvvCorrs);
+		//int nDetStopBkGnd = 0;
+		//int nStop = 0;
+		//TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		//int nStartSeq = nDetStopBkGnd + 1;
+		//int nStopSeq = nStop;
+		int nDetStopBkGnd = nStartSeq - 1;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		// background frames with null vectors!
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		string szFolder, szDelim;
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+
+		vector< vector<int> > vvRecogClasses0;
+
+		vector< vector< vector<double> > > vvvRecogVec0;
+		vector< vector< vector<double> > > vvvRecogVec1;
+		//TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0, vvvCorrs);
+	
+		//unordered_map<string, GMM> hNewGMMs;
+		//vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+		vector< vector< vector<double> > > vvvRecogScores;
+		int nNumIter = GMMITER;
+		if(nAdaptMode == 1)
+			nNumIter = 0;
+		if(bFrameBatch)
+		{
+			// Framewise adaptation
+			for(long n = 0; n < vvvFeatures.size(); n++)
+			{
+				if(n >= nStartSeq && n < nStopSeq)
+				{
+					vector<int> vRecogClasses0;
+					vector<int> vRecogClasses1;
+					vector< vector< vector<double> > > vvvRecogVec0;
+					vector< vector< vector<double> > > vvvRecogVec1;
+					//TestAFrameFeatures_BS0_V2(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+					unordered_map<string, GMM> hNewGMMs;
+					vector<GMM> newGMMs;
+
+					vector<GMM> GMMsCopy;
+					GMMsCopy = GMMs;
+
+					for(int nIter = 1; nIter <= nNumIter; nIter++)
+					{
+						vvvRecogVec0.clear();
+						hNewGMMs.clear();
+						newGMMs.clear();
+						//TestAFrameFeatures_BS0_V2(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+						TestAFrameFeatures_BS0(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+						Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+						GMMHash2VectBH(hNewGMMs, newGMMs);
+						GMMsCopy.clear();
+						GMMsCopy = newGMMs;
+					}
+					//TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+					if(nNumIter < 1)
+					{
+						newGMMs = GMMs;
+					}
+					vector< vector<double> > vvScores;
+					TestAFrameFeatures_BS0_Scores(vvvFeatures, newGMMs, vvScores, n, vvvCorrs);
+					vvvRecogScores.push_back(vvScores);
+				}
+				else
+				{
+					vector< vector<double> > vvScores;
+					vvvRecogScores.push_back(vvScores);
+				}
+			}
+
+		}
+		else
+		{
+			// Batch adaptation
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			for(int nIter = 1; nIter <= nNumIter; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				//TestAllFeatures_BS0_V2(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+				TestAllFeatures_BS0(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			if(nNumIter < 1)
+			{
+				newGMMs = GMMs;
+			}
+			AllFeatures_BS0_Scores(vvvFeatures, newGMMs, vvvRecogScores, vvvCorrs);
+		}
+		vvRecogClasses.resize(vvvFeatures.size());
+		if(nAdaptMode == 0)
+		{
+			// MAP only
+			for(int i = 0; i < vvvFeatures.size(); ++i)
+			{
+				if(i >= nStartSeq && i < nStopSeq)
+				{
+					vvRecogClasses[i].resize(vvvRecogScores[i].size(), 0);
+					for(size_t j = 0; j < vvvRecogScores[i].size(); ++j)
+					{
+						if(vvvRecogScores[i][j][1] - vvvRecogScores[i][j][0] > 0.0)
+						{
+							vvRecogClasses[i][j] = 1;
+						}
+					}
+				}
+			}
+		}
+		else
+		{
+			// Score fusions
+			vector< vector< vector<double> > > vvvScoreForFusions(vvvFeatures.size());
+			for(int i = 0; i < vvvFeatures.size(); ++i)
+			{
+				if(i >= nStartSeq && i < nStopSeq)
+				{
+					vvvScoreForFusions[i].resize(vvvRecogScores[i].size());
+					for(size_t j = 0; j < vvvRecogScores[i].size(); ++j)
+					{
+						double LLR = vvvRecogScores[i][j][1] - vvvRecogScores[i][j][0];
+						double sLLR = 1.0/(1.0+exp(-0.5*LLR));
+						double sCorr = 0.1140*vvvCorrs[i][j][0] + 0.5870 * vvvCorrs[i][j][1] + 0.2989*vvvCorrs[i][j][2];
+						//cout<<LLR<<"\t"<<sLLR<<"\t"<<sCorr<<endl;
+						vvvScoreForFusions[i][j].push_back(sLLR);
+						vvvScoreForFusions[i][j].push_back(sCorr);
+					}
+				}
+			}
+			TestAllFeatures(vvvScoreForFusions, vFusionGMMs, vvRecogClasses);
+		}
+
+		//Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs);
+		//GMMHash2VectBH(hNewGMMs, newGMMs);
+		//TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		//TestAllFeatures_BS0(vvvFeatures, newGMMs, vvRecogClasses, vvvCorrs);
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+
+
+
+
+	static long HTKGMMMAP_BS0_Fusion_With_Scores(
+		vector<GMM>& GMMs, 
+		string& GMMPath, 
+		string& szFEFolder, 
+		vector<string>& vszImagePathNames, 
+		vector< vector<int> >& vvRecogClasses, 
+		vector<string>& vszLoadadFiles, 
+		int BLOCKSIZE, 
+		vector< vector<int> >& vvxyrange, 
+		cv::Mat& ref, 
+		vector<GMM>& vFusionGMMs, 
+		bool bFrameBatch, 
+		int nAdaptMode, 
+		int nStartSeq,
+		int nStopSeq,
+		vector< vector<double> >& vvScore0, 
+		vector< vector<double> >& vvScore1
+		)
+	{
+		vector< vector< vector<double> > > vvvCorrs;
+		long N = (long) vszImagePathNames.size();
+		long I = (long) GMMs.size();
+		vector< vector< vector<double> > > vvvFeatures;
+		if(N <= 0)
+		{
+			cerr<<"The image paths are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		if(I <= 0)
+		{
+			cerr<<"The GMMs are empty"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		vector<cv::Mat> vImgs;
+		HRESULT hr = LoadImagesFromPaths(vszImagePathNames, vImgs, vszLoadadFiles);
+		long NN = (long)vImgs.size();
+		if(NN <= 0 || hr != S_OK)
+		{
+			cerr<<"No images are loaded"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+//		hr = ExtColorFeaturesFromImages_BS0(vImgs, vvvFeatures, BLOCKSIZE, ref, vvvCorrs);
+		//int nDetStopBkGnd = 0;
+		//int nStop = 0;
+		//TestOnlineBkgndFrames1Dot2(vImgs, nDetStopBkGnd, nStop);
+		//int nStartSeq = nDetStopBkGnd + 1;
+		//int nStopSeq = nStop;
+		int nDetStopBkGnd = nStartSeq - 1;
+		IplImage* pBkGnd = NULL;
+		cv::Mat BkGnd;
+		AccBackGroundbyIndex(vImgs, 0, nDetStopBkGnd, BkGnd);
+		IplImage BkGndipl = BkGnd.operator IplImage();
+		pBkGnd = &BkGndipl;
+		hr = ExtColorFeaturesFromImagesStartStop(vImgs, vvvFeatures, BLOCKSIZE, nStartSeq, nStopSeq, pBkGnd, vvvCorrs);
+		// background frames with null vectors!
+		if(hr != S_OK)
+		{
+			cerr<<"Error while extracting color features"<<endl;
+			return hr;
+		}
+		string szFolder, szDelim;
+		FindCurrentFolderANDDelim(GMMPath, szFolder, szDelim);
+		szFEFolder = szFolder + szDelim + "MyFE" + szDelim;
+		string mkdirFolder = "mkdir " + szFEFolder;
+		struct stat st;
+		if(stat(szFEFolder.c_str(),&st) != 0)
+			system(mkdirFolder.c_str());
+
+		vector< vector<int> > vvRecogClasses0;
+
+		vector< vector< vector<double> > > vvvRecogVec0;
+		vector< vector< vector<double> > > vvvRecogVec1;
+		//TestAllFeatures_BS0(vvvFeatures, GMMs, vvRecogClasses0, vvvRecogVec0, vvvCorrs);
+	
+		//unordered_map<string, GMM> hNewGMMs;
+		//vector<GMM> newGMMs;
+		string szSeqName, szCurrPath;
+		FindCurrentSeqNamePath(vszLoadadFiles[0], szSeqName, szCurrPath);
+		string szTmpName = szCurrPath + szSeqName;
+		vector< vector< vector<double> > > vvvRecogScores;
+		int nNumIter = GMMITER;
+		if(nAdaptMode == 1)
+			nNumIter = 0;
+		if(bFrameBatch)
+		{
+			// Framewise adaptation
+			for(long n = 0; n < vvvFeatures.size(); n++)
+			{
+				if(n >= nStartSeq && n < nStopSeq)
+				{
+					vector<int> vRecogClasses0;
+					vector<int> vRecogClasses1;
+					vector< vector< vector<double> > > vvvRecogVec0;
+					vector< vector< vector<double> > > vvvRecogVec1;
+					//TestAFrameFeatures_BS0_V2(vvvFeatures, GMMs, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+					unordered_map<string, GMM> hNewGMMs;
+					vector<GMM> newGMMs;
+
+					vector<GMM> GMMsCopy;
+					GMMsCopy = GMMs;
+
+					for(int nIter = 1; nIter <= nNumIter; nIter++)
+					{
+						vvvRecogVec0.clear();
+						hNewGMMs.clear();
+						newGMMs.clear();
+						//TestAFrameFeatures_BS0_V2(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+						TestAFrameFeatures_BS0(vvvFeatures, GMMsCopy, vRecogClasses0, vvvRecogVec0, n, vvvCorrs);
+						Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, vszLoadadFiles[n], hNewGMMs, nIter);
+						GMMHash2VectBH(hNewGMMs, newGMMs);
+						GMMsCopy.clear();
+						GMMsCopy = newGMMs;
+					}
+					//TestAFrameFeatures(vvvFeatures, newGMMs, vRecogClasses1, vvvRecogVec1, n);
+					if(nNumIter < 1)
+					{
+						newGMMs = GMMs;
+					}
+					vector< vector<double> > vvScores;
+					TestAFrameFeatures_BS0_Scores(vvvFeatures, newGMMs, vvScores, n, vvvCorrs);
+					vvvRecogScores.push_back(vvScores);
+				}
+				else
+				{
+					vector< vector<double> > vvScores;
+					vvvRecogScores.push_back(vvScores);
+				}
+			}
+
+		}
+		else
+		{
+			// Batch adaptation
+			vector<GMM> GMMsCopy;
+			GMMsCopy = GMMs;
+			unordered_map<string, GMM> hNewGMMs;
+			vector<GMM> newGMMs;
+			for(int nIter = 1; nIter <= nNumIter; nIter++)
+			{
+				vvvRecogVec0.clear();
+				hNewGMMs.clear();
+				newGMMs.clear();
+				//TestAllFeatures_BS0_V2(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+				TestAllFeatures_BS0(vvvFeatures, GMMsCopy, vvRecogClasses0, vvvRecogVec0, vvvCorrs) ;
+				Do_Skin_HTKMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs, nIter);
+				GMMHash2VectBH(hNewGMMs, newGMMs);
+				GMMsCopy.clear();
+				GMMsCopy = newGMMs;
+			}
+			if(nNumIter < 1)
+			{
+				newGMMs = GMMs;
+			}
+			AllFeatures_BS0_Scores(vvvFeatures, newGMMs, vvvRecogScores, vvvCorrs);
+		}
+		vvRecogClasses.resize(vvvFeatures.size());
+		vvScore0.resize(vvvFeatures.size());
+		vvScore1.resize(vvvFeatures.size());
+		if(nAdaptMode == 0)
+		{
+			// MAP only
+			for(int i = 0; i < vvvFeatures.size(); ++i)
+			{
+				if(i >= nStartSeq && i < nStopSeq)
+				{
+					vvRecogClasses[i].resize(vvvRecogScores[i].size(), 0);
+					vvScore0[i].resize(vvvRecogScores[i].size(), 0.0);
+					vvScore1[i].resize(vvvRecogScores[i].size(), 0.0);
+					for(size_t j = 0; j < vvvRecogScores[i].size(); ++j)
+					{
+						vvScore0[i][j] = vvvRecogScores[i][j][0];
+						vvScore1[i][j] = vvvRecogScores[i][j][1];
+						if(vvvRecogScores[i][j][1] - vvvRecogScores[i][j][0] > 0.0)
+						{
+							vvRecogClasses[i][j] = 1;
+						}
+					}
+				}
+			}
+		}
+		else
+		{
+			// Score fusions
+			vector< vector< vector<double> > > vvvScoreForFusions(vvvFeatures.size());
+			for(int i = 0; i < vvvFeatures.size(); ++i)
+			{
+				if(i >= nStartSeq && i < nStopSeq)
+				{
+					vvvScoreForFusions[i].resize(vvvRecogScores[i].size());
+					vvScore0[i].resize(vvvRecogScores[i].size(), 0.0);
+					vvScore1[i].resize(vvvRecogScores[i].size(), 0.0);
+					for(size_t j = 0; j < vvvRecogScores[i].size(); ++j)
+					{
+						double LLR = vvvRecogScores[i][j][1] - vvvRecogScores[i][j][0];
+						double sLLR = 1.0/(1.0+exp(-0.5*LLR));
+						double sCorr = 0.1140*vvvCorrs[i][j][0] + 0.5870 * vvvCorrs[i][j][1] + 0.2989*vvvCorrs[i][j][2];
+						//cout<<LLR<<"\t"<<sLLR<<"\t"<<sCorr<<endl;
+						vvvScoreForFusions[i][j].push_back(sLLR);
+						vvvScoreForFusions[i][j].push_back(sCorr);
+					}
+				}
+			}
+			vector< vector< vector<double> > > vvvRecogFusionScores;
+			TestAllFeatures_Scores(vvvScoreForFusions, 
+								vFusionGMMs, 
+								vvRecogClasses,
+								vvvRecogFusionScores
+								);
+			for(int i = 0; i < vvvFeatures.size(); ++i)
+			{
+				for(size_t j = 0; j < vvvRecogScores[i].size(); ++j)
+				{
+					vvScore0[i][j] = vvvRecogFusionScores[i][j][0];
+					vvScore1[i][j] = vvvRecogFusionScores[i][j][1];
+				}
+			}
+			//TestAllFeatures(vvvScoreForFusions, vFusionGMMs, vvRecogClasses);
+		}
+
+		//Do_Skin_SMAP(vvvRecogVec0, GMMPath, szFEFolder, szTmpName, hNewGMMs);
+		//GMMHash2VectBH(hNewGMMs, newGMMs);
+		//TestAllFeatures(vvvFeatures, newGMMs, vvRecogClasses);
+		//TestAllFeatures_BS0(vvvFeatures, newGMMs, vvRecogClasses, vvvCorrs);
+		vvxyrange.resize(NN);
+		for(long n = 0; n < NN; n++)
+		{
+			vvxyrange[n].push_back(vImgs[n].cols);
+			vvxyrange[n].push_back(vImgs[n].rows);
+		}
+		return S_OK;
+	}
+
+
+
+
+
+	static int GMMByLAB(string GMMPaths, string DataLABPaths, double& Acc)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		
+		int BLOCKSIZE = 16;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName0 = DataLABPaths + "_Orig01";
+		LoadJPGLabelInfo lb, lb0;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			BaselineASeq(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb0.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		lb0.SaveJPGInfo(szLabelPathName0);
+		return 0;
+//		unordered_map<string, GMM> hGMMs;
+//		vector<GMM> GMMs;
+//		GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+//		GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+//
+//		// Get Current Folder
+//		int nPos0001 = DataLABPaths.find_last_of("/");
+//		int nPob0001 = DataLABPaths.find_last_of("\\");
+//		int nPos01 = (nPob0001>nPos0001)?nPob0001:nPos0001;
+//		string szCurrFolder = DataLABPaths.substr(0, nPos01);
+//
+//		string szDelim = "";
+//		if(nPos01 == nPob0001) szDelim = "\\";
+//		else if(nPos01 == nPos0001) szDelim = "/";
+//		
+//		// Create FE store folder
+//		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+//		string sysMkDirFE = "mkdir " + szFEFolder;
+//		system(sysMkDirFE.c_str());
+//		string szTmp = DataLABPaths + "_Tmp";
+//		string szTmpMLF = DataLABPaths + "_Tmp.mlf";
+//		string GMMCopy = GMMPaths + "_Tmp";
+//		
+//		// Output Label
+//		string szLabelPathName = DataLABPaths;
+//		string szLabelPathName1 = DataLABPaths + "_MAPPFHTK";
+//		string szLabelPathName0 = DataLABPaths + "_Orig01";
+//
+//		Acc = 0.0;
+//		double Acc0 = 0.0;
+//		double N_1 = 0;
+//		int BLKSIZE = 16;
+//		// int nCountX = 0;
+//		// int nCountO = 0;
+//		unordered_map<string, int> hszJPGFiles;
+//		unordered_map<string, int> hszJPGFiles1;
+//		unordered_map<string, int> hszJPGFiles0;
+//
+////#ifdef _WIN32
+////		string szCopyGMM = "copy " + GMMPaths + " " + GMMCopy;
+////#else
+////		string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+////#endif
+//
+//		// Now, load label
+//		LoadJPGLabelInfo lb, lb0, lb1;
+//		lb.m_szLabelPathName = szLabelPathName;
+//		lb.LoadJPGInfo();
+//
+//		// Loop through all files included in the label file:
+//		for(size_t n = 0; n < lb.m_vszKeyOrder.size(); n++)
+//		{
+//			string szCurrFilePath = lb.m_vszKeyOrder[n];
+//
+//			int nPos001s = szCurrFilePath.find_last_of("/");
+//			int nPos001b = szCurrFilePath.find_last_of("\\");
+//			int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+//			int nPos002 = szCurrFilePath.find_last_of(".");
+//			string szCurrFileName = szCurrFilePath.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+//			string szCurrFE1 = szFEFolder + szCurrFileName +"_Hand.fe";
+//			string szCurrFE0 = szFEFolder + szCurrFileName +"_BkGnd.fe";
+//
+//			JPGLabelInfo* pinfo = &lb.m_hJPGLavelInfo[szCurrFilePath];
+//			vector< vector<double> > vvCurrFeatures;
+//			//ExtColorFeatureRGBOnly(szCurrFilePath, pinfo, vvCurrFeatures, BLKSIZE);
+//			ExtLowLevelImgFeature::ExtColorFeatureRGBOnly(szCurrFilePath, vvCurrFeatures, BLKSIZE);
+//			//ExtColorFeature(szCurrFilePath, pinfo, vvCurrFeatures, BLKSIZE);
+//			int nHeight = pinfo->m_nBlockHeight;
+//			int nWidth = pinfo->m_nBlockWidth;
+//			vector<int> vCurrRecogClasses0, vCurrRecogClasses;
+//			double Accn0 = 0.0;
+//			double Accn = 0.0;
+//			vector<int> confres0, confres;
+//			Test2ClassesGMMs(vvCurrFeatures, lb.m_hJPGClasses[szCurrFilePath], GMMs, vCurrRecogClasses0, Accn0, confres0);
+//			vector< vector<double> > vvRecog0, vvRecog1;
+//			// Collect those recognized as background and hand, respectively
+//			for(int k1 = 0; k1 < nWidth; k1++)
+//			{
+//				for(int k2 = 0; k2 < nHeight; k2++)
+//				{
+//					int nCurrIndex = k1 * nHeight + k2;
+//					if(vCurrRecogClasses0[nCurrIndex] == 0)
+//					{
+//						vvRecog0.push_back(vvCurrFeatures[nCurrIndex]);
+//					}
+//					else if(vCurrRecogClasses0[nCurrIndex] == 1)
+//					{
+//						vvRecog1.push_back(vvCurrFeatures[nCurrIndex]);
+//						lb0.MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1, nWidth, nHeight);
+//						if(lb0.m_hszJPGFiles.find(szCurrFilePath) == lb0.m_hszJPGFiles.end())
+//						{
+//							lb0.m_vszKeyOrder.push_back(szCurrFilePath);
+//						}					
+//						lb0.m_hszJPGFiles[szCurrFilePath] = 1;
+//					}
+//				}
+//			}
+//			double NN = (double)(nWidth * nHeight);
+//			Acc0 = (Accn0 * NN + Acc0 * N_1)/(N_1+NN);
+//			N_1 += NN;
+//		}
+//		cout<<"Original result is "<<Acc0<<endl;
+//		//lb1.SaveJPGInfo(szLabelPathName1);
+//		lb0.SaveJPGInfo(szLabelPathName0);
+//		return 0;
+	}
+
+	static int GMMByLAB(string GMMPaths, string DataLABPaths, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		
+		int BLOCKSIZE = 16;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName0 = DataLABPaths + "_Orig01";
+		LoadJPGLabelInfo lb, lb0;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			BaselineASeq(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					//cout<<"inside loop "<<mm<<endl;
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb0.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb0.SaveJPGInfo(szLabelPathName0);
+		return 0;
+	}
+
+
+	static int GMMByLAB_NOBS(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		
+		int BLOCKSIZE = 16;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName0 = DataLABPaths + "_Orig01";
+		LoadJPGLabelInfo lb, lb0;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			int nStartSeq =0;
+			int nStopSeq = 0;
+			BaselineASeq_NOBS(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+			// Get differences:
+			for(size_t nn = nStartSeq; nn < nStopSeq/*hvszKeyNames[vszKeys[n]].size()*/; nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					//cout<<"inside loop "<<mm<<endl;
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb0.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb0.SaveJPGInfo(szLabelPathName0);
+		return 0;
+	}
+
+	static int GMMByLAB_BS0_Corrs_Only(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		
+		int BLOCKSIZE = 16;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName0 = DataLABPaths + "_Orig01";
+		LoadJPGLabelInfo lb, lb0;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			int nStartSeq =0;
+			int nStopSeq = 0;
+			BaselineASeq_BS0_Corrs_Only(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+			// Get differences:
+			for(size_t nn = nStartSeq; nn < nStopSeq/*hvszKeyNames[vszKeys[n]].size()*/; nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					//cout<<"inside loop "<<mm<<endl;
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb0.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb0.SaveJPGInfo(szLabelPathName0);
+		return 0;
+	}
+
+
+
+
+	static int GMMByLAB_BS0(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		
+		int BLOCKSIZE = 16;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName0 = DataLABPaths + "_Orig01";
+		LoadJPGLabelInfo lb, lb0;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			int nStartSeq =0;
+			int nStopSeq = 0;
+			BaselineASeq_BS0(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+			// Get differences:
+			for(size_t nn = nStartSeq; nn < nStopSeq/*hvszKeyNames[vszKeys[n]].size()*/; nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					//cout<<"inside loop "<<mm<<endl;
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb0.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb0.SaveJPGInfo(szLabelPathName0);
+		return 0;
+	}
+
+
+	static int GMMHTKMAPByLAB_Cheat(string GMMPaths, string DataLABPaths, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_MAPPF";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector< vector<int> > vvRecogClassesCheat(hvszKeyNames[vszKeys[n]].size());
+			vector<string> vszLoadadFiles;
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+				size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+				size_t hhww = hh*ww;
+				vvRecogClassesCheat[nn].reserve(hhww);
+				vvRecogClassesCheat[nn].resize(hhww);
+				for(size_t mm = 0; mm < hhww; mm++)
+				{
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					vvRecogClassesCheat[nn][mm] = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+				}
+			}
+
+
+			HTKGMMAdaptPerFrame_Cheat(GMMs, GMMPaths, szFEFolder, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, vvRecogClassesCheat);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					//int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					int nclass = vvRecogClassesCheat[nn][mm];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+	}
+
+
+
+	static int GMMHTKMAPByLAB_BS0_Cheat(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_SMAPPF";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+
+			vector< vector<int> > vvRecogClassesCheat(hvszKeyNames[vszKeys[n]].size());
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+				size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+				size_t hhww = hh*ww;
+				vvRecogClassesCheat[nn].reserve(hhww);
+				vvRecogClassesCheat[nn].resize(hhww);
+				for(size_t mm = 0; mm < hhww; mm++)
+				{
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					vvRecogClassesCheat[nn][mm] = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+				}
+			}
+
+
+			int nStartSeq = 0;
+			int nStopSeq = 0;
+			HTKGMMMAPPerFrame_BS0_Cheat(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq, GMMPaths, vvRecogClassesCheat);
+
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = nStartSeq; nn < nStopSeq; nn++) //hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn - nStartSeq].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn - nStartSeq][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn - nStartSeq][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+	}
+
+	static int GMMHTKMAPByLAB_BS0_Scores(string& GMMPaths, string& DataLABPaths, string& szRefSCP, string& szOutData)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_SMAPPF";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		FILE* pfOut = NULL;
+		//string tmpFolder, tmpDelim;
+		//GMMAdaptTool::FindCurrentFolderANDDelim(szOutData, tmpFolder, tmpDelim);
+		//CVideoFE tmpfe;
+		//tmpfe.MkdirHier(tmpFolder);
+		pfOut = fopen(szOutData.c_str(), "wb");
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			vector< vector< vector<double> > > vvvRecogScores;
+			int nStartSeq = 0;
+			int nStopSeq = 0;
+			HTKGMMMAPPerFrame_BS0_Scores(GMMs, hvszKeyNames[vszKeys[n]], vvvRecogScores, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq, GMMPaths);
+			for(size_t n1 = 0; n1 < vvvRecogScores.size(); ++n1)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][n1 + nStartSeq];
+				size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+				size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+				for(size_t n2 = 0; n2 < vvvRecogScores[n1].size(); ++n2)
+				{
+					size_t mm2 =  n2 / hh;
+					size_t mm1 = n2 - (mm2 * hh);
+					double dbclass = (double)lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					fwrite(&dbclass, sizeof(double), 1, pfOut);
+					for(size_t n3 = 0; n3 < vvvRecogScores[n1][n2].size(); ++n3)
+					{
+						double db = vvvRecogScores[n1][n2][n3];
+						fwrite(&db, sizeof(double), 1, pfOut);
+					}
+				}
+			}
+			cout<<"Sequence "<<n<<" is computed!"<<endl;
+		}
+		fclose(pfOut);
+
+		return 0;
+	}
+
+	static int GMMHTKMAPByLAB2_BS0_Scores(string& GMMPaths, string& DataLABPaths, string& szRefSCP, string& szOutData)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_MAPAL";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+		
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		FILE* pfOut = NULL;
+		//string tmpFolder, tmpDelim;
+		//GMMAdaptTool::FindCurrentFolderANDDelim(szOutData, tmpFolder, tmpDelim);
+		//CVideoFE tmpfe;
+		//tmpfe.MkdirHier(tmpFolder);
+		pfOut = fopen(szOutData.c_str(), "wb");
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector< vector<double> > > vvvRecogScores;
+			vector<string> vszLoadadFiles;
+			int nStartSeq = 0;
+			int nStopSeq = 0;
+			HTKGMMMAPASeq_BS0_Scores(GMMs, hvszKeyNames[vszKeys[n]], vvvRecogScores, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq, GMMPaths);
+			for(size_t n1 = 0; n1 < vvvRecogScores.size(); ++n1)
+			{
+				if(vvvRecogScores[n1].size())
+				{
+					string szCurrFileName = hvszKeyNames[vszKeys[n]][n1];
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					for(size_t n2 = 0; n2 < vvvRecogScores[n1].size(); ++n2)
+					{
+						size_t mm2 =  n2 / hh;
+						size_t mm1 = n2 - (mm2 * hh);
+						double dbclass = (double)lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+						fwrite(&dbclass, sizeof(double), 1, pfOut);
+						for(size_t n3 = 0; n3 < vvvRecogScores[n1][n2].size(); ++n3)
+						{
+							double db = vvvRecogScores[n1][n2][n3];
+							fwrite(&db, sizeof(double), 1, pfOut);
+						}
+					}
+				}
+			}
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+		}
+		fclose(pfOut);
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		return 0;
+
+	}
+
+
+
+
+
+
+	static int GMMHTKMAPByLAB_BS0(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_SMAPPF";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+
+			//vector< vector<int> > vvRecogClassesCheat(hvszKeyNames[vszKeys[n]].size());
+			//for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			//{
+			//	string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+			//	size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+			//	size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+			//	size_t hhww = hh*ww;
+			//	vvRecogClassesCheat[nn].reserve(hhww);
+			//	vvRecogClassesCheat[nn].resize(hhww);
+			//	for(size_t mm = 0; mm < hhww; mm++)
+			//	{
+			//		size_t mm2 =  mm / hh;
+			//		size_t mm1 = mm - (mm2 * hh);
+			//		vvRecogClassesCheat[nn][mm] = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+			//	}
+			//}
+
+
+			int nStartSeq = 0;
+			int nStopSeq = 0;
+			HTKGMMMAPPerFrame_BS0(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq, GMMPaths);
+
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = nStartSeq; nn < nStopSeq; nn++) //hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn - nStartSeq].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn - nStartSeq][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn - nStartSeq][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+	}
+
+
+
+	static int GMMHTKMAPByLAB2_BS0(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_MAPAL";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+		
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			int nStartSeq = 0;
+			int nStopSeq = 0;
+			HTKGMMMAPASeq_BS0(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq, GMMPaths);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+
+	}
+
+
+
+
+	static int GMMHTKMAPByLAB(string GMMPaths, string DataLABPaths, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_MAPPF";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+
+			HTKGMMAdaptPerFrame(GMMs, GMMPaths, szFEFolder, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+	//	unordered_map<string, GMM> hGMMs;
+	//	vector<GMM> GMMs;
+	//	GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+	//	GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+	//	string szDelim = "";
+	//	string szCurrFolder = "";
+
+	//	FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+
+	//	// Make feature directory
+	//	string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+	//	string sysMkDirFE = "mkdir " + szFEFolder;
+	//	system(sysMkDirFE.c_str());
+
+	//	// Temp MLF and SCP (for Adaptation)
+	//	string szTmp = DataLABPaths + "_Tmp";
+	//	string szTmpMLF = DataLABPaths + "_Tmp.mlf";
+
+	//	//string HERest = "C:\\CollectedDataCopy\\recognizer\\HTK\\bin.win32\\HERest.exe"; //"/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+	//	//string config = "C:\\CollectedDataCopy\\recognizer\\block_config"; //"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+	//	//string words = "C:\\CollectedDataCopy\\recognizer\\block_word"; //"/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+	//	//string GMMCopy = GMMPaths + "_Tmp";
+	//	//string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+
+	//	// Copy GMM
+
+	//	string GMMCopy = GMMPaths + "_Tmp";
+	//#ifdef _MSC_VER
+	//	string HERest = "C:\\CollectedDataCopy\\recognizer\\HTK\\bin.win32\\HERest.exe";
+	//	string config = "H:\\Transfer\\AdjustGMMNew\\config";
+	//	string words = "H:\\Transfer\\AdjustGMMNew\\words";
+	//	string szCopyGMM = "copy " + GMMPaths + " " + GMMCopy;
+	//#elif defined(__GNUC__)
+	//	string HERest = "/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+	//	string config = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+	//	string words = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+	//	string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+	//#endif
+
+	//	double Acc = 0.0;
+	//	double Acc0 = 0.0;
+	//	double N_1 = 0;
+	//	int BLKSIZE = 16;
+	//	// Now, load label
+	//	int nCountX = 0;
+	//	int nCountO = 0;
+
+	//	unordered_map<string, int> hszJPGFiles;
+	//	unordered_map<string, int> hszJPGFiles1;
+	//	unordered_map<string, int> hszJPGFiles0;
+	//	//unordered_map<string, int> hszCurrJPGFiles;
+	//	//unordered_map<string, JPGLabelInfo> hJPGLavelInfo;
+	//	//unordered_map< string, vector<int> > hJPGClasses;
+	//	//vector<string> vszKeyOrder;
+	//	string szLabelPathName = DataLABPaths;
+	//	//unordered_map<string, unordered_map<string, int> > hhTrainFiles;
+
+	//	//int nCountO1 = 0;
+	//	//int nCountX1 = 0;
+	//	//int nCountO10 = 0;
+	//	//int nCountX10 = 0;
+	//	//unordered_map<string, JPGLabelInfo> hJPGLavelInfo1;
+	//	//unordered_map<string, JPGLabelInfo> hJPGLavelInfo0;
+	//	string szLabelPathName1 = DataLABPaths + "_MAPPFHTK";
+	//	string szLabelPathName0 = DataLABPaths + "_Orig01";
+	//	LoadJPGLabelInfo lb, lb0, lb1;
+	//	lb.m_szLabelPathName = szLabelPathName;
+
+	//	lb.LoadJPGInfo();
+	//	//GMMAdaptTool::LoadJPGInfo(BLKSIZE, 4, nCountX, nCountO,
+	//	//							hszJPGFiles,
+	//	//							//hszCurrJPGFiles,
+	//	//							hJPGLavelInfo,
+	//	//							hJPGClasses, 
+	//	//							vszKeyOrder,
+	//	//							szLabelPathName,
+	//	//							hhTrainFiles);
+	//	// Loop through all files included in the label file:
+	//	int nTP0 = 0;
+	//	int nFP0 = 0;
+	//	int nFN0 = 0;
+	//	int nTN0 = 0;
+	//	int nTP = 0;
+	//	int nFP = 0;
+	//	int nFN = 0;
+	//	int nTN = 0;
+	//	for(size_t n = 0; n < lb.m_vszKeyOrder.size(); n++)
+	//	{
+	//		string szCurrFilePath = lb.m_vszKeyOrder[n];
+	//		string szCurrFileName = "";
+	//		FindCurrentFileName(szCurrFilePath, szCurrFileName);
+	//		// Self adaptation data path name
+	//		string szCurrFE1 = szFEFolder + szCurrFileName +"_Hand.fe";
+	//		string szCurrFE0 = szFEFolder + szCurrFileName +"_BkGnd.fe";
+
+	//		vector< vector<double> > vvCurrFeatures;
+	//		ExtLowLevelImgFeature::ExtColorFeatureRGBOnly(szCurrFilePath, vvCurrFeatures, BLKSIZE);
+	//		vector<int> vCurrRecogClasses0;
+	//		Test2ClassesGMMs(vvCurrFeatures, GMMs, vCurrRecogClasses0);
+
+	//		JPGLabelInfo* pinfo = &lb.m_hJPGLavelInfo[szCurrFilePath];
+	//		//ExtColorFeature(szCurrFilePath, pinfo, vvCurrFeatures, BLKSIZE);
+	//		//ExtColorFeatureRGBOnly(szCurrFilePath, pinfo, vvCurrFeatures, BLKSIZE);
+	//		int nHeight = pinfo->m_nBlockHeight;
+	//		int nWidth = pinfo->m_nBlockWidth;
+	//		vector<int> /*vCurrRecogClasses0,*/ vCurrRecogClasses;
+	//		double Accn0 = 0.0;
+	//		double Accn = 0.0;
+	//		vector<int> confres0, confres;
+	//		Test2ClassesGMMs(vvCurrFeatures, lb.m_hJPGClasses[szCurrFilePath], GMMs, vCurrRecogClasses0, Accn0, confres0);
+	//		nTP0 += confres0[0];
+	//		nFP0 += confres0[1];
+	//		nFN0 += confres0[2];
+	//		nTN0 += confres0[3];
+
+	//		vector< vector<double> > vvRecog0, vvRecog1;
+	//		// Collect those recognized as background and hand, respectively
+	//		for(int k1 = 0; k1 < nWidth; k1++)
+	//		{
+	//			for(int k2 = 0; k2 < nHeight; k2++)
+	//			{
+	//				int nCurrIndex = k1 * nHeight + k2;
+	//				if(vCurrRecogClasses0[nCurrIndex] == 0)
+	//				{
+	//					vvRecog0.push_back(vvCurrFeatures[nCurrIndex]);
+	//				}
+	//				else if(vCurrRecogClasses0[nCurrIndex] == 1)
+	//				{
+	//					vvRecog1.push_back(vvCurrFeatures[nCurrIndex]);
+	//					lb0.MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1, nWidth, nHeight);
+	//					if(lb0.m_hszJPGFiles.find(szCurrFilePath) == lb0.m_hszJPGFiles.end())
+	//					{
+	//						lb0.m_vszKeyOrder.push_back(szCurrFilePath);
+	//					}					
+	//					lb0.m_hszJPGFiles[szCurrFilePath] = 1;
+	//					//GMMAdaptTool::MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1,
+	//										//                                                                                                hJPGLavelInfo0,
+	//										//                                                                                                nCountO10,
+	//										//                                                                                                nCountX10,
+	//										//                                                                                                nWidth,
+	//										//                                                                                                nHeight,
+	//										//                                                                                                BLKSIZE);
+	//				}
+	//			}
+	//		}
+	//		// Prepare mlf and scp for HTK
+	//		ofstream fout;
+	//		fout.open(szTmp.c_str());
+	//		if(!fout.is_open())
+	//		{
+	//			cerr<<"Cannot Open Temp File so stop it"<<endl;
+	//			return -1;
+	//		}
+	//		ofstream fout02;
+	//		fout02.open(szTmpMLF.c_str());
+	//		if(!fout02.is_open())
+	//		{
+	//			cerr<<"Cannot open mlf file for written!"<<endl;
+	//			return -1;
+	//		}
+	//		fout02<<"#!MLF!#"<<endl;
+	//		if(0 < vvRecog0.size())
+	//		{
+	//			WriteFeatureAsHTKMFCC(vvRecog0, szCurrFE0, 9);
+	//			fout<<szCurrFE0<<endl;
+	//			fout02<<"\"*/"<<szCurrFileName<<"_BkGnd.lab\""<<endl;
+	//			fout02<<"BkGnd\n.\n";
+	//		}
+	//		if(0 < vvRecog1.size())
+	//		{
+	//			WriteFeatureAsHTKMFCC(vvRecog1, szCurrFE1, 9);
+	//			fout<<szCurrFE1<<endl;
+	//			fout02<<"\"*/"<<szCurrFileName<<"_Hand.lab\""<<endl;
+	//			fout02<<"Hand\n.\n";
+	//		}
+	//		fout.close();
+	//		fout02.close();
+	//		// Copy GMM as Temp
+	//		system(szCopyGMM.c_str());
+	//		string sysCmd = HERest;
+	//		sysCmd.append(" -C ");
+	//		sysCmd.append(config);
+	//		sysCmd.append(" -S ");
+	//		sysCmd.append(szTmp);
+	//		sysCmd.append(" -I ");
+	//		sysCmd.append(szTmpMLF);
+	//		sysCmd.append(" -H ");
+	//		sysCmd.append(GMMCopy);
+	//		sysCmd.append(" -u mpw ");
+	//		sysCmd.append(words);					
+	//		// Use HERest to adapt the model
+	//		system(sysCmd.c_str());
+
+	//		// Load adapted model
+	//		unordered_map<string, GMM> hGMMsTmp;
+	//		vector<GMM> GMMsTmp;
+	//		GMMAdaptTool::LoadGMM(GMMCopy, hGMMsTmp);
+	//		GMMAdaptTool::GMMHash2VectBH(hGMMsTmp, GMMsTmp);
+	//		//vector<int> confres;
+	//		Test2ClassesGMMs(vvCurrFeatures, lb.m_hJPGClasses[szCurrFilePath], GMMsTmp, vCurrRecogClasses, Accn, confres);
+	//		nTP += confres[0];
+	//		nFP += confres[1];
+	//		nFN += confres[2];
+	//		nTN += confres[3];
+	//		hszJPGFiles1[szCurrFilePath] = 1;
+	//		hszJPGFiles0[szCurrFilePath] = 1;
+	//		for(int k1 = 0; k1 < nWidth; k1++)
+	//		{
+	//			for(int k2 = 0; k2 < nHeight; k2++)
+	//			{
+	//				int nCurrIndex = k1 * nHeight + k2;
+	//				if(vCurrRecogClasses[nCurrIndex] == 1)
+	//				{
+	//					lb1.MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1, nWidth, nHeight);
+	//					//GMMAdaptTool::MarkSelectedPointWithoutDrawing(szCurrFilePath, k1, k2, 1, 
+	//					//												hJPGLavelInfo1, 	
+	//					//												nCountO1,
+	//					//												nCountX1,
+	//					//												nWidth,
+	//					//												nHeight,
+	//					//												BLKSIZE);
+	//					if(lb1.m_hszJPGFiles.find(szCurrFilePath) == lb1.m_hszJPGFiles.end())
+	//					{
+	//						lb1.m_vszKeyOrder.push_back(szCurrFilePath);
+	//					}					
+	//					lb1.m_hszJPGFiles[szCurrFilePath] = 1;
+	//				}
+	//			}
+	//		}
+	//		double NN = (double)(nWidth * nHeight);
+	//		Acc = (Accn * NN + Acc * N_1)/(N_1+NN);
+	//		Acc0 = (Accn0 * NN + Acc0 * N_1)/(N_1+NN);
+	//		N_1 += NN;
+	//	}
+	//	double dbPrecision0 = (double)nTP0/((double)nTP0 + (double)nFP0);
+	//	double dbRecall0 = (double)nTP0/((double)nTP0 + (double)nFN0);
+	//	double dbAccuracy0 = ((double)nTP0 + (double)nTN0)/((double)nTP0 + (double)nTN0 + (double)nFN0 + (double)nFP0);
+
+	//	double dbPrecision = (double)nTP/((double)nTP + (double)nFP);
+	//	double dbRecall = (double)nTP/((double)nTP + (double)nFN);
+	//	double dbAccuracy = ((double)nTP + (double)nTN)/((double)nTP + (double)nTN + (double)nFN + (double)nFP);
+	//	metrics.resize(14);
+	//	metrics[0] = (double) nTP0;
+	//	metrics[1] = (double) nFP0;
+	//	metrics[2] = (double) nFN0;
+	//	metrics[3] = (double) nTN0;
+	//	metrics[4] = (double) nTP;
+	//	metrics[5] = (double) nFP;
+	//	metrics[6] = (double) nFN;
+	//	metrics[7] = (double) nTN;
+	//	metrics[8] = dbPrecision0;
+	//	metrics[9] = dbRecall0;
+	//	metrics[10] = dbAccuracy0;
+	//	metrics[11] = dbPrecision;
+	//	metrics[12] = dbRecall;
+	//	metrics[13] = dbAccuracy;
+
+	//	cout<<"Original result is "<<Acc0<<endl;
+	//	cout<<"HTK MAP for each frame, result is "<<Acc<<endl;
+	//	lb1.SaveJPGInfo(szLabelPathName1);
+	//	lb0.SaveJPGInfo(szLabelPathName0);
+	//	//GMMAdaptTool::SaveJPGInfo(szLabelPathName1, 
+	//	//			hJPGLavelInfo1,
+	//	//			vszKeyOrder, 
+	//	//			hszJPGFiles1);
+	// //       GMMAdaptTool::SaveJPGInfo(szLabelPathName0,
+	// //                               hJPGLavelInfo0,
+	// //                               vszKeyOrder,
+	// //                               hszJPGFiles0);
+
+	//	return 0;
+	}
+
+	static int GMMHTKMAPByLAB2(string GMMPaths, string DataLABPaths, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_MAPAL";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+
+			HTKGMMAdaptASeq(GMMs, GMMPaths, szFEFolder, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+	//	unordered_map<string, GMM> hGMMs;
+	//	vector<GMM> GMMs;
+	//	GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+	//	GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+	//	
+	//	int nPos0001 = DataLABPaths.find_last_of("/");
+	//	int nPob0001 = DataLABPaths.find_last_of("\\");
+	//	int nPos01 = (nPob0001>nPos0001)?nPob0001:nPos0001;
+	//	string szCurrFolder = DataLABPaths.substr(0, nPos01);
+	//	string szDelim = "";
+	//	if(nPos01 == nPob0001) szDelim = "\\";
+	//	else if(nPos01 == nPos0001) szDelim = "/";
+	//	string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+	//	string sysMkDirFE = "mkdir " + szFEFolder;
+	//	system(sysMkDirFE.c_str());
+	//	string szTmp = DataLABPaths + "_Tmp";
+	//	string szTmpMLF = DataLABPaths + "_Tmp.mlf";
+	//	string GMMCopy = GMMPaths + "_Tmp";
+	//#ifdef _MSC_VER
+	//	string HERest = "C:\\CollectedDataCopy\\recognizer\\HTK\\bin.win32\\HERest.exe";
+	//	string config = "H:\\Transfer\\AdjustGMMNew\\config";
+	//	string words = "H:\\Transfer\\AdjustGMMNew\\words";
+	//	string szCopyGMM = "copy " + GMMPaths + " " + GMMCopy;
+	//#elif defined(__GNUC__)
+	//	string HERest = "/cluster/users/ycheng31/CollectedDataCopy/recognizer/HTK/bin/HERest";
+	//	string config = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/config";
+	//	string words = "/cluster/users/ycheng31/SkinGMMTools/AdjustGMMNew/words";
+	//	string szCopyGMM = "cp " + GMMPaths + " " + GMMCopy;
+	//#endif
+	//	double Acc = 0.0;
+	//	double Acc0 = 0.0;
+	//	double N_1 = 0;
+	//	int BLKSIZE = 16;
+	//	// Now, load label
+	//	int nCountX = 0;
+	//	int nCountO = 0;
+	//	unordered_map<string, int> hszJPGFiles;
+	//	unordered_map<string, int> hszJPGFiles1;
+	//	unordered_map<string, int> hszJPGFiles0;
+	//	//unordered_map<string, int> hszCurrJPGFiles;
+	//	//unordered_map<string, JPGLabelInfo> hJPGLavelInfo;
+	//	//unordered_map< string, vector<int> > hJPGClasses;
+	//	//vector<string> vszKeyOrder;
+	//	string szLabelPathName = DataLABPaths;
+	//	//unordered_map<string, unordered_map<string, int> > hhTrainFiles;
+
+	//	int nCountO1 = 0;
+	//	int nCountX1 = 0;
+	//	int nCountO10 = 0;
+	//	int nCountX10 = 0;
+	//	//unordered_map<string, JPGLabelInfo> hJPGLavelInfo1;
+	//	//unordered_map<string, JPGLabelInfo> hJPGLavelInfo0;
+	//	string szLabelPathName1 = DataLABPaths + "_MAPHTKAL";
+	//	string szLabelPathName0 = DataLABPaths + "_Orig02";
+	//	LoadJPGLabelInfo lb, lb0, lb1;
+	//	//GMMAdaptTool::LoadJPGInfo(BLKSIZE, 4, nCountX, nCountO,
+	//	//							hszJPGFiles,
+	//	//							//hszCurrJPGFiles,
+	//	//							hJPGLavelInfo,
+	//	//							hJPGClasses, 
+	//	//							vszKeyOrder,
+	//	//							szLabelPathName,
+	//	//							hhTrainFiles);
+	//	lb.m_szLabelPathName = szLabelPathName;
+	//	lb.LoadJPGInfo();
+	//	vector<string> vszSeqKeys;
+	//	unordered_map<string, vector<string> > hszSeqNames;
+	//	int nTP0 = 0;
+	//	int nFP0 = 0;
+	//	int nFN0 = 0;
+	//	int nTN0 = 0;
+	//	int nTP = 0;
+	//	int nFP = 0;
+	//	int nFN = 0;
+	//	int nTN = 0;
+	//	for(size_t n = 0; n < lb.m_vszKeyOrder.size(); n++)
+	//	{
+	//		string szCurrFilePath = lb.m_vszKeyOrder[n];
+	//		int nPos001s = szCurrFilePath.find_last_of("/");
+	//		int nPos001b = szCurrFilePath.find_last_of("\\");
+	//		int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+	//		int nPos002 = szCurrFilePath.find_last_of(".");
+	//		string szCurrFileName = szCurrFilePath.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+	//		//2010_0521_1114_50_000015
+	//		int nPos003 = szCurrFileName.find_last_of("_");
+	//		string szSeqKey = szCurrFileName.substr(0, nPos003);
+	//		if(hszSeqNames.find(szSeqKey) == hszSeqNames.end())
+	//		{
+	//			vszSeqKeys.push_back(szSeqKey);
+	//		}
+	//		hszSeqNames[szSeqKey].push_back(szCurrFilePath);
+	//	}
+
+	//	// Loop through all files included in the label file:
+	//	for(size_t n = 0; n < vszSeqKeys.size(); n++)
+	//	{
+	//		size_t nNumFramesn = hszSeqNames[vszSeqKeys[n]].size();
+	//		// Prepare mlf and scp for HTK
+	//		ofstream fout;
+	//		fout.open(szTmp.c_str());
+	//		if(!fout.is_open())
+	//		{
+	//			cerr<<"Cannot Open Temp File so stop it"<<endl;
+	//			return -1;
+	//		}
+	//		ofstream fout02;
+	//		fout02.open(szTmpMLF.c_str());
+	//		if(!fout02.is_open())
+	//		{
+	//			cerr<<"Cannot open mlf file for written!"<<endl;
+	//			return -1;
+	//		}
+	//		fout02<<"#!MLF!#"<<endl;
+	//		vector< vector<double> > vvCurrFeaturesMFrames;
+	//		vector< vector< vector<double> > > vvvCurrFeatures;
+	//		double Accn0 = 0.0;
+	//		double Accn = 0.0;
+	//		double N_1m = 0.0;
+	//		double Nmm = 0.0;
+	//		double N_1m2 = 0.0;
+	//		double Nmm2 = 0.0;
+	//		for(size_t m = 0; m < nNumFramesn; m++)
+	//		{
+	//			string szCurrFilePath = hszSeqNames[vszSeqKeys[n]][m];
+	//			int nPos001s = szCurrFilePath.find_last_of("/");
+	//			int nPos001b = szCurrFilePath.find_last_of("\\");
+	//			int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+	//			int nPos002 = szCurrFilePath.find_last_of(".");
+	//			string szCurrFileName = szCurrFilePath.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+	//			string szCurrFE1 = szFEFolder + szCurrFileName +"_Hand.fe";
+	//			string szCurrFE0 = szFEFolder + szCurrFileName +"_BkGnd.fe";
+	//			JPGLabelInfo* pinfo = &lb.m_hJPGLavelInfo[szCurrFilePath];
+	//			vector< vector<double> > vvCurrFeatures;
+	//			ExtColorFeatureRGBOnly(szCurrFilePath, pinfo, vvCurrFeatures, BLKSIZE);
+	//			vvvCurrFeatures.push_back(vvCurrFeatures);
+	//			for(size_t mm = 0; mm < vvCurrFeatures.size(); mm++)
+	//			{
+	//				vvCurrFeaturesMFrames.push_back(vvCurrFeatures[mm]);
+	//			}
+	//			int nHeight = pinfo->m_nBlockHeight;
+	//			int nWidth = pinfo->m_nBlockWidth;
+	//			vector<int> vCurrRecogClasses0, vCurrRecogClasses;
+	//			double Accn0m = 0.0;
+	//			vector<int> confres0m;
+	//			Test2ClassesGMMs(vvCurrFeatures, lb.m_hJPGClasses[szCurrFilePath], GMMs, vCurrRecogClasses0, Accn0m, confres0m);
+	//			nTP0 += confres0m[0];
+	//			nFP0 += confres0m[1];
+	//			nFN0 += confres0m[2];
+	//			nTN0 += confres0m[3];
+	//			Nmm = (double)(vCurrRecogClasses0.size());
+	//			Accn0 = (N_1m * Accn0 + Accn0m *  Nmm)/(N_1m + Nmm);
+	//			N_1m += Nmm;
+	//			vector< vector<double> > vvRecog0, vvRecog1;
+	//			// Collect those recognized as background and hand, respectively
+	//			for(int k1 = 0; k1 < nWidth; k1++)
+	//			{
+	//				for(int k2 = 0; k2 < nHeight; k2++)
+	//				{
+	//					int nCurrIndex = k1 * nHeight + k2;
+	//					if(vCurrRecogClasses0[nCurrIndex] == 0)
+	//					{
+	//						vvRecog0.push_back(vvCurrFeatures[nCurrIndex]);
+	//					}
+	//					else if(vCurrRecogClasses0[nCurrIndex] == 1)
+	//					{
+	//						vvRecog1.push_back(vvCurrFeatures[nCurrIndex]);
+	//						lb0.MarkSelectedPointWithoutDrawing(hszSeqNames[vszSeqKeys[n]][m], k1, k2, 1, nWidth, nHeight);
+	//						if(lb0.m_hszJPGFiles.find(szCurrFilePath) == lb0.m_hszJPGFiles.end())
+	//						{
+	//							lb0.m_vszKeyOrder.push_back(szCurrFilePath);
+	//						}					
+	//						lb0.m_hszJPGFiles[szCurrFilePath] = 1;
+	//						//GMMAdaptTool::MarkSelectedPointWithoutDrawing(hszSeqNames[vszSeqKeys[n]][m], k1, k2, 1, 
+	//						//												hJPGLavelInfo0, 	
+	//						//												nCountO10,
+	//						//												nCountX10,
+	//						//												nWidth,
+	//						//												nHeight,
+	//						//												BLKSIZE);
+	//					}
+	//				}
+	//			}
+	//			if(0 < vvRecog0.size())
+	//			{
+	//				WriteFeatureAsHTKMFCC(vvRecog0, szCurrFE0, 9);
+	//				fout<<szCurrFE0<<endl;
+	//				fout02<<"\"*/"<<szCurrFileName<<"_BkGnd.lab\""<<endl;
+	//				fout02<<"BkGnd\n.\n";
+	//			}
+	//			if(0 < vvRecog1.size())
+	//			{
+	//				WriteFeatureAsHTKMFCC(vvRecog1, szCurrFE1, 9);
+	//				fout<<szCurrFE1<<endl;
+	//				fout02<<"\"*/"<<szCurrFileName<<"_Hand.lab\""<<endl;
+	//				fout02<<"Hand\n.\n";
+	//			}
+	//		}
+	//		fout.close();
+	//		fout02.close();
+	//		// Copy GMM as Temp
+	//		system(szCopyGMM.c_str());
+	//		string sysCmd = HERest;
+	//		sysCmd.append(" -C ");
+	//		sysCmd.append(config);
+	//		sysCmd.append(" -S ");
+	//		sysCmd.append(szTmp);
+	//		sysCmd.append(" -I ");
+	//		sysCmd.append(szTmpMLF);
+	//		sysCmd.append(" -H ");
+	//		sysCmd.append(GMMCopy);
+	//		sysCmd.append(" -u mpw ");
+	//		sysCmd.append(words);					
+	//		// Use HERest to adapt the model
+	//		system(sysCmd.c_str());
+
+	//		// Load adapted model
+	//		unordered_map<string, GMM> hGMMsTmp;
+	//		vector<GMM> GMMsTmp;
+	//		GMMAdaptTool::LoadGMM(GMMCopy, hGMMsTmp);
+	//		GMMAdaptTool::GMMHash2VectBH(hGMMsTmp, GMMsTmp);
+	//		double NN = 0.0;
+	//		for(size_t m = 0; m < nNumFramesn; m++)
+	//		{
+	//			vector<int> vCurrRecogClassesm;
+	//			double Accnm = 0.0;
+	//			vector<int> confres0m;
+	//			Test2ClassesGMMs(vvvCurrFeatures[m], lb.m_hJPGClasses[hszSeqNames[vszSeqKeys[n]][m]], GMMsTmp, vCurrRecogClassesm, Accnm, confres0m);
+	//			nTP += confres0m[0];
+	//			nFP += confres0m[1];
+	//			nFN += confres0m[2];
+	//			nTN += confres0m[3];
+	//			hszJPGFiles1[hszSeqNames[vszSeqKeys[n]][m]] = 1;
+	//			hszJPGFiles0[hszSeqNames[vszSeqKeys[n]][m]] = 1;
+	//			Nmm2 = (double)vCurrRecogClassesm.size();
+	//			Accn = (Nmm2 * Accnm + N_1m2 * Accn)/(Nmm2 + N_1m2);
+	//			N_1m2 += Nmm2;
+	//			NN += Nmm2;
+	//			int nHeight = lb.m_hJPGLavelInfo[hszSeqNames[vszSeqKeys[n]][m]].m_nBlockHeight;
+	//			int nWidth = lb.m_hJPGLavelInfo[hszSeqNames[vszSeqKeys[n]][m]].m_nBlockWidth;
+	//			string szTempKeyName = hszSeqNames[vszSeqKeys[n]][m];
+	//			for(int k1 = 0; k1 < nWidth; k1++)
+	//			{
+	//				for(int k2 = 0; k2 < nHeight; k2++)
+	//				{
+	//					int nCurrIndex = k1 * nHeight + k2;
+	//					if(vCurrRecogClassesm[nCurrIndex] == 1)
+	//					{
+	//						lb1.MarkSelectedPointWithoutDrawing(szTempKeyName, k1, k2, 1, nWidth, nHeight);
+	//						if(lb1.m_hszJPGFiles.find(szTempKeyName) == lb1.m_hszJPGFiles.end())
+	//						{
+	//							lb1.m_vszKeyOrder.push_back(szTempKeyName);
+	//						}					
+	//						lb1.m_hszJPGFiles[szTempKeyName] = 1;
+	//						//GMMAdaptTool::MarkSelectedPointWithoutDrawing(hszSeqNames[vszSeqKeys[n]][m], k1, k2, 1, 
+	//						//												hJPGLavelInfo1, 	
+	//						//												nCountO1,
+	//						//												nCountX1,
+	//						//												nWidth,
+	//						//												nHeight,
+	//						//												BLKSIZE);
+	//					}
+	//				}
+	//			}
+	//		}
+	//		N_1m += Nmm;
+	//		Acc = (Accn * NN + Acc * N_1)/(N_1+NN);
+	//		Acc0 = (Accn0 * NN + Acc0 * N_1)/(N_1+NN);
+	//		N_1 += NN;
+	//	}	
+	//	double dbPrecision0 = (double)nTP0/((double)nTP0 + (double)nFP0);
+	//	double dbRecall0 = (double)nTP0/((double)nTP0 + (double)nFN0);
+	//	double dbAccuracy0 = ((double)nTP0 + (double)nTN0)/((double)nTP0 + (double)nTN0 + (double)nFN0 + (double)nFP0);
+
+	//	double dbPrecision = (double)nTP/((double)nTP + (double)nFP);
+	//	double dbRecall = (double)nTP/((double)nTP + (double)nFN);
+	//	double dbAccuracy = ((double)nTP + (double)nTN)/((double)nTP + (double)nTN + (double)nFN + (double)nFP);
+	//	metrics.resize(14);
+	//	metrics[0] = (double) nTP0;
+	//	metrics[1] = (double) nFP0;
+	//	metrics[2] = (double) nFN0;
+	//	metrics[3] = (double) nTN0;
+	//	metrics[4] = (double) nTP;
+	//	metrics[5] = (double) nFP;
+	//	metrics[6] = (double) nFN;
+	//	metrics[7] = (double) nTN;
+	//	metrics[8] = dbPrecision0;
+	//	metrics[9] = dbRecall0;
+	//	metrics[10] = dbAccuracy0;
+	//	metrics[11] = dbPrecision;
+	//	metrics[12] = dbRecall;
+	//	metrics[13] = dbAccuracy;
+
+	//	cout<<"Original result is "<<Acc0<<endl;
+	//	cout<<"HTK MAP for each sequence, result is "<<Acc<<endl;
+	//	lb1.SaveJPGInfo(szLabelPathName1);
+	//	lb0.SaveJPGInfo(szLabelPathName0);
+	//	//GMMAdaptTool::SaveJPGInfo(szLabelPathName1, 
+	//	//			hJPGLavelInfo1,
+	//	//			vszKeyOrder, 
+	//	//			hszJPGFiles1);	
+	//	//GMMAdaptTool::SaveJPGInfo(szLabelPathName0, 
+	//	//			hJPGLavelInfo0,
+	//	//			vszKeyOrder, 
+	//	//			hszJPGFiles0);
+	//	return 0;
+	}
+
+
+
+
+	static int GMMSMAPByLAB(string GMMPaths, string DataLABPaths, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_SMAPPF";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+
+			HTKGMMSMAPPerFrame(GMMs, GMMPaths, szFEFolder, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+	}
+
+	static int GMMSMAPByLAB2(string GMMPaths, string DataLABPaths, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_MAPAL";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+
+			HTKGMMSMAPASeq(GMMs, GMMPaths, szFEFolder, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+
+	}
+
+
+
+	static int GMMSMAPByLAB_BS0(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_SMAPPF";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			int nStartSeq = 0;
+			int nStopSeq = 0;
+			HTKGMMSMAPPerFrame_BS0(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq, GMMPaths);
+
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = nStartSeq; nn < nStopSeq; nn++) //hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn - nStartSeq].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn - nStartSeq][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn - nStartSeq][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+	}
+
+	static int GMMSMAPByLAB2_BS0(string GMMPaths, string DataLABPaths, string szRefSCP, vector<double>& metrics)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		LoadGMM(GMMPaths, hGMMs);
+		GMMHash2VectBH(hGMMs, GMMs);
+		int BLOCKSIZE = 16;
+		string szCurrFolder, szDelim;
+		FindCurrentFolderANDDelim(DataLABPaths, szCurrFolder, szDelim);
+		string szFEFolder = szCurrFolder + szDelim + "MyFE" + szDelim;
+		
+		string szLabelPathName = DataLABPaths;
+		string szLabelPathName1 = DataLABPaths + "_MAPAL";
+		LoadJPGLabelInfo lb, lb1;
+		lb.m_szLabelPathName = szLabelPathName;
+		lb.LoadJPGInfo();
+
+		// Fix JPG Label Info
+		FixlabelInfoByRefFileList(lb, szRefSCP, BLOCKSIZE);
+		
+		long N = (long) lb.m_vszKeyOrder.size();
+		unordered_map< string, vector<string> > hvszKeyNames;
+		vector<string> vszKeys;
+		for(long n = 0; n < N; n++)
+		{
+			string szName, szPath;
+			FindCurrentSeqNamePath(lb.m_vszKeyOrder[n], szName, szPath);
+			if(hvszKeyNames.find(szName) == hvszKeyNames.end())
+			{
+				vszKeys.push_back(szName);
+			}
+			hvszKeyNames[szName].push_back(lb.m_vszKeyOrder[n]);
+		}
+		long NN = (long) vszKeys.size();
+		int TP = 0;
+		int TN = 0;
+		int FP = 0;
+		int FN = 0;
+		for(long n = 0; n < NN; n++)
+		{
+			vector< vector<int> > vvRecogClasses;
+			vector<string> vszLoadadFiles;
+			int nStartSeq = 0;
+			int nStopSeq = 0;
+			HTKGMMSMAPASeq_BS0(GMMs, hvszKeyNames[vszKeys[n]], vvRecogClasses, vszLoadadFiles, BLOCKSIZE, nStartSeq, nStopSeq, GMMPaths);
+			cout<<"Sequence "<<n<<" is recognized!"<<endl;
+
+			// Get differences:
+			for(size_t nn = 0; nn < hvszKeyNames[vszKeys[n]].size(); nn++)
+			{
+				string szCurrFileName = hvszKeyNames[vszKeys[n]][nn];
+				for(size_t mm = 0; mm < vvRecogClasses[nn].size(); mm++)
+				{
+					size_t hh = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockHeight;
+					size_t ww = (size_t)lb.m_hJPGLavelInfo[szCurrFileName].m_nBlockWidth;
+					size_t mm2 =  mm / hh;
+					size_t mm1 = mm - (mm2 * hh);
+					int nclass = lb.m_hJPGLavelInfo[szCurrFileName].m_ppnLabel[mm1][mm2];
+					if(nclass == vvRecogClasses[nn][mm])
+					{
+						if(nclass == 1)
+							TP++;
+						else
+							TN++;
+					}
+					else
+					{
+						if(nclass == 0)
+							FP++;
+						else
+							FN++;
+					}
+					if(1 == vvRecogClasses[nn][mm])
+					{
+						lb1.MarkSelectedPointWithoutDrawing(szCurrFileName, mm2, mm1, 1, ww, hh);
+					}
+				}
+			}
+		}
+		//double Acc = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics.resize(7);
+		double dbPrecision = (double)(TP) / (double)(TP + FP);
+		double dbRecall = (double)(TP) / (double)(TP + FN);
+		double dbAccuracy = (double)(TP+TN)/(double)(TP+TN+FP+FN);
+		metrics[0] = (double) TP;
+		metrics[1] = (double) FP;
+		metrics[2] = (double) FN;
+		metrics[3] = (double) TN;
+		metrics[4] = dbPrecision;
+		metrics[5] = dbRecall;
+		metrics[6] = dbAccuracy;
+		lb1.SaveJPGInfo(szLabelPathName1);
+		return 0;
+
+	}
+
+
+	static int Test2ClassesGMMs(string GMMPaths, string DataPaths, double& Acc, int nFrameSize)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		vector< vector<double> > vvData;
+		vector<int> vClasses, recogClasses;
+		GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+		GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+		GMMAdaptTool::LoadLogData(DataPaths, vvData, vClasses);
+		vector<int> confres;
+		int nretval = Test2ClassesGMMs(vvData, vClasses, GMMs, recogClasses, Acc, confres);
+		return nretval;
+	}
+
+	static int Test2ClassesGMMsImg(string GMMPaths, string DataPaths, double& Acc, int nFrameSize)
+	{
+		unordered_map<string, GMM> hGMMs;
+		vector<GMM> GMMs;
+		vector< vector<double> > vvData;
+		vector<int> vClasses, recogClasses;
+		GMMAdaptTool::LoadGMM(GMMPaths, hGMMs);
+		GMMAdaptTool::GMMHash2VectBH(hGMMs, GMMs);
+		GMMAdaptTool::LoadLogData(DataPaths, vvData, vClasses);
+		vector<int> confres;
+		int nretval = Test2ClassesGMMs(vvData, vClasses, GMMs, recogClasses, Acc, confres);
+		return nretval;
+	}
+
+	static int TestBoosted2ClassesGMMs(vector<string> vGMMPaths, string DataPaths, double& Acc, vector<double>& vAlpha)
+	{
+		unordered_map<string, GMM> hGMMs;
+		//vector<GMM> GMMs;
+		vector< vector<double> > vvData;
+		vector<int> vClasses, recogClasses;
+		size_t T = vGMMPaths.size();
+		if(T != vAlpha.size())
+		{
+			cerr<<"number of models is not equal to number of weights"<<endl;
+			return -1;
+		}
+		vector< vector<GMM> > vGMMs(T);
+		GMMAdaptTool::LoadLogData(DataPaths, vvData, vClasses);
+		for(size_t t = 0; t < T; t++)
+		{
+			unordered_map<string, GMM> hTmpGMM;
+			GMMAdaptTool::LoadGMM(vGMMPaths[t], hTmpGMM);
+			GMMAdaptTool::GMMHash2VectBH(hTmpGMM, vGMMs[t]);
+		}	
+		int nretval = TestBoosted2ClassesGMMs(vvData, vClasses, vGMMs, vAlpha, recogClasses, Acc);
+		
+		return nretval;
+	}
+
+	static int TestBoosted2ClassesGMMs(vector< vector<double> >& vvData, vector<int>& vClasses, vector< vector<GMM> >& vGMMs, vector<double>& vAlpha, vector<int>& recogClasses, double& Acc)
+	{
+		int N = (int)vvData.size();
+		recogClasses.resize(N, 0);
+		int I = (int)vGMMs[0].size();
+		for(size_t t = 1; t < vGMMs.size(); t++)
+		{
+			if(I != vGMMs[t].size())
+			{
+				cerr<<"Not all GMMs has the same number of classes"<<endl;
+				return -1;
+			}
+		}
+		int ErrCount = 0;
+		for(int n = 0; n < N; n++)
+		{
+			//double maxni = GMMs[0].CompLikelihoodPart(vvData[n], vDimConsidered);//GMMs[0].CompLikelihood(vvData[n]);
+			double maxni = 0.0;
+			int argmaxni = 0;
+			for(size_t t = 0; t < vGMMs.size(); t++)
+			{
+				maxni += vAlpha[t] * vGMMs[t][0].CompLikelihood(vvData[n]);
+			}
+			for(int i = 1; i < I ;i++)
+			{
+				//double dbi = GMMs[i].CompLikelihoodPart(vvData[n], vDimConsidered);//GMMs[i].CompLikelihood(vvData[n]);
+				double dbi = 0.0;
+				
+				for(size_t t = 0; t < vGMMs.size(); t++)
+				{			
+					dbi += vAlpha[t] * vGMMs[t][i].CompLikelihood(vvData[n]);
+				}
+				if(dbi > maxni)
+				{
+					maxni = dbi;
+					argmaxni = i;
+				}
+			}
+			recogClasses[n] = argmaxni;
+		}
+		for(int n = 0; n < N; n++)
+		{
+			if(recogClasses[n] != vClasses[n])
+			{
+				ErrCount++;
+			}	
+		}
+		Acc = (double)(N - ErrCount) / (double) N;
+		return 1;
+	}
+
+	static void CompMean(vector< vector<double> >& vvData, vector<double>& vMean)
+	{
+		int N = (int)vvData.size();
+		double dbN = (double)N;
+		if(N <= 0)
+		{
+			cerr<<"Null Data"<<endl;
+			return;
+		}
+		int D = (int)vvData[0].size();
+		vMean = vector<double>(D, 0.0);
+		
+		for(int n = 0; n < N; n++)
+		{
+			for(int d = 0; d < D; d++)
+			{
+				vMean[d] += vvData[n][d];
+			}
+		}
+		for(int d = 0; d < D; d++)
+		{
+			vMean[d] /= dbN;
+		}
+	}
+
+	static void CompDiagVar(vector< vector<double> >& vvData, matrix<double>& diagVar)
+	{
+		int N = (int)vvData.size();
+		double dbN = (double)N;
+		if(N <= 0)
+		{
+			cerr<<"Null Data"<<endl;
+			return;
+		}
+		int D = (int)vvData[0].size();
+		diagVar.SetSize(D, D);
+		diagVar.Null();
+		vector<double> vMean;
+		CompMean(vvData, vMean);
+		for(int n = 0; n < N; n++)
+		{
+			for(int d = 0; d < D; d++)
+			{
+				diagVar(d, d) += pow(vvData[n][d] - vMean[d], 2.0);
+			}
+		}	
+		for(int d = 0; d < D; d++)
+		{
+			diagVar(d, d) /= dbN;
+		}
+
+	}
+	static void GetLargestConnectedComponents(vector<int>& orig, vector<int>&refined)
+	{
+		refined = vector<int>(orig.size(), 0);
+		unsigned char* img = new unsigned char[WIDTH * HEIGHT];
+		memset(img, 0, WIDTH * HEIGHT);
+		for(int nn1 = 0; nn1 < WIDTH; nn1++)
+		{
+			for(int nn2 = 0; nn2 < HEIGHT; nn2++)
+			{
+				int nn12 = nn1 * HEIGHT + nn2;
+				int nn122 = nn2 * WIDTH + nn1;
+				if(orig[nn12] == 1)
+				{
+					img[nn122] = 1;
+				}
+			}
+		}
+		unsigned char *out_uc = new unsigned char[WIDTH * HEIGHT];
+		memset(out_uc, 0, WIDTH * HEIGHT);
+		ConnectedComponents cc(WIDTH * HEIGHT);
+		cc.connected(img, out_uc, WIDTH, HEIGHT,
+			std::equal_to<unsigned char>(),
+			false);	
+		cout<<endl;
+		
+		unordered_map<unsigned char, int> hCount;
+		//hash_map<unsigned char, int> hCount;
+
+		for(int r=0; r<HEIGHT; ++r) {
+			for(int c=0; c<WIDTH; ++c)
+			{
+				unsigned char val = out_uc[r*WIDTH+c];
+				if(val != 0 && img[r*WIDTH+c] != 0)
+				{
+					if(hCount.find(out_uc[r*WIDTH+c]) ==hCount.end())
+					{
+						hCount[out_uc[r*WIDTH+c]] = 1;
+					}
+					else
+					{
+						hCount[out_uc[r*WIDTH+c]]++;
+					}
+				}
+			}
+		}		
+		unordered_map<unsigned char, int>::iterator itr;
+		//hash_map<unsigned char, int>::iterator itr;
+		int nmaxcount = 0;
+		unsigned char nkey = 0;
+		for(itr = hCount.begin();itr != hCount.end(); itr++)
+		{
+			if(itr->second > nmaxcount)
+			{
+				nmaxcount = itr->second;
+				nkey = itr->first;
+			}
+		}
+		for(int r=0; r<HEIGHT; ++r) 
+		{
+			for(int c=0; c<WIDTH; ++c)
+			{
+				if(out_uc[r*WIDTH+c] == nkey)
+				{
+					refined[c * HEIGHT + r] = 1;
+				}
+				else
+				{
+					refined[c * HEIGHT + r] = 0;
+				}
+			}
+		}
+		delete [] img;
+		delete [] out_uc;
+	}
+		
+	static void ExtColorFeature(string szFileName, JPGLabelInfo* pinfo, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		ExtLowLevelImgFeature::ExtColorFeatures(szFileName, vvFeatures, BLKSIZE);
+	//	IplImage* pimg;
+	//#ifdef LPF
+	//	CvMat* hlpf = cvCreateMat(3, 3, CV_32FC1);
+	//	cvSetReal2D(hlpf, 0, 0, 0.1);
+	//	cvSetReal2D(hlpf, 0, 1, 0.1);
+	//	cvSetReal2D(hlpf, 0, 2, 0.1);
+	//	cvSetReal2D(hlpf, 1, 0, 0.1);
+	//	cvSetReal2D(hlpf, 1, 1, 0.8);
+	//	cvSetReal2D(hlpf, 1, 2, 0.1);
+	//	cvSetReal2D(hlpf, 2, 0, 0.1);
+	//	cvSetReal2D(hlpf, 2, 1, 0.1);
+	//	cvSetReal2D(hlpf, 2, 2, 0.1);
+	//	IplImage* pimg0 = cvLoadImage(szFileName.c_str());
+	//	IplImage* pimg1 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+	//	IplImage* pimg2 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+	//	pimg = cvCreateImage(cvSize(pimg0->width,pimg0->height), pimg0->depth, pimg0->nChannels);
+	//	cvConvert(pimg0, pimg1);
+	//	cvFilter2D(pimg1, pimg2, hlpf);
+	//	cvConvert(pimg2, pimg);
+	//	cvReleaseImage(&pimg0);
+	//	cvReleaseImage(&pimg1);
+	//	cvReleaseImage(&pimg2);
+	//	cvReleaseMat(&hlpf);
+	//#else
+	//	pimg = cvLoadImage(szFileName.c_str());
+	//#endif
+	//	cv::Mat img(pimg);
+	//	cv::Mat fimg;
+	//	img.convertTo(fimg, CV_32FC3);
+
+	//	for(int x = 0; x < img.cols / BLKSIZE; x++)
+	//	{
+	//		cv::Scalar fmeanxy, stddevxy;
+	//		cv::Scalar fmeanxyhsv, stddevxyhsv;
+	//		cv::Scalar fmeanxyx, stddevxyx;
+	//		cv::Scalar fmeanxyy, stddevxyy;
+	//		cv::Mat colx = fimg/*fres*/.colRange(x*16, (x+1)*16/*min((x+1)*8, img.cols - 1)*/); 
+	//		for(int y = 0; y < img.rows / BLKSIZE; y++)
+	//		{	
+	//			cv::Mat sub = colx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+	//			cv::Mat sub8bits;
+	//			sub.convertTo(sub8bits, CV_8UC3);
+	//			cv::Mat subhsv;
+	//			cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+	//			cv::meanStdDev(sub, fmeanxy, stddevxy);
+	//			cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+	//			//JPGLabelInfo* pinfo = &m_hJPGLavelInfo[m_vszKeyOrder[n]];
+	//			//int nLabel = pinfo->m_ppnLabel[y][x];
+	//			double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+	//			double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+	//			double dbBMean = fmeanxy.val[0];
+	//			double dbGMean = fmeanxy.val[1];
+	//			double dbRMean = fmeanxy.val[2];
+	//			double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+	//			double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+	//			double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+	//			double dbVMean = fmeanxyhsv.val[2];
+	//			double dbSMean = fmeanxyhsv.val[1];
+	//			double dbHMean = fmeanxyhsv.val[0];
+	//			vector<double> vdbTemp;
+	//			//vdbTemp.push_back(dbAvgStdev);
+	//			vdbTemp.push_back(dbIMean);
+	//			vdbTemp.push_back(dbBMean);
+	//			vdbTemp.push_back(dbGMean);
+	//			vdbTemp.push_back(dbRMean);
+	//			vdbTemp.push_back(dbExBMean);
+	//			vdbTemp.push_back(dbExGMean);
+	//			vdbTemp.push_back(dbExRMean);
+	//			//vdbTemp.push_back(dbVMean);
+	//			//vdbTemp.push_back(dbSMean);
+	//			//vdbTemp.push_back(dbHMean);
+	//			vvFeatures.push_back(vdbTemp);
+	//		}
+	//	}
+	//	img.release();
+	//	cvReleaseImage(&pimg);
+	}
+
+	static void ExtColorFeatureRGBOnly(string szFileName, JPGLabelInfo* pinfo, vector< vector<double> >& vvFeatures, int BLKSIZE)
+	{
+		ExtLowLevelImgFeature::ExtColorFeatureRGBOnly(szFileName, vvFeatures, BLKSIZE);
+	//	IplImage* pimg;
+	//#ifdef LPF
+	//	CvMat* hlpf = cvCreateMat(3, 3, CV_32FC1);
+	//	cvSetReal2D(hlpf, 0, 0, 0.1);
+	//	cvSetReal2D(hlpf, 0, 1, 0.1);
+	//	cvSetReal2D(hlpf, 0, 2, 0.1);
+	//	cvSetReal2D(hlpf, 1, 0, 0.1);
+	//	cvSetReal2D(hlpf, 1, 1, 0.8);
+	//	cvSetReal2D(hlpf, 1, 2, 0.1);
+	//	cvSetReal2D(hlpf, 2, 0, 0.1);
+	//	cvSetReal2D(hlpf, 2, 1, 0.1);
+	//	cvSetReal2D(hlpf, 2, 2, 0.1);
+	//	IplImage* pimg0 = cvLoadImage(szFileName.c_str());
+	//	IplImage* pimg1 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+	//	IplImage* pimg2 = cvCreateImage(cvSize(pimg0->width,pimg0->height), IPL_DEPTH_32F, pimg0->nChannels);
+	//	pimg = cvCreateImage(cvSize(pimg0->width,pimg0->height), pimg0->depth, pimg0->nChannels);
+	//	cvConvert(pimg0, pimg1);
+	//	cvFilter2D(pimg1, pimg2, hlpf);
+	//	cvConvert(pimg2, pimg);
+	//	cvReleaseImage(&pimg0);
+	//	cvReleaseImage(&pimg1);
+	//	cvReleaseImage(&pimg2);
+	//	cvReleaseMat(&hlpf);
+	//#else
+	//	pimg = cvLoadImage(szFileName.c_str());
+	//#endif
+	//	cv::Mat img(pimg);
+	//	cv::Mat fimg;
+	//	img.convertTo(fimg, CV_32FC3);
+
+	//	for(int x = 0; x < img.cols / BLKSIZE; x++)
+	//	{
+	//		cv::Scalar fmeanxy, stddevxy;
+	//		cv::Scalar fmeanxyhsv, stddevxyhsv;
+	//		cv::Scalar fmeanxyx, stddevxyx;
+	//		cv::Scalar fmeanxyy, stddevxyy;
+	//		cv::Mat colx = fimg/*fres*/.colRange(x*16, (x+1)*16/*min((x+1)*8, img.cols - 1)*/); 
+	//		for(int y = 0; y < img.rows / BLKSIZE; y++)
+	//		{	
+	//			cv::Mat sub = colx.rowRange(y*BLKSIZE, (y+1)*BLKSIZE/*min((y+1)*8, img.rows - 1)*/);
+	//			cv::Mat sub8bits;
+	//			sub.convertTo(sub8bits, CV_8UC3);
+	//			cv::Mat subhsv;
+	//			cv::cvtColor(sub8bits, subhsv, CV_BGR2HSV);
+	//			cv::meanStdDev(sub, fmeanxy, stddevxy);
+	//			cv::meanStdDev(subhsv, fmeanxyhsv, stddevxyhsv);
+	//			//JPGLabelInfo* pinfo = &m_hJPGLavelInfo[m_vszKeyOrder[n]];
+	//			//int nLabel = pinfo->m_ppnLabel[y][x];
+	//			//double dbAvgStdev = (stddevxy.val[0] + stddevxy.val[1] + stddevxy.val[2])/3.0;
+	//			//double dbIMean = (fmeanxy.val[0] + fmeanxy.val[1] + fmeanxy.val[2]) / 3.0;
+	//			double dbBMean = fmeanxy.val[0];
+	//			double dbGMean = fmeanxy.val[1];
+	//			double dbRMean = fmeanxy.val[2];
+	//			//double dbExBMean = 2 * fmeanxy.val[0] - (fmeanxy.val[1] + fmeanxy.val[2]);
+	//			//double dbExGMean = 2 * fmeanxy.val[1] - (fmeanxy.val[0] + fmeanxy.val[2]);
+	//			//double dbExRMean = 2 * fmeanxy.val[2] - (fmeanxy.val[0] + fmeanxy.val[1]);
+	//			//double dbVMean = fmeanxyhsv.val[2];
+	//			//double dbSMean = fmeanxyhsv.val[1];
+	//			//double dbHMean = fmeanxyhsv.val[0];
+	//			vector<double> vdbTemp;
+	//			//vdbTemp.push_back(dbAvgStdev);
+	//			//vdbTemp.push_back(dbIMean);
+	//			vdbTemp.push_back(dbBMean);
+	//			vdbTemp.push_back(dbGMean);
+	//			vdbTemp.push_back(dbRMean);
+	//			//vdbTemp.push_back(dbExBMean);
+	//			//vdbTemp.push_back(dbExGMean);
+	//			//vdbTemp.push_back(dbExRMean);
+	//			//vdbTemp.push_back(dbVMean);
+	//			//vdbTemp.push_back(dbSMean);
+	//			//vdbTemp.push_back(dbHMean);
+	//			vvFeatures.push_back(vdbTemp);
+	//		}
+	//	}
+	//	img.release();
+	//	cvReleaseImage(&pimg);
+	}
+
+	// Get the minimum and maximum value of matrix stored in vector< vector<double> > form at n-th dimension
+	static HRESULT GetvvRangeAtnD(const vector< vector<double> >& vvData, unsigned int n, double& dbMin, double& dbMax)
+	{
+		size_t stvvSize = vvData.size();
+		if(stvvSize == 0)
+		{
+			return ERROR_EMPTY;
+		}
+		if(vvData[0].size() < n + 1)
+		{
+			return ERROR_INVALID_INDEX;
+		}
+		double l_dbMin = vvData[0][n];
+		double l_dbMax = vvData[0][n];
+		for(size_t t = 1; t < stvvSize; t++)
+		{
+			if(vvData[t].size() < n + 1)
+			{
+				return ERROR_INVALID_INDEX;
+			}
+			l_dbMin = (vvData[t][n] < l_dbMin)?vvData[t][n]:l_dbMin;
+			l_dbMax = (vvData[t][n] > l_dbMax)?vvData[t][n]:l_dbMax;
+		}
+		dbMin = l_dbMin;
+		dbMax = l_dbMax;
+		return S_OK;
+	}
+	
+	// normalize so that the sequence are in [0,1]
+	static HRESULT Makein01(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData)
+	{
+		HRESULT hr = S_OK;
+		vector<double> vMean;
+		size_t nSize = vvData.size();
+		size_t nDim = vvData[0].size();
+		vvNewData.resize(nSize);
+		if(nDim >= 2)
+		{
+			for(unsigned int n = 0; n < nDim; n++)
+			{
+				double dbMin = 0.0;
+				double dbMax = 0.0;
+				if(S_OK == (hr = GetvvRangeAtnD(vvData, n, dbMin, dbMax)) )
+				{
+					double dbhalfRange = dbMax - dbMin;
+
+					for(unsigned int t = 0; t < nSize; t++)
+					{
+						if(vvNewData[t].size() != nDim)
+						{
+							vvNewData[t].resize(nDim);
+						}
+						if(dbhalfRange > 0.0)
+						{
+							vvNewData[t][n] = (vvData[t][n] - dbMin)/dbhalfRange;
+						}
+						else
+						{
+							vvNewData[t][n] = 0.0;
+							hr = ERROR_INVALID_DATA;
+						}
+						//if(n < 2)
+						//{
+						//	vvNewData[t][n] = (vvData[t][n] - dbMin)/dbhalfRange;
+						//}
+						//else
+						//{
+						//	vvNewData[t][n] = vvData[t][n];
+						//}
+					}
+				}
+				else
+				{
+					return hr;
+				}
+			}
+			return hr;
+		}
+		return S_FALSE;
+	}
+
+	// Make vector< vector<double> > data zero mean and range from [-1, 1]
+	static HRESULT MakeZeroMeanAndUnitRange(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData)
+	{
+		HRESULT hr = S_OK;
+		vector<double> vMean;
+		size_t nSize = vvData.size();
+		if(nSize == 0)
+		{
+			return ERROR_INVALID_DATA;
+		}
+		size_t nDim = vvData[0].size();
+		if(nDim == 0)
+		{
+			return ERROR_INVALID_DATA;
+		}
+		if(S_OK == (hr = CalcvvMean(vvData, vMean)) )
+		{
+			vvNewData.resize(nSize);
+			for(size_t n = 0; n < nDim; n++)
+			{
+				double dbMin = 0.0;
+				double dbMax = 0.0;
+				if(S_OK == (hr = GetvvRangeAtnD(vvData, n, dbMin, dbMax)) )
+				{
+					double dbhalfRange = max(fabs(dbMax - vMean[n]), fabs(vMean[n] - dbMin));
+					for(size_t t = 0; t < nSize; t++)
+					{
+						if(vvNewData[t].size() != nDim)
+						{
+							vvNewData[t].resize(nDim);
+						}
+						vvNewData[t][n] = (vvData[t][n] - vMean[n])/dbhalfRange;
+					}
+				}
+				else
+				{
+					return hr;
+				}
+			}
+		}
+		return hr;
+	}
+
+	// Calculate the mean vector of a vector< vector<double> > data matrix by trating each vector<double> as a data point
+	static HRESULT CalcvvMean(const vector< vector<double> >& vvData, vector<double>& vMean)
+	{
+		size_t stvvSize = vvData.size();
+		if(stvvSize == 0)
+		{
+			return ERROR_EMPTY;
+		}
+		size_t nDim = vvData[0].size();
+		if(nDim == 0)
+		{
+			return ERROR_INVALID_DATA;
+		}
+		double dbSize = (double)stvvSize;
+		vMean.resize(nDim, 0.0);
+		for(size_t t = 1; t < stvvSize; t++)
+		{
+			if(vvData[t].size() != nDim)
+			{
+				return ERROR_INVALID_DATA;
+			}
+			for(size_t n = 0; n < nDim; n++)
+			{
+				vMean[n] += vvData[t][n]/dbSize;
+			}
+		}
+ 
+		return S_OK;
+	}
+
+	static long ReadHTKMFCCFeature(vector< vector<double> >& vvData, string szInFileName )
+	{
+		FILE* fin = NULL;
+		long nSamples = 0;
+		long sampPeriod = 0;
+		short sampSize = 0;
+		short parmKind = 0;
+		fin = fopen(szInFileName.c_str(), "rb");
+		if(fin == NULL)
+		{
+			return 2L;
+		}
+		fread(&nSamples, sizeof(long), 1, fin);
+		fread(&sampPeriod, sizeof(long), 1, fin);
+		fread(&sampSize, sizeof(short), 1, fin);
+		fread(&parmKind, sizeof(short), 1, fin);
+		long nSize = sampSize / sizeof(float);
+		float fTmp = 0.0;
+		vvData.resize(nSamples);
+		for(long n = 0; n < nSamples; n++)
+		{
+			for(long m = 0; m < nSize; m++)
+			{
+				fread(&fTmp, sizeof(float), 1, fin);
+				vvData[n].push_back((double)fTmp);
+			}
+		}
+		fclose(fin);
+		return 0;
+	}
+
+	static long WriteFeatureAsHTKMFCC(const vector< vector<double> >& vvData, string szOutFileName, short sampKind)
+	{
+		vector< vector<double> > vvNewData;
+		size_t nSize = vvData.size();
+		//for(size_t t = 0; t < vvNewData.size(); t++)
+		//{
+		//	for(size_t d = 0; d < vvNewData[t].size(); d++)
+		//	{
+		//	}
+		//}
+		short sSize = (short)vvData[0].size();
+		int nSamples = (int)vvData.size();
+		int sampPeriod = 666666;//10000000/15;
+		short sampSize = sSize * sizeof(float);
+		short parmKind = sampKind; //9; //2054; // MFCC_Z//9; // USER //2054; // MFCC_Z
+
+		FILE* hFout = 0;
+		hFout = fopen(szOutFileName.c_str(), "wb");
+		if(hFout)
+		{
+			fwrite(&nSamples, sizeof(int), 1, hFout);
+			fwrite(&sampPeriod, sizeof(int), 1, hFout);
+			fwrite(&sampSize, sizeof(short), 1, hFout);
+			fwrite(&parmKind, sizeof(short), 1, hFout);
+			for(unsigned int n = 0; n < nSize; n++)
+			{
+				float fTmp = 0.0;
+				for(short s = 0; s < sSize; s++)
+				{
+					fTmp = (float)vvData[n][s];
+					fwrite(&fTmp, sizeof(float), 1, hFout);
+				}
+			}
+		}
+		else
+		{
+			return ERROR_OPEN_FAILED;
+		}
+		if(hFout)
+		{
+			fclose(hFout);
+		}
+		return 0;
+	}
+
+	// Write the feature vector as HTK format MFCC feature file
+	static HRESULT WriteFeatureAsHTKMFCC(const vector< vector<double> >& vvData, string szOutFileName)
+	{
+		vector< vector<double> > vvNewData;
+		size_t nSize = vvData.size();
+		//cout<<"before makein01\n";
+		HRESULT hr = Makein01(vvData, vvNewData);
+		if(hr == S_OK)
+		{
+			//cout<<"ok, start writing htk feature\n";
+			short sSize = (short)vvData[0].size();
+			int nSamples = (int)vvData.size();
+			int sampPeriod = 666666;//10000000/15;
+			short sampSize = sSize * sizeof(float);
+			short parmKind = 2054; // MFCC_Z//9; // USER //2054; // MFCC_Z
+
+			FILE* hFout = 0;
+			hFout = fopen(szOutFileName.c_str(), "wb");
+			if(hFout)
+			{
+				fwrite(&nSamples, sizeof(int), 1, hFout);
+				fwrite(&sampPeriod, sizeof(int), 1, hFout);
+				fwrite(&sampSize, sizeof(short), 1, hFout);
+				fwrite(&parmKind, sizeof(short), 1, hFout);
+				for(unsigned int n = 0; n < nSize; n++)
+				{
+					float fTmp = 0.0;
+					for(short s = 0; s < sSize; s++)
+					{
+						//cout<<"before writing "<<n<<" th feature at "<<s<<" th dimension\n";
+						fTmp = (float)vvNewData[n][s];
+						fwrite(&fTmp, sizeof(float), 1, hFout);
+						//cout<<"after writing "<<n<<" th feature at "<<s<<" th dimension\n";
+
+					}
+				}
+			}
+			else
+			{
+				return ERROR_OPEN_FAILED;
+			}
+			if(hFout)
+			{
+				fclose(hFout);
+			}
+		}
+		return hr;
+	}
+
+	// Write the feature vector as HTK format MFCC feature file and its lower and upper halves
+
+	static HRESULT WriteFeatureAsHTKMFCCAndItsHalves(const vector< vector<double> >& vvData, string szOutFileName, string szOutFileName_uhalf, string szOutFileName_lhalf)
+	{
+		vector< vector<double> > vvNewData;
+		size_t nSize = vvData.size();
+		HRESULT hr = Makein01(vvData, vvNewData);
+		if(hr == S_OK)
+		{
+			short sSize = (short)vvData[0].size();
+			int nSamples = (int)vvData.size();
+			int sampPeriod = 666666;//10000000/15;
+			short sampSize = sSize * sizeof(float);
+			short sampSizeU = sSize/2 * sizeof(float);
+			short sampSizeL = (sSize - sSize/2) * sizeof(float);
+			short parmKind = 2054; // MFCC_Z  //9; // USER //2054; // MFCC_Z
+			
+			FILE* hFout = 0;
+			FILE* hFoutU = 0;
+			FILE* hFoutL = 0;
+			hFout = fopen(szOutFileName.c_str(), "wb");
+			hFoutU = fopen(szOutFileName_uhalf.c_str(), "wb");
+			hFoutL = fopen(szOutFileName_lhalf.c_str(), "wb");
+			if(hFout)
+			{
+				fwrite(&nSamples, sizeof(int), 1, hFout);
+				fwrite(&sampPeriod, sizeof(int), 1, hFout);
+				fwrite(&sampSize, sizeof(short), 1, hFout);
+				fwrite(&parmKind, sizeof(short), 1, hFout);
+				for(unsigned int n = 0; n < nSize; n++)
+				{
+					float fTmp = 0.0;
+					for(short s = 0; s < sSize; s++)
+					{
+						fTmp = (float)vvNewData[n][s];
+						fwrite(&fTmp, sizeof(float), 1, hFout);
+					}
+				}
+				fclose(hFout);
+			}
+			else 
+			{
+				hr = ERROR_OPEN_FAILED;
+			}
+			if(hFoutU)
+			{
+				fwrite(&nSamples, sizeof(int), 1, hFoutU);
+				fwrite(&sampPeriod, sizeof(int), 1, hFoutU);
+				fwrite(&sampSizeU, sizeof(short), 1, hFoutU);
+				fwrite(&parmKind, sizeof(short), 1, hFoutU);
+				for(unsigned int n = 0; n < nSize; n++)
+				{
+					float fTmp = 0.0;
+					for(short s = 0; s < sSize/2; s++)
+					{
+						fTmp = (float)vvNewData[n][s];
+						fwrite(&fTmp, sizeof(float), 1, hFoutU);
+					}
+				}
+				fclose(hFoutU);
+			}
+			else 
+			{
+				hr = ERROR_OPEN_FAILED;
+			}
+			if(hFoutL)
+			{
+				fwrite(&nSamples, sizeof(int), 1, hFoutL);
+				fwrite(&sampPeriod, sizeof(int), 1, hFoutL);
+				fwrite(&sampSizeL, sizeof(short), 1, hFoutL);
+				fwrite(&parmKind, sizeof(short), 1, hFoutL);
+				for(unsigned int n = 0; n < nSize; n++)
+				{
+					float fTmp = 0.0;
+					for(short s = sSize/2; s < sSize; s++)
+					{
+						fTmp = (float)vvNewData[n][s];
+						fwrite(&fTmp, sizeof(float), 1, hFoutL);
+					}
+				}
+				fclose(hFoutL);
+			}
+			else 
+			{
+				hr = ERROR_OPEN_FAILED;
+			}
+		}
+		else if(hr == ERROR_INVALID_DATA)
+		{
+		}
+		return hr;
+	}
+
+	static HRESULT WriteFeatureAsDEBUGTRAJ(const vector< vector<double> >& vvData, string szOutFileName1)
+	{
+		vector< vector<double> > vvNewData;
+		size_t nSize = vvData.size();
+		HRESULT hr = Makein01(vvData, vvNewData);
+		if(hr == S_OK)
+		{
+			IplImage* pImg1 = cvCreateImage(cvSize(500, 500), IPL_DEPTH_8U, 3);
+			cvSet(pImg1, CV_RGB(255, 255, 255));
+			vector<int> vPrevData(2, 0);
+			for(unsigned int n = 0; n < nSize; n++)
+			{
+				double dx1 = floor(vvNewData[n][0] * 500.0 + 0.5);
+				double dy1 = floor(vvNewData[n][1] * 500.0 + 0.5);
+				int nx1 = (int)dx1;
+				int ny1 = (int)dy1;
+				if(n == 0)
+				{
+					cvCircle(pImg1, cvPoint(nx1, ny1), 3, CV_RGB(0, 255, 0), 2);
+				}
+				else if(n == nSize - 1)
+				{
+					cvCircle(pImg1, cvPoint(nx1, ny1), 3, CV_RGB(255, 0, 0), 2);
+				}
+				else
+				{
+					cvCircle(pImg1, cvPoint(nx1, ny1), 1, CV_RGB(0, 0, 0), 1);
+				}
+				if(n > 0)
+				{
+					cvLine(pImg1, cvPoint(vPrevData[0], vPrevData[1]), cvPoint(nx1, ny1), CV_RGB(0, 0, 0), 1);
+				}
+				vPrevData[0] = nx1;
+				vPrevData[1] = ny1;
+			}
+			cvSaveImage(szOutFileName1.c_str(), pImg1);
+			cvReleaseImage(&pImg1);
+		}
+		return hr;
+	}
+
+	static HRESULT WriteFeatureAsDEBUGTRAJ(const vector< vector<double> >& vvData, string szOutFileName1, string szOutFileName2)
+	{
+		vector< vector<double> > vvNewData;
+		size_t nSize = vvData.size();
+		HRESULT hr = Makein01(vvData, vvNewData);
+		if(hr == S_OK)
+		{
+			IplImage* pImg1 = cvCreateImage(cvSize(500, 500), IPL_DEPTH_8U, 3);
+			IplImage* pImg2 = cvCreateImage(cvSize(500, 500), IPL_DEPTH_8U, 3);
+			cvSet(pImg1, CV_RGB(255, 255, 255));
+			cvSet(pImg2, CV_RGB(255, 255, 255));
+			vector<int> vPrevData(4, 0);
+			for(unsigned int n = 0; n < nSize; n++)
+			{
+				double dx1 = floor(vvNewData[n][0] * 500.0 + 0.5);
+				double dy1 = floor(vvNewData[n][1] * 500.0 + 0.5);
+				double dx2 = floor(vvNewData[n][2] * 500.0 + 0.5);
+				double dy2 = floor(vvNewData[n][3] * 500.0 + 0.5);
+				int nx1 = (int)dx1;
+				int ny1 = (int)dy1;
+				int nx2 = (int)dx2;
+				int ny2 = (int)dy2;
+				if(n == 0)
+				{
+					cvCircle(pImg1, cvPoint(nx1, ny1), 3, CV_RGB(0, 255, 0), 2);
+					cvCircle(pImg2, cvPoint(nx2, ny2), 3, CV_RGB(0, 255, 0), 2);
+				}
+				else if(n == nSize - 1)
+				{
+					cvCircle(pImg1, cvPoint(nx1, ny1), 3, CV_RGB(255, 0, 0), 2);
+					cvCircle(pImg2, cvPoint(nx2, ny2), 3, CV_RGB(255, 0, 0), 2);
+				}
+				else
+				{
+					cvCircle(pImg1, cvPoint(nx1, ny1), 1, CV_RGB(0, 0, 0), 1);
+					cvCircle(pImg2, cvPoint(nx2, ny2), 1, CV_RGB(0, 0, 0), 1);
+				}
+				if(n > 0)
+				{
+					cvLine(pImg1, cvPoint(vPrevData[0], vPrevData[1]), cvPoint(nx1, ny1), CV_RGB(0, 0, 0), 1);
+					cvLine(pImg2, cvPoint(vPrevData[2], vPrevData[3]), cvPoint(nx2, ny2), CV_RGB(0, 0, 0), 1);
+				}
+				vPrevData[0] = nx1;
+				vPrevData[1] = ny1;
+				vPrevData[2] = nx2;
+				vPrevData[3] = ny2;
+			}
+			cvSaveImage(szOutFileName1.c_str(), pImg1);
+			cvSaveImage(szOutFileName2.c_str(), pImg2);
+			cvReleaseImage(&pImg1);
+			cvReleaseImage(&pImg2);
+		}
+		return hr;
+	}
+	
+	
+	static HRESULT AccBackground(const CvArr* src, CvArr*& dst)
+	{
+		if(dst == NULL)
+		{
+			if(CV_IS_MAT_HDR(src))
+			{
+				dst = cvCreateMat(((CvMat*)src)->rows, ((CvMat*)src)->cols, ((CvMat*)src)->type);
+			}
+			else if(CV_IS_IMAGE_HDR(src))
+			{
+				dst = cvCreateImage(cvSize(((IplImage*)src)->width, ((IplImage*)src)->height), ((IplImage*)src)->depth, ((IplImage*)src)->nChannels );
+			}
+		}
+		cvAcc(src, dst);
+		return S_OK;
+	}
+
+	// Divide the number of accumulated background by its number of frames
+	static HRESULT AvgBackground(const CvArr* src, CvArr*& dst, unsigned int nnum)
+	{
+		if(dst == NULL)
+		{
+			if(CV_IS_MAT_HDR(src))
+			{
+				dst = cvCreateMat(((CvMat*)src)->rows, ((CvMat*)src)->cols, ((CvMat*)src)->type);
+			}
+			else if(CV_IS_IMAGE_HDR(src))
+			{
+				dst = cvCreateImage(cvSize(((IplImage*)src)->width, ((IplImage*)src)->height), ((IplImage*)src)->depth, ((IplImage*)src)->nChannels );
+			}
+		}
+		double dscale = 1.0;
+		if(nnum > 0)
+		{
+			dscale = 1.0/((double)(nnum));
+		}
+		cvConvertScale(src, dst, dscale);
+		return S_OK;
+	}
+
+	// This function use simply variance change magnitude to detect hand onset (start) and offset (end)
+	static HRESULT TestOnlineBkgndFrames1Dot2(vector<IplImage*>& vpImgs, int& nDetStopBkGnd, int& nStop)
+	{
+		IplImage* pBkGnd = 0;
+		IplImage* pcurr = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pdst = 0;
+		//IplImage* pImg = 0;
+		int nStart = 0;
+		vector<double> vdbStdev;
+		vector<double> vdbDifStdev;
+		
+		nStop = (int)vpImgs.size() - 1;
+		// Accumulate background information
+		double dbMostNegDif = 0.0;
+		double dbMostPosDif = 0.0;
+		double dbMaxStdev = 0.0;
+		double dbMinStdev = DBL_MAX; //1.79769e+308;
+		int nNewStop = 0;
+		for(int n = nStart; n <= nStop; n++)
+		{
+			IplImage* pcurr = vpImgs[n];
+			// OK, let's assume the first image is background, 
+			// this is a big assumption, but there is nothing else we can do.
+			if(n == nStart)			
+			{
+				pBkGnd = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+				CvScalar s0;
+				s0.val[0] = s0.val[1] = s0.val[2] = s0.val[3] = 0;
+				cvSet(pBkGnd, s0);
+				GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGnd);
+			}
+			if(n > nStart)
+			{
+				pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+				cvConvert(pcurr, pcurr2);
+				pdst = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+				cvSub(pcurr2, pBkGnd, pdst);
+				CvScalar std_dev, mean1;
+				cvAvgSdv(pdst, &mean1, &std_dev);
+				cvReleaseImage(&pdst);
+				cvReleaseImage(&pcurr2);
+				vdbStdev.push_back(std_dev.val[0]);
+				if(n - nStart > 1)
+				{
+					double dbDif = vdbStdev[n - nStart - 1] - vdbStdev[n - nStart - 2];
+					if(dbDif > 0 && dbDif > dbMostPosDif)
+					{
+						dbMostPosDif = dbDif;
+					}
+					if(dbDif < 0 && dbDif < dbMostNegDif)
+					{
+						dbMostNegDif = dbDif;
+					}
+					vdbDifStdev.push_back(dbDif);
+				}
+				if(std_dev.val[0] < dbMinStdev)
+					dbMinStdev = std_dev.val[0];
+				if(std_dev.val[0] > dbMaxStdev)
+					dbMaxStdev = std_dev.val[0];
+				//cvReleaseImage(&pdst);
+			}
+		}
+		cvReleaseImage(&pBkGnd);
+		nNewStop = nStop;
+		for(int t = 0; t < (int)vdbStdev.size(); t++)
+		{
+			double db1 = (vdbStdev[t] - dbMinStdev) / (dbMaxStdev - dbMinStdev);
+			if(db1 > 0.5)
+			{
+				nDetStopBkGnd = nStart + t - 1;
+				if(nDetStopBkGnd < 1)
+					nDetStopBkGnd = 1;
+				break;
+			}
+		}
+		for(int t = (int)vdbStdev.size() - 1; t >= 0; t--)
+		{
+			double db1 = (vdbStdev[t] - dbMinStdev) / (dbMaxStdev - dbMinStdev);
+			if(db1 > 0.25)
+			{
+				nNewStop = nStart + t + 1;
+				if(nNewStop > nStop)
+					nNewStop = nStop;
+				break;
+			}
+		}
+		//for(int n = nStop; n > nNewStop; n--)
+		//{
+		//	pImg = vpImgs[n];
+		//	vpImgs.pop_back();
+		//	cvReleaseImage(&pImg);
+		//}
+		nStop = nNewStop;
+
+		if(nDetStopBkGnd == 0)
+		{
+			return ERROR_EMPTY;
+		}
+		vdbStdev.clear();
+		vdbDifStdev.clear();
+		return S_OK;
+	}	
+	
+	static HRESULT TestOnlineBkgndFrames1Dot2(vector<cv::Mat>& vImgs, int& nDetStopBkGnd, int& nStop)
+	{
+		cv::Mat BkGnd;
+		cv::Mat curr2;
+		cv::Mat dst;
+		//IplImage* pImg = 0;
+		int nStart = 0;
+		vector<double> vdbStdev;
+		vector<double> vdbDifStdev;
+		
+		nStop = (int)vImgs.size() - 1;
+		// Accumulate background information
+		double dbMostNegDif = 0.0;
+		double dbMostPosDif = 0.0;
+		double dbMaxStdev = 0.0;
+		double dbMinStdev = DBL_MAX; //1.79769e+308;
+		int nNewStop = 0;
+		for(int n = nStart; n <= nStop; n++)
+		{
+			//curr = vImgs[n];
+			// OK, let's assume the first image is background, 
+			// this is a big assumption, but there is nothing else we can do.
+			if(n == nStart)			
+			{
+				vImgs[n].convertTo(BkGnd, CV_64F);
+			}
+			if(n > nStart)
+			{
+				//curr2 = cv::Mat(
+				
+				vImgs[n].convertTo(curr2, CV_64F);
+				dst = curr2 - BkGnd;
+				cv::Scalar std_dev, mean1;
+				cv::meanStdDev(dst, mean1, std_dev);
+				
+				vdbStdev.push_back(std_dev.val[0]);
+				if(n - nStart > 1)
+				{
+					double dbDif = vdbStdev[n - nStart - 1] - vdbStdev[n - nStart - 2];
+					if(dbDif > 0 && dbDif > dbMostPosDif)
+					{
+						dbMostPosDif = dbDif;
+					}
+					if(dbDif < 0 && dbDif < dbMostNegDif)
+					{
+						dbMostNegDif = dbDif;
+					}
+					vdbDifStdev.push_back(dbDif);
+				}
+				if(std_dev.val[0] < dbMinStdev)
+					dbMinStdev = std_dev.val[0];
+				if(std_dev.val[0] > dbMaxStdev)
+					dbMaxStdev = std_dev.val[0];
+				//cvReleaseImage(&pdst);
+			}
+		}
+		nNewStop = nStop;
+		for(int t = 0; t < (int)vdbStdev.size(); t++)
+		{
+			double db1 = (vdbStdev[t] - dbMinStdev) / (dbMaxStdev - dbMinStdev);
+			if(db1 > 0.5)
+			{
+				nDetStopBkGnd = nStart + t - 1;
+				if(nDetStopBkGnd < 1)
+					nDetStopBkGnd = 1;
+				break;
+			}
+		}
+		for(int t = (int)vdbStdev.size() - 1; t >= 0; t--)
+		{
+			double db1 = (vdbStdev[t] - dbMinStdev) / (dbMaxStdev - dbMinStdev);
+			if(db1 > 0.25)
+			{
+				nNewStop = nStart + t + 1;
+				if(nNewStop > nStop)
+					nNewStop = nStop;
+				break;
+			}
+		}
+		nStop = nNewStop;
+
+		if(nDetStopBkGnd == 0)
+		{
+			return ERROR_EMPTY;
+		}
+		vdbStdev.clear();
+		vdbDifStdev.clear();
+		return S_OK;
+	}	
+
+
+	//========================================================================================//
+	// Assume all images in each sequence are included in vImageNames.
+	// vImageNames: Input, path names of all images
+	// hSeqStart: Output, estimated image index where hand occur
+	// hSeqStop: Output, estimated image index where hand disappear
+	// hSeqs: Output, hash table for each name of sequence
+	// vSeqs: Output, key value for image sequence in order
+	//========================================================================================//
+	static void TestImageStartStop(vector<string>& vImageNames, unordered_map<string, int>& hSeqStart, unordered_map<string, int>& hSeqStop, 
+		unordered_map<string, vector<string> >& hvSeqs,
+		vector<string>& vSeqs)
+	{
+		size_t nNoImgs = vImageNames.size();
+		size_t nNoSeqs = 0;
+		for(size_t n = 0; n < nNoImgs; n++)
+		{
+			//================================================================================//
+			// Get the name of sequence
+			//================================================================================//
+			string szCurrFilePath = vImageNames[n];
+			int nPos001s = szCurrFilePath.find_last_of("/");
+			int nPos001b = szCurrFilePath.find_last_of("\\");
+			int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+			int nPos002 = szCurrFilePath.find_last_of(".");
+			string szCurrFileName = szCurrFilePath.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+			int nPos0001seq = szCurrFileName.find_last_of('_');
+			string szCurrSeqKey = szCurrFileName.substr(0, nPos0001seq + 1);
+			//================================================================================//
+			if(hvSeqs.find(szCurrSeqKey) == hvSeqs.end())
+			{
+				vSeqs.push_back(szCurrSeqKey);
+			}
+			hvSeqs[szCurrSeqKey].push_back(szCurrFilePath);
+		}
+		nNoSeqs = vSeqs.size();
+		for(size_t n = 0; n < nNoSeqs; n++)
+		{
+			vector<IplImage*> vpImgs;
+			size_t nImgINSeq = hvSeqs[vSeqs[n]].size();
+			for(size_t i = 0; i < nImgINSeq; i++)
+			{
+				// Load and store the pointer of gray scale version of images
+				string szni = hvSeqs[vSeqs[n]][i];
+				IplImage* pImg = cvLoadImage(szni.c_str(), 0);
+				IplImage* pImgq = cvCreateImage(cvSize(64, 48), pImg->depth, pImg->nChannels);
+				//IplImage* pImgq2 = cvCreateImage(cvSize(pImg->width, pImg->height), pImg->depth, pImg->nChannels);
+				int nsizeW = (int)floor((double)pImg->width / 64.0 + 0.5);
+				int nsizeH = (int)floor((double)pImg->height / 48.0 + 0.5);
+				//================================================================================//
+				// NO LPF
+				//================================================================================//
+				//CvMat* pFilter = cvCreateMat(nsizeH,nsizeW,CV_32FC1);
+				//for(int n1 = 0; n1 < nsizeH; n1++)
+				//	for(int n2 = 0; n2 < nsizeW; n2++) 
+				//		cvSetReal2D(pFilter, n1, n2, 1.0/(nsizeH*nsizeW));
+				//================================================================================//
+				//cvFilter2D(pImg, pImgq2, pFilter);
+				//cvResize(pImgq2, pImgq, CV_INTER_AREA);
+				cvResize(pImg, pImgq, CV_INTER_AREA);
+				vpImgs.push_back(pImgq);
+				//cvReleaseMat(&pFilter);
+				cvReleaseImage(&pImg);
+				//cvReleaseImage(&pImgq2);
+			}
+			int nStopBkGnd = 0;
+			int nStop = (int)nImgINSeq - 1;
+			//================================================================================//
+			// Actually test where the background start and stop
+			//================================================================================//
+			TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+			hSeqStart[vSeqs[n]] = nStopBkGnd + 1;
+			hSeqStop[vSeqs[n]] = nStop;
+			//================================================================================//
+			for(size_t i = 0; i < vpImgs.size(); i++)
+			{
+				IplImage* pImg = vpImgs[i];
+				cvReleaseImage(&pImg);
+				vpImgs[i] = NULL;
+			}
+		}	
+	}
+
+	//========================================================================================//
+	// Assume all images in each sequence are included in vImageNames.
+	// vImageNames: Input, path names of all images
+	// hJPGLabels: Input, information for each image sequences
+	// hSeqStart: Output, exact image index where hand occur
+	// hSeqStop: Output, exact image index where hand disappear
+	// hSeqs: Output, hash table for each name of sequence
+	// vSeqs: Output, key value for image sequence in order
+	//========================================================================================//
+	static void GetImageStartStop(vector<string>& vImageNames, unordered_map<string, JPGLabelInfo>& hJPGLabels, unordered_map<string, int>& hSeqStart, unordered_map<string, int>& hSeqStop,
+		unordered_map<string, vector<string> >& hvSeqs,
+		vector<string>& vSeqs)
+	{
+		size_t nNoImgs = vImageNames.size();
+		size_t nNoSeqs = 0;
+		for(size_t n = 0; n < nNoImgs; n++)
+		{
+			//================================================================================//
+			// Get the name of sequence
+			//================================================================================//
+			string szCurrFilePath = vImageNames[n];
+			int nPos001s = szCurrFilePath.find_last_of("/");
+			int nPos001b = szCurrFilePath.find_last_of("\\");
+			int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+			int nPos002 = szCurrFilePath.find_last_of(".");
+			string szCurrFileName = szCurrFilePath.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+			int nPos0001seq = szCurrFileName.find_last_of('_');
+			string szCurrSeqKey = szCurrFileName.substr(0, nPos0001seq + 1);
+			//================================================================================//
+			if(hvSeqs.find(szCurrSeqKey) == hvSeqs.end())
+			{
+				vSeqs.push_back(szCurrSeqKey);
+			}
+			hvSeqs[szCurrSeqKey].push_back(szCurrFilePath);
+		}
+		nNoSeqs = vSeqs.size();
+		for(size_t n = 0; n < nNoSeqs; n++)
+		{
+			size_t nImgINSeq = hvSeqs[vSeqs[n]].size();
+			bool bFoundStart = false;
+			for(size_t i = 0; i < nImgINSeq; i++)
+			{
+				string szCurrFilePath = hvSeqs[vSeqs[n]][i];
+				
+				if(!bFoundStart && hJPGLabels[szCurrFilePath].m_vvOnes.size())
+				{
+					bFoundStart = true;
+					hSeqStart[vSeqs[n]] = i;
+				}
+				else if(bFoundStart && 0 == hJPGLabels[szCurrFilePath].m_vvOnes.size())
+				{
+					//bFoundStop = true;
+					hSeqStop[vSeqs[n]] = i - 1;
+				}
+			}
+		}
+	}
+
+	static void GetFileNameInfo(string& szImagePathName, string& szImagePath, string& szImageName, string& szSeqName, string& szExt)
+	{
+		//================================================================================//
+		// Get the name of sequence
+		//================================================================================//
+		int nPos001s = szImagePathName.find_last_of("/");
+		int nPos001b = szImagePathName.find_last_of("\\");
+		int nPos001 = (nPos001s>nPos001b)?nPos001s:nPos001b;
+		int nPos002 = szImagePathName.find_last_of(".");
+		szImagePath = szImagePathName.substr(0, nPos001 + 1);
+		szImageName = szImagePathName.substr(nPos001 + 1, nPos002 - nPos001 - 1);
+		int nPos0001seq = szImageName.find_last_of('_');
+		szSeqName = szImageName.substr(0, nPos0001seq + 1);
+		szExt = szImagePathName.substr(nPos002);
+		//================================================================================//
+	}
+
+	//========================================================================================//
+	// Assign empty label for those not listed in hJPGLavelInfo but was listed in 
+	// the file szRefFilePath
+	// hJPGLavelInfo: Input/Output, hash table with label information on list of files
+	// hJPGClasses: Input/Output, hash table to store the ground truth classes
+	// vKeysInOrder: Output, key(file paths) in the order of listed file
+	// szRefFilePath: Input, path name of the file list with list of image paths
+	// BLKSIZE: Input, block size
+	//========================================================================================//
+	static void FixlabelInfoByRefFileList(LoadJPGLabelInfo& lb, string szRefFilePath, int BLKSIZE)
+	{
+		return FixlabelInfoByRefFileList(lb.m_hJPGLavelInfo, lb.m_hJPGClasses, lb.m_vszKeyOrder, szRefFilePath, BLKSIZE);
+	}
+	static void FixlabelInfoByRefFileList(unordered_map<string, JPGLabelInfo>& hJPGLavelInfo, unordered_map< string, vector<int> >& hJPGClasses, vector<string>& vKeysInOrder, string szRefFilePath, int BLKSIZE)
+	{
+		// First get the list of sequence:
+		unordered_map<string, int> hSeqsCount;
+		unordered_map<string, JPGLabelInfo>::iterator itr;
+		for(itr = hJPGLavelInfo.begin(); itr != hJPGLavelInfo.end(); itr++)
+		{
+			string szCurrPathName = itr->second.m_szPathName;
+			string szImagePath;
+			string szImageName;
+			string szSeqName;
+			string szExt;
+			GetFileNameInfo(szCurrPathName, szImagePath, szImageName, szSeqName, szExt);
+			hSeqsCount[szSeqName]++;
+		}
+		ifstream fin(szRefFilePath.c_str());
+		vector<string> vszRefFileLists;
+		string szBuf;
+		if(!fin.is_open())
+		{
+			cerr<<"cannot open reference file list: "<<szRefFilePath<<endl;
+			return;
+		}
+		vKeysInOrder.clear();
+		while(getline(fin, szBuf))
+		{
+			if(szBuf[szBuf.length() - 1] == '\r')
+			{
+				szBuf = szBuf.substr(0, szBuf.length()-1);
+			}
+			string szImagePath;
+			string szImageName;
+			string szSeqName;
+			string szExt;
+			GetFileNameInfo(szBuf, szImagePath, szImageName, szSeqName, szExt);
+			if(hSeqsCount.find(szSeqName) != hSeqsCount.end())
+			{
+				vKeysInOrder.push_back(szBuf);
+				if(hJPGLavelInfo.find(szBuf) == hJPGLavelInfo.end())
+				{
+					IplImage* pImg = cvLoadImage(szBuf.c_str());
+					hJPGLavelInfo[szBuf].SetWidthHeight(pImg->width, pImg->height, BLKSIZE);
+					hJPGLavelInfo[szBuf].m_szPathName = szBuf;
+					int nBlockWidth = (int)floor((double)pImg->width/(double)BLKSIZE);
+					int nBlockHeight = (int)floor((double)pImg->height/(double)BLKSIZE);
+					hJPGClasses[szBuf] = vector<int>(nBlockWidth*nBlockHeight, 0);
+					cvReleaseImage(&pImg);
+				}
+			}
+		}
+		fin.close();
+	}
+
+	static void AccBackGroundbyIndex(vector<IplImage*>& vpImgs, int nStart, int nStop, IplImage*& pAccImg)
+	{
+		if(0 == vpImgs.size())
+		{
+			cerr<<"Empty vector of images"<<endl;
+			return;
+		}
+		
+		if(nStop < nStart || nStop >= vpImgs.size() || nStart < 0)
+		{
+			cerr<<"Invalid Indices"<<endl;
+			return;
+		}
+		int nwidth = vpImgs[nStart]->width;
+		int nheight = vpImgs[nStart]->height;
+		int ndepth = vpImgs[nStart]->depth;
+		int nchannels = vpImgs[nStart]->nChannels;
+		for(int n = nStart; n <= nStop; n++)
+		{
+			if(nwidth != vpImgs[n]->width || nheight != vpImgs[n]->height || 
+				ndepth != vpImgs[n]->depth || nchannels != vpImgs[n]->nChannels)
+			{
+				cerr<<"Size mismatch at index = "<<n<<" of current stream"<<endl;
+				return;
+			}
+		}
+		if(pAccImg)
+		{
+			cvReleaseImage(&pAccImg);
+		}
+		
+		IplImage* pAccImgTmp = cvCreateImage(cvSize(nwidth, nheight), IPL_DEPTH_32F, nchannels);
+		IplImage* pAccImgTmpTmp = cvCreateImage(cvSize(nwidth, nheight), IPL_DEPTH_32F, nchannels);
+		cvSetZero(pAccImgTmp);
+		pAccImg = cvCreateImage(cvSize(nwidth, nheight), ndepth, nchannels);
+		for(int n = nStart; n <= nStop; n++)
+		{
+			cvConvert(vpImgs[n], pAccImgTmpTmp);
+			GMMAdaptTool::AccBackground((CvArr*)pAccImgTmpTmp, (CvArr*&)pAccImgTmp);
+		}
+		cvConvertScale(pAccImgTmp, pAccImg, 1.0);
+		cvReleaseImage(&pAccImgTmp);
+		cvReleaseImage(&pAccImgTmpTmp);
+		//cvConvertScale(pAccImgTmp, pAccImg, (double>(1.0)/(double)(nStop - nStart + 1)));
+	}
+
+	static void AccBackGroundbyIndex(vector<cv::Mat>& vImgs, int nStart, int nStop, cv::Mat& AccImg)
+	{
+		if(0 == vImgs.size())
+		{
+			cerr<<"Empty vector of images"<<endl;
+			return;
+		}
+		
+		if(nStop < nStart || nStop >= vImgs.size() || nStart < 0)
+		{
+			cerr<<"Invalid Indices"<<endl;
+			return;
+		}
+		
+		int nwidth = vImgs[nStart].cols;
+		int nheight = vImgs[nStart].rows;
+		int ndepth = vImgs[nStart].depth();
+		int nchannels = vImgs[nStart].channels();
+		for(int n = nStart; n <= nStop; n++)
+		{
+			if(nwidth != vImgs[n].cols || nheight != vImgs[n].rows || 
+				ndepth != vImgs[n].depth() || nchannels != vImgs[n].channels())
+			{
+				cerr<<"Size mismatch at index = "<<n<<" of current stream"<<endl;
+				return;
+			}
+		}
+		
+		IplImage* pAccImgTmp = cvCreateImage(cvSize(nwidth, nheight), IPL_DEPTH_32F, nchannels);
+		IplImage* pAccImgTmpTmp = cvCreateImage(cvSize(nwidth, nheight), IPL_DEPTH_32F, nchannels);
+		cvSetZero(pAccImgTmp);
+		//IplImage* pAccImg = cvCreateImage(cvSize(nwidth, nheight), ndepth, nchannels);
+		for(int n = nStart; n <= nStop; n++)
+		{
+			IplImage img = vImgs[n].operator IplImage();
+			cvConvert(&img, pAccImgTmpTmp);
+			GMMAdaptTool::AccBackground((CvArr*)pAccImgTmpTmp, (CvArr*&)pAccImgTmp);
+		}
+		cv::Mat tmp(pAccImgTmp);
+		AccImg = tmp * ((double)(1.0)/(double)(nStop - nStart + 1));
+		//cvConvertScale(pAccImgTmp, pAccImg, 1.0);
+
+		cvReleaseImage(&pAccImgTmp);
+		cvReleaseImage(&pAccImgTmpTmp);
+		//cvConvertScale(pAccImgTmp, pAccImg, (double>(1.0)/(double)(nStop - nStart + 1)));
+	}
+
+	//static void LoadMyBinMat(string szPathName, matrix<double>& mat)
+	//{
+	//	FILE* f = NULL;
+	//	int n1 = 0;
+	//	int n2 = 0;
+	//	double dbBuf = 0.0;
+	//	f = fopen(szPathName.c_str(), "rb");
+	//	if(!f)
+	//	{
+	//		cerr<<"Cannot open "<<szPathName<<endl;
+	//		return;
+	//	}
+	//	fread(&n1, sizeof(int), 1, f);
+	//	fread(&n2, sizeof(int), 1, f);
+	//	mat.SetSize(n1, n2);
+	//	for(int i1 = 0; i1 < n1; ++i1)
+	//	{
+	//		for(int i2 = 0; i2 < n2; ++i2)
+	//		{
+	//			fread(&dbBuf, sizeof(double), 1, f);
+	//			mat(i1, i2) = dbBuf;
+	//		}
+	//	}
+	//	fclose(f);
+	//}
+	//
+	//static void WriteMyBinMat(string szPathName, matrix<double>& mat)
+	//{
+	//	FILE* f = NULL;
+	//	int n1 = (int)mat.RowNo();
+	//	int n2 = (int)mat.ColNo();
+	//	double dbBuf = 0.0;
+	//	f = fopen(szPathName.c_str(), "wb");
+	//	if(!f)
+	//	{
+	//		cerr<<"Cannot open "<<szPathName<<endl;
+	//		return;
+	//	}
+	//	fwrite(&n1, sizeof(int), 1, f);
+	//	fwrite(&n2, sizeof(int), 1, f);
+	//	for(int i1 = 0; i1 < n1; ++i1)
+	//	{
+	//		for(int i2 = 0; i2 < n2; ++i2)
+	//		{
+	//			dbBuf = mat(i1, i2);
+	//			fwrite(&dbBuf, sizeof(double), 1, f);
+	//		}
+	//	}
+	//	fclose(f);
+	//}
+	
+	// static int GenEpsilon(matrix<double>& mat, int nDims, double eps);
+	// static int GMMBiasAdapt(vector< vector<double> >& vvData, matrix<double>& newmub, vector<GMM>& oldGMMs, vector<GMM>& newGMMs);
+	// static int GMMBiasAdapt2(vector< vector<double> >& vvData, matrix<double>& Sigmab, matrix<double>& newmub, matrix<double>& newSigmab, vector<GMM>& oldGMMs, vector<GMM>& newGMMs, int nIter);
+	// static int GMMHash2VectBH(unordered_map<string, GMM>& hGMMs, vector<GMM>& vGMMs);
+	// static int Test2ClassesGMMs(vector< vector<double> >& vvData, vector<int>& classes, vector<GMM>& GMMs, vector<int>& recogClasses, double& Acc, vector<int>& confres);
+	// static int Test2ClassesGMMs(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses);
+	// static int Test2ClassesGMMs(string GMMPaths, string DataPaths, double& Acc, int nFrameSize);
+	// static int Test2ClassesGMMsImg(string GMMPaths, string DataPaths, double& Acc, int nFrameSize);
+	// static int TestBoosted2ClassesGMMs(vector<string> vGMMPaths, string DataPaths, double& Acc, vector<double>& vAlpha);
+	// static int TestBoosted2ClassesGMMs(vector< vector<double> >& vvData, vector<int>& vClasses, vector< vector<GMM> >& vGMMs, vector<double>& vAlpha, vector<int>& recogClasses, double& Acc);
+	// static int GMMAdaptRcogbyFrame(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vclasses, double& Acc, int nFrameSize);
+	// static int GMMAdaptRcogbyFrame2(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vclasses, double& Acc, int nFrameSize);
+	// static int GMMAdaptRcogbyFrame(string GMMPaths, string DataPaths, double& Acc, int nFrameSize);
+	// static int GMMAdaptRcogbyFrame2(string GMMPaths, string DataPaths, double& Acc, int nFrameSize);
+	// static int GMMHTKMAPBySCP(string GMMPaths, string DataSCPPaths, double& Acc);
+	// static int GMMHTKMAPBySCP2(string GMMPaths, string DataSCPPaths, double& Acc);
+	// static int GMMByLAB(string GMMPaths, string DataLABPaths, double& Acc);
+	// static int GMMHTKMAPByLAB(string GMMPaths, string DataLABPaths, vector<double>& metrics);
+	// static int GMMHTKMAPByLAB2(string GMMPaths, string DataLABPaths, vector<double>& metrics);
+	// static int GMMHTKMAPByLABTestNonSkinAdaptOnly(string GMMPaths, string DataLABPaths, string szRefImgList, double& Acc, ofstream& fout);
+	// static void CompMean(vector< vector<double> >& vvData, vector<double>& vMean);
+	// static void CompDiagVar(vector< vector<double> >& vvData, matrix<double>& diagVar);
+	// static void GetLargestConnectedComponents(vector<int>& orig, vector<int>&refined);	
+	// static long ReadHTKMFCCFeature(vector< vector<double> >& vvData, string szInFileName );
+
+	//void GMMAdaptTool::MarkSelectedPointWithoutDrawing(string szCurrFile, int x, int y, int val, 
+	//	unordered_map<string, JPGLabelInfo>& hJPGLavelInfo, 
+	//	int& nCountO,
+	//	int& nCountX,
+	//	int nWidth,
+	//	int nHeight,
+	//	int BLKSIZE)
+	//{
+	//	if(hJPGLavelInfo.find(szCurrFile) == hJPGLavelInfo.end())
+	//	{
+	//		hJPGLavelInfo[szCurrFile].SetWidthHeight(nWidth*BLKSIZE, nHeight*BLKSIZE, BLKSIZE);
+	//		hJPGLavelInfo[szCurrFile].m_szPathName = szCurrFile;
+	//	}
+	//	if(val == 0)
+	//	{
+	//		hJPGLavelInfo[szCurrFile].SetAsNonSkinPixel(x, y);
+	//	}
+	//	else if(val == 1)
+	//	{
+	//		if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == 1)
+	//		{
+	//			hJPGLavelInfo[szCurrFile].SetAsNonSkinPixel(x, y);
+	//			nCountO--;
+	//		}
+	//		else
+	//		{
+	//			if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == -1)
+	//			{
+	//				nCountX--;
+	//			}
+	//			hJPGLavelInfo[szCurrFile].SetAsSkinPixel(x, y);
+	//			nCountO++;
+	//		}
+	//	}
+	//	else if(val == -1)
+	//	{
+	//		if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == -1)
+	//		{
+	//			hJPGLavelInfo[szCurrFile].SetAsNonSkinPixel(x, y);
+	//			nCountX--;
+	//		}
+	//		else
+	//		{
+	//			if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == 1)
+	//			{
+	//				nCountO--;
+	//			}
+	//			hJPGLavelInfo[szCurrFile].SetAsNotSurePixel(x, y);
+	//			nCountX++;
+	//		}
+	//	}
+	//}
+	//
+	//void GMMAdaptTool::SaveJPGInfo(string szLabelPathName, 
+	//	unordered_map<string, JPGLabelInfo>& hJPGLavelInfo,
+	//	vector<string>& vszJPGFiles,
+	//	//unordered_map<string, int>& hszCurrJPGFiles,
+	//	unordered_map<string, int>& hszJPGFiles)
+	//{
+	//	ofstream fout;
+	//	fout.open(szLabelPathName.c_str());
+	//	size_t stFiles = hJPGLavelInfo.size();
+	//	size_t stCurrFileLists = vszJPGFiles.size();
+	//	vector<string> vszOthers;
+	//	int nIndex = 0;
+	//	// Compare list of files:
+	//	//for(hash_map<string, JPGLabelInfo>::iterator itr = hJPGLavelInfo.begin();itr!=hJPGLavelInfo.end(); itr++)
+	//	//{
+	//	//	string szKey = itr->first;
+	//	//	if(hszCurrJPGFiles.find(szKey) == hszCurrJPGFiles.end())
+	//	//	{
+	//	//		vszOthers.push_back(szKey);
+	//	//	}
+	//	//}
+	//	for(int nnn = 0; nnn < (int)vszJPGFiles.size(); nnn++)
+	//	{
+	//		if(hJPGLavelInfo.find(vszJPGFiles[nnn]) != hJPGLavelInfo.end())
+	//		{
+	//			nIndex = nnn;
+	//		}
+	//	}
+	//	//for(hash_map<string, JPGLabelInfo>::iterator itr = m_hJPGLavelInfo.begin();itr!=m_hJPGLavelInfo.end(); itr++)
+	//	for(size_t st = 0; st < (size_t)nIndex; st++)
+	//	{
+	//		//string szKey = itr->first;
+	//		string szKey = vszJPGFiles[st];
+	//		fout<<hJPGLavelInfo[szKey].m_szPathName<<","<<hJPGLavelInfo[szKey].m_nBlockWidth
+	//			<<","<<hJPGLavelInfo[szKey].m_nBlockHeight<<","<<hszJPGFiles[szKey]<<endl;
+	//		for(int mm = 0; mm < hJPGLavelInfo[szKey].m_nBlockWidth; mm++)
+	//		{
+	//			for(int nn = 0; nn < hJPGLavelInfo[szKey].m_nBlockHeight; nn++)
+	//			{
+	//				if(hJPGLavelInfo[szKey].m_ppnLabel[nn][mm] == 1)
+	//				{
+	//					fout<<mm<<","<<nn<<","<<1<<endl;
+	//				}
+	//			}
+	//		}
+	//		for(int mm = 0; mm < hJPGLavelInfo[szKey].m_nBlockWidth; mm++)
+	//		{
+	//			for(int nn = 0; nn < hJPGLavelInfo[szKey].m_nBlockHeight; nn++)
+	//			{
+	//				if(hJPGLavelInfo[szKey].m_ppnLabel[nn][mm] == -1)
+	//				{
+	//					fout<<mm<<","<<nn<<","<<-1<<endl;
+	//				}
+	//			}
+	//		}
+	//		fout<<"."<<endl;
+	//	}
+	//	// Others
+	//	//for(size_t st = 0; st < vszOthers.size(); st++)
+	//	//{
+	//	//	string szKey = vszOthers[st];
+	//	//	fout<<hJPGLavelInfo[szKey].m_szPathName<<","<<hJPGLavelInfo[szKey].m_nBlockWidth
+	//	//		<<","<<hJPGLavelInfo[szKey].m_nBlockHeight<<","<<hszJPGFiles[szKey]<<endl;
+	//	//	for(int mm = 0; mm < hJPGLavelInfo[szKey].m_nBlockWidth; mm++)
+	//	//	{
+	//	//		for(int nn = 0; nn < hJPGLavelInfo[szKey].m_nBlockHeight; nn++)
+	//	//		{
+	//	//			if(hJPGLavelInfo[szKey].m_ppnLabel[nn][mm] == 1)
+	//	//			{
+	//	//				fout<<mm<<","<<nn<<","<<1<<endl;
+	//	//			}
+	//	//		}
+	//	//	}
+	//	//	for(int mm = 0; mm < hJPGLavelInfo[szKey].m_nBlockWidth; mm++)
+	//	//	{
+	//	//		for(int nn = 0; nn < hJPGLavelInfo[szKey].m_nBlockHeight; nn++)
+	//	//		{
+	//	//			if(hJPGLavelInfo[szKey].m_ppnLabel[nn][mm] == -1)
+	//	//			{
+	//	//				fout<<mm<<","<<nn<<","<<-1<<endl;
+	//	//			}
+	//	//		}
+	//	//	}
+	//	//	fout<<"."<<endl;
+	//	//}
+	//
+	//	fout.close();
+	//}
+	//	
+	/*
+	void GMMAdaptTool::LoadJPGInfo(int BLOCKSIZE, int NUMFRAMETR, int& m_nCountX, int& m_nCountO,
+							unordered_map<string, int>& m_hszJPGFiles,
+							//unordered_map<string, int>& m_hszCurrJPGFiles,
+							unordered_map<string, JPGLabelInfo>& m_hJPGLavelInfo,
+							unordered_map< string, vector<int> >& m_hJPGClasses,
+							vector<string>& m_vszKeyOrder,
+							string& m_szLabelPathName,
+							unordered_map<string, unordered_map<string, int> >& m_hhTrainFiles)
+	{
+		ifstream fin;
+		fin.open(m_szLabelPathName.c_str());
+		string szBuf;
+		while(fin>>szBuf)
+		{
+			if(szBuf[szBuf.length()-1] == '\r')
+				szBuf = szBuf.substr(0, szBuf.length()-1);
+			size_t stdot1 = szBuf.find_first_of(',');
+			string szFileName = szBuf.substr(0, stdot1);
+			szBuf = szBuf.substr(stdot1+1, szBuf.length() - stdot1 - 1);
+			size_t stdot2 = szBuf.find_first_of(',');
+			string szWidth = szBuf.substr(0, stdot2);
+			int nWidth = atoi(szWidth.c_str());
+			szBuf = szBuf.substr(stdot2+1, szBuf.length() - stdot2 - 1);
+			size_t stdot3 = szBuf.find_first_of(',');
+			string szHeight = szBuf.substr(0, stdot3);
+			int nHeight = atoi(szHeight.c_str());
+			szBuf = szBuf.substr(stdot3+1, szBuf.length() - stdot3 - 1);
+			if(m_hszJPGFiles.find(szFileName) == m_hszJPGFiles.end())
+			{
+				m_vszKeyOrder.push_back(szFileName);
+			}
+			m_hszJPGFiles[szFileName] = atoi(szBuf.c_str());
+			m_hJPGLavelInfo[szFileName].SetWidthHeight(nWidth * BLOCKSIZE, nHeight * BLOCKSIZE, BLOCKSIZE);
+			m_hJPGLavelInfo[szFileName].m_szPathName = szFileName;
+			m_hJPGClasses[szFileName] = vector<int>(nWidth*nHeight, 0);
+			fin>>szBuf;
+			if(szBuf[szBuf.length()-1] == '\r')
+				szBuf = szBuf.substr(0, szBuf.length()-1);
+			//string szFileNameKey = szFileName.substr(szFileName.find_last_of("\\") + 1, szFileName.find_last_of("_")  - szFileName.find_last_of("\\"));
+			string szFileNameKey = szFileName.substr(szFileName.find_last_of("/") + 1, szFileName.find_last_of("_")  - szFileName.find_last_of("/"));
+			int nCountLabHand = 0;
+			while(0 != szBuf.compare("."))
+			{
+				size_t stdot01 = szBuf.find_first_of(',');
+				string szx = szBuf.substr(0, stdot01);
+				szBuf = szBuf.substr(stdot01+1, szBuf.length() - stdot01 - 1);
+				size_t stdot02 = szBuf.find_first_of(',');
+				string szy = szBuf.substr(0, stdot02);
+				szBuf = szBuf.substr(stdot02+1, szBuf.length() - stdot02 - 1);
+				string szv = szBuf;
+				int ncurrx = atoi(szx.c_str());
+				int ncurry = atoi(szy.c_str());
+				if(-1 == atoi(szv.c_str()))
+				{
+					m_hJPGLavelInfo[szFileName].SetAsNotSurePixel(ncurrx, ncurry);
+					m_hJPGClasses[szFileName][ncurrx * nHeight + ncurry] = -1;
+					m_nCountX++;
+				}
+				else if(1 == atoi(szv.c_str()))
+				{
+					m_hJPGLavelInfo[szFileName].SetAsSkinPixel(ncurrx, ncurry);
+					m_hJPGClasses[szFileName][ncurrx * nHeight + ncurry] = 1;
+					m_nCountO++;
+					nCountLabHand++;
+				}
+				fin>>szBuf;
+				if(szBuf[szBuf.length()-1] == '\r')
+					szBuf = szBuf.substr(0, szBuf.length()-1);
+			}
+			if(nCountLabHand > 0)
+			{
+				
+				if(m_hhTrainFiles.find(szFileNameKey) == m_hhTrainFiles.end())
+				{
+					m_hhTrainFiles[szFileNameKey][szFileName] = nCountLabHand;
+				}
+				else
+				{
+					if(NUMFRAMETR > m_hhTrainFiles[szFileNameKey].size())
+					{
+						m_hhTrainFiles[szFileNameKey][szFileName] = nCountLabHand;
+					}
+				}
+			}
+		}
+		fin.close();
+	}
+	*/
+		
+	//static void LoadJPGInfo(int BLOCKSIZE, int NUMFRAMETRi, int& m_nCountX, int& m_nCountO, 
+	//		unordered_map<string, int>& m_hszJPGFiles,
+	//		//unordered_map<string, int>& m_hszCurrJPGFiles,
+	//		unordered_map<string, JPGLabelInfo>& m_hJPGLavelInfo,
+	//		unordered_map< string, vector<int> >& m_hJPGClasses, 
+	//		vector<string>& m_vszKeyOrder,
+	//		string& m_szLabelPathName,
+	//		unordered_map<string, unordered_map<string, int> >& m_hhTrainFiles);
+	// static void ExtColorFeature(string szFileName, JPGLabelInfo* pinfo, vector< vector<double> >& vvFeatures, int BLKSIZE);
+	// static void ExtColorFeatureRGBOnly(string szFileName, JPGLabelInfo* pinfo, vector< vector<double> >& vvFeatures, int BLKSIZE);
+
+	//static void MarkSelectedPointWithoutDrawing(string szCurrFile, int x, int y, int val, 
+	//	unordered_map<string, JPGLabelInfo>& hJPGLavelInfo, 
+	//	int& nCountO,
+	//	int& nCountX,
+	//	int nWidth,
+	//	int nHeight,
+	//	int BLKSIZE);
+	//static void SaveJPGInfo(string szLabelPathName, 
+	//	unordered_map<string, JPGLabelInfo>& hJPGLavelInfo,
+	//	vector<string>& vszJPGFiles,
+	//	//unordered_map<string, int>& hszCurrJPGFiles,
+	//	unordered_map<string, int>& hszJPGFiles);
+	// static long WriteFeatureAsHTKMFCC(const vector< vector<double> >& vvData, string szOutFileName, short sampKind);
+	// static HRESULT GMMAdaptTool::AccBackground(const CvArr* src, CvArr*& dst);
+	// static HRESULT TestOnlineBkgndFrames1Dot2(vector<IplImage*> vpImgs, int& nDetStopBkGnd, int& nStop); 
+	// static void TestImageStartStop(vector<string>& vImageNames, unordered_map<string, int>& hSeqStart, unordered_map<string, int>& hSeqStop, 
+	// unordered_map<string, vector<string> >& hvSeqs,
+	// vector<string>& vSeqs);
+	// static void GetImageStartStop(vector<string>& vImageNames, unordered_map<string, JPGLabelInfo>& hJPGLabels, unordered_map<string, int>& hSeqStart, unordered_map<string, int>& hSeqStop,
+		// unordered_map<string, vector<string> >& hvSeqs,
+		// vector<string>& vSeqs);
+	// static void GetFileNameInfo(string& szImagePathName, string& szImagePath, string& szImageName, string& szSeqName, string& szExt);
+	// static void FixlabelInfoByRefFileList(unordered_map<string, JPGLabelInfo>& hJPGLavelInfo, unordered_map< string, vector<int> >& hJPGClasses, vector<string>& vKeysInOrder, string szRefFilePath, int BLKSIZE);
+
+
+
+	//int m_nCountX;
+	//int m_nCountO;
+	//unordered_map<string, int> m_hszJPGFiles;
+	//unordered_map<string, int> m_hszCurrJPGFiles;
+	//unordered_map<string, JPGLabelInfo> m_hJPGLavelInfo;
+	//vector<string> m_vszKeyOrder;
+	//string m_szLabelPathName;
+	//unordered_map<string, unordered_map<string, int> > m_hhTrainFiles;
+
+	
+};
diff --git a/LoadJPGLabelInfo.h b/LoadJPGLabelInfo.h
new file mode 100644
index 0000000..fd9c54e
--- /dev/null
+++ b/LoadJPGLabelInfo.h
@@ -0,0 +1,457 @@
+#pragma once
+
+#include <vector>
+#include <string>
+#include <cmath>
+#include <fstream>
+#include <iostream>
+#include <cstdlib>
+using namespace std;
+#ifdef _WIN32
+#include <hash_map>
+#define unordered_map hash_map 
+using namespace stdext;
+#else
+#include <tr1/unordered_map>
+#define hash_map unordered_map
+using namespace tr1;
+#endif
+
+
+#define MYBLKSIZE 16
+#define NUMFRAMETR 4
+class JPGLabelInfo
+{
+public:
+	int m_nWidth;
+	int m_nHeight;
+	int m_nBlockWidth;
+	int m_nBlockHeight;
+	int** m_ppnLabel;
+	int m_nSkinCount;
+	int BLOCKSIZE;
+	vector< vector<int> > m_vvOnes;
+	string m_szPathName;
+
+	JPGLabelInfo()
+	{
+		m_nWidth=0;
+		m_nHeight=0;
+		m_ppnLabel=0;
+		BLOCKSIZE = MYBLKSIZE;
+		m_nSkinCount = 0;
+	}
+	~JPGLabelInfo()
+	{
+		if(m_ppnLabel != NULL)
+		{
+			for(int n = 0; n < m_nBlockHeight; n++)
+			{
+				delete [] m_ppnLabel[n];
+			}
+			delete [] m_ppnLabel;
+		}
+		m_nWidth = 0;
+		m_nHeight = 0;
+		m_nBlockWidth = 0;
+		m_nBlockHeight = 0;
+	}
+	void SetWidthHeight(int nWidth, int nHeight)
+	{
+		m_nWidth = nWidth;
+		m_nHeight = nHeight;
+		m_nBlockWidth = (int)floor((double)nWidth/(double)BLOCKSIZE);
+		m_nBlockHeight = (int)floor((double)nHeight/(double)BLOCKSIZE);
+	
+		m_ppnLabel = new int*[m_nBlockHeight];
+		for(int n = 0; n < m_nBlockHeight; n++)
+		{
+			m_ppnLabel[n] = new int[m_nBlockWidth];
+			for(int m = 0; m < m_nBlockWidth; m++)
+			{
+				m_ppnLabel[n][m] = 0;
+			}
+		}
+	}
+	void SetWidthHeight(int nWidth, int nHeight, int BLKSIZE)
+	{
+		BLOCKSIZE = BLKSIZE;
+		m_nWidth = nWidth;
+		m_nHeight = nHeight;
+		m_nBlockWidth = (int)floor((double)nWidth/(double)BLOCKSIZE);
+		m_nBlockHeight = (int)floor((double)nHeight/(double)BLOCKSIZE);
+	
+		m_ppnLabel = new int*[m_nBlockHeight];
+		for(int n = 0; n < m_nBlockHeight; n++)
+		{
+			m_ppnLabel[n] = new int[m_nBlockWidth];
+			for(int m = 0; m < m_nBlockWidth; m++)
+			{
+				m_ppnLabel[n][m] = 0;
+			}
+		}
+	}
+	void SetAsSkinPixel(int x, int y)
+	{
+		if(m_ppnLabel && x < m_nBlockWidth && y < m_nBlockHeight)
+		{
+			m_ppnLabel[y][x] = 1;
+			m_nSkinCount++;
+		}
+	}
+	void SetAsNotSurePixel(int x, int y)
+	{
+		if(m_ppnLabel && x < m_nBlockWidth && y < m_nBlockHeight)
+		{
+			m_ppnLabel[y][x] = -1;
+		}
+	}
+	void SetAsNonSkinPixel(int x, int y)
+	{
+		if(m_ppnLabel && x < m_nBlockWidth && y < m_nBlockHeight)
+		{
+			m_ppnLabel[y][x] = 0;
+		}
+	}
+};
+
+class LoadJPGLabelInfo
+{
+public:
+	LoadJPGLabelInfo()
+	{
+		BLOCKSIZE = MYBLKSIZE;
+		m_nCountX = 0;
+		m_nCountO = 0;
+
+	}
+	unordered_map<string, int> m_hszJPGFiles;
+	unordered_map<string, int> m_hszCurrJPGFiles;
+	unordered_map<string, JPGLabelInfo> m_hJPGLavelInfo;
+	unordered_map< string, vector<int> > m_hJPGClasses;
+	vector<string> m_vszKeyOrder;
+	unordered_map<string, int> m_hHyperKeys;
+	string m_szLabelPathName;
+	unordered_map<string, unordered_map<string, int> > m_hhTrainFiles;
+	unordered_map<string, vector<int> > m_hvSizes;
+
+	int BLOCKSIZE;
+	int m_nCountX;
+	int m_nCountO;
+	void LoadJPGInfo()
+	{
+		//ifstream fin;
+		//fin.open(m_szLabelPathName.c_str());
+		//string szBuf;
+		//while(fin>>szBuf)
+		//{
+		//	size_t stdot1 = szBuf.find_first_of(',');
+		//	string szFileName = szBuf.substr(0, stdot1);
+		//	szBuf = szBuf.substr(stdot1+1, szBuf.length() - stdot1 - 1);
+		//	size_t stdot2 = szBuf.find_first_of(',');
+		//	string szWidth = szBuf.substr(0, stdot2);
+		//	int nWidth = atoi(szWidth.c_str());
+		//	szBuf = szBuf.substr(stdot2+1, szBuf.length() - stdot2 - 1);
+		//	size_t stdot3 = szBuf.find_first_of(',');
+		//	string szHeight = szBuf.substr(0, stdot3);
+		//	int nHeight = atoi(szHeight.c_str());
+		//	szBuf = szBuf.substr(stdot3+1, szBuf.length() - stdot3 - 1);
+		//	string szHyperKeyTmp = szFileName.substr(0, szFileName.find_last_of("_") + 1);
+		//	m_hHyperKeys[szHyperKeyTmp]++;
+		//	if(m_hszJPGFiles.find(szFileName) == m_hszJPGFiles.end())
+		//	{
+		//		m_vszKeyOrder.push_back(szFileName);
+		//	}
+		//	m_hszJPGFiles[szFileName] = atoi(szBuf.c_str());
+		//	m_hJPGLavelInfo[szFileName].SetWidthHeight(nWidth * BLOCKSIZE, nHeight * BLOCKSIZE);
+		//	m_hJPGLavelInfo[szFileName].m_szPathName = szFileName;
+		//	fin>>szBuf;
+		//	string szFileNameKey = szFileName.substr(szFileName.find_last_of("\\") + 1, szFileName.find_last_of("_")  - szFileName.find_last_of("\\"));
+		//	int nCountLabHand = 0;
+		//	while(0 != szBuf.compare("."))
+		//	{
+		//		size_t stdot01 = szBuf.find_first_of(',');
+		//		string szx = szBuf.substr(0, stdot01);
+		//		szBuf = szBuf.substr(stdot01+1, szBuf.length() - stdot01 - 1);
+		//		size_t stdot02 = szBuf.find_first_of(',');
+		//		string szy = szBuf.substr(0, stdot02);
+		//		szBuf = szBuf.substr(stdot02+1, szBuf.length() - stdot02 - 1);
+		//		string szv = szBuf;
+		//		if(-1 == atoi(szv.c_str()))
+		//		{
+		//			m_hJPGLavelInfo[szFileName].SetAsNotSurePixel(atoi(szx.c_str()), atoi(szy.c_str()));
+		//			m_nCountX++;
+		//		}
+		//		else if(1 == atoi(szv.c_str()))
+		//		{
+		//			m_hJPGLavelInfo[szFileName].SetAsSkinPixel(atoi(szx.c_str()), atoi(szy.c_str()));
+		//			m_nCountO++;
+		//			nCountLabHand++;
+		//		}
+		//		fin>>szBuf;
+		//	}
+		//	if(nCountLabHand > 0)
+		//	{
+		//		
+		//		if(m_hhTrainFiles.find(szFileNameKey) == m_hhTrainFiles.end())
+		//		{
+		//			m_hhTrainFiles[szFileNameKey][szFileName] = nCountLabHand;
+		//		}
+		//		else
+		//		{
+		//			if(NUMFRAMETR > m_hhTrainFiles[szFileNameKey].size())
+		//			{
+		//				m_hhTrainFiles[szFileNameKey][szFileName] = nCountLabHand;
+		//			}
+		//		}
+		//	}
+		//}
+		//fin.close();
+		ifstream fin;
+		fin.open(m_szLabelPathName.c_str());
+		string szBuf;
+		while(fin>>szBuf)
+		{
+			if(szBuf[szBuf.length()-1] == '\r')
+				szBuf = szBuf.substr(0, szBuf.length()-1);
+			size_t stdot1 = szBuf.find_first_of(',');
+			string szFileName = szBuf.substr(0, stdot1);
+			szBuf = szBuf.substr(stdot1+1, szBuf.length() - stdot1 - 1);
+			size_t stdot2 = szBuf.find_first_of(',');
+			string szWidth = szBuf.substr(0, stdot2);
+			int nWidth = atoi(szWidth.c_str());
+			szBuf = szBuf.substr(stdot2+1, szBuf.length() - stdot2 - 1);
+			size_t stdot3 = szBuf.find_first_of(',');
+			string szHeight = szBuf.substr(0, stdot3);
+			int nHeight = atoi(szHeight.c_str());
+			szBuf = szBuf.substr(stdot3+1, szBuf.length() - stdot3 - 1);
+			if(m_hszJPGFiles.find(szFileName) == m_hszJPGFiles.end())
+			{
+				m_vszKeyOrder.push_back(szFileName);
+			}
+			int nnpostmp1 =(int)szFileName.find_last_of("\\");
+			int nnpostmp11 =(int)szFileName.find_last_of("/");
+			int nnpostmp01 = (nnpostmp1 > nnpostmp11)?nnpostmp1:nnpostmp11;
+			int nnpostmp02 = (int)szFileName.find_last_of("_");
+			string szTmpKey = szFileName.substr(nnpostmp01 + 1, nnpostmp02 - nnpostmp01);
+			m_hvSizes[szTmpKey].push_back(nWidth);
+			m_hvSizes[szTmpKey].push_back(nHeight);
+			m_hszJPGFiles[szFileName] = atoi(szBuf.c_str());
+			m_hJPGLavelInfo[szFileName].SetWidthHeight(nWidth * BLOCKSIZE, nHeight * BLOCKSIZE, BLOCKSIZE);
+			m_hJPGLavelInfo[szFileName].m_szPathName = szFileName;
+			m_hJPGClasses[szFileName] = vector<int>(nWidth*nHeight, 0);
+			fin>>szBuf;
+			if(szBuf[szBuf.length()-1] == '\r')
+				szBuf = szBuf.substr(0, szBuf.length()-1);
+			//string szFileNameKey = szFileName.substr(szFileName.find_last_of("\\") + 1, szFileName.find_last_of("_")  - szFileName.find_last_of("\\"));
+			string szFileNameKey = szFileName.substr(szFileName.find_last_of("/") + 1, szFileName.find_last_of("_")  - szFileName.find_last_of("/"));
+			int nCountLabHand = 0;
+			while(0 != szBuf.compare("."))
+			{
+				size_t stdot01 = szBuf.find_first_of(',');
+				string szx = szBuf.substr(0, stdot01);
+				szBuf = szBuf.substr(stdot01+1, szBuf.length() - stdot01 - 1);
+				size_t stdot02 = szBuf.find_first_of(',');
+				string szy = szBuf.substr(0, stdot02);
+				szBuf = szBuf.substr(stdot02+1, szBuf.length() - stdot02 - 1);
+				string szv = szBuf;
+				int ncurrx = atoi(szx.c_str());
+				int ncurry = atoi(szy.c_str());
+				if(-1 == atoi(szv.c_str()))
+				{
+					m_hJPGLavelInfo[szFileName].SetAsNotSurePixel(ncurrx, ncurry);
+					m_hJPGClasses[szFileName][ncurrx * nHeight + ncurry] = -1;
+					m_nCountX++;
+				}
+				else if(1 == atoi(szv.c_str()))
+				{
+					m_hJPGLavelInfo[szFileName].SetAsSkinPixel(ncurrx, ncurry);
+					m_hJPGClasses[szFileName][ncurrx * nHeight + ncurry] = 1;
+					vector<int> v2(2,0);
+					v2[0] = ncurrx;
+					v2[1] = ncurry;
+					m_hJPGLavelInfo[szFileName].m_vvOnes.push_back(v2);
+					m_nCountO++;
+					nCountLabHand++;
+				}
+				fin>>szBuf;
+				if(szBuf[szBuf.length()-1] == '\r')
+					szBuf = szBuf.substr(0, szBuf.length()-1);
+			}
+			if(nCountLabHand > 0)
+			{
+				
+				if(m_hhTrainFiles.find(szFileNameKey) == m_hhTrainFiles.end())
+				{
+					m_hhTrainFiles[szFileNameKey][szFileName] = nCountLabHand;
+				}
+				else
+				{
+					if(NUMFRAMETR > m_hhTrainFiles[szFileNameKey].size())
+					{
+						m_hhTrainFiles[szFileNameKey][szFileName] = nCountLabHand;
+					}
+				}
+			}
+		}
+		fin.close();
+
+	}
+	void BruteForcelyFixKeys(vector<string>& vszKeys)
+	{
+		if(0 == vszKeys.size())
+		{
+			cerr<<"Empty vector, aborted!"<<endl;
+			return;
+		}
+		for(size_t n = 0; n < vszKeys.size(); n++)
+		{
+			if(m_hJPGLavelInfo.find(vszKeys[n]) == m_hJPGLavelInfo.end())
+			{
+				int nnpostmp1 =(int)vszKeys[n].find_last_of("\\");
+				int nnpostmp11 =(int)vszKeys[n].find_last_of("/");
+				int nnpostmp01 = (nnpostmp1 > nnpostmp11)?nnpostmp1:nnpostmp11;
+				int nnpostmp02 = (int)vszKeys[n].find_last_of("_");
+				string szTmpKey = vszKeys[n].substr(nnpostmp01 + 1, nnpostmp02 - nnpostmp01);
+				int nSize1 = 0;
+				int nSize2 = 0;
+				if(m_hvSizes.find(szTmpKey) == m_hvSizes.end())
+				{
+					cerr<<"Warning, the sequence was not found in original stream, size set to the same as the fist one"<<endl;
+					if(2 == m_hvSizes.begin()->second.size())
+					{
+						nSize1 = m_hvSizes.begin()->second[0];
+						nSize2 = m_hvSizes.begin()->second[1];
+					}
+					else
+					{
+						cerr<<"OMG, you don't even have the first one, lets give you a fake size"<<endl;
+						nSize1 = 16;
+						nSize2 = 12;
+					}
+				}
+				else
+				{
+					nSize1 = m_hvSizes[szTmpKey][0];
+					nSize2 = m_hvSizes[szTmpKey][1];
+				}
+				m_hJPGLavelInfo[vszKeys[n]].SetWidthHeight(nSize1 * BLOCKSIZE, nSize2 * BLOCKSIZE, BLOCKSIZE);
+				m_hJPGLavelInfo[vszKeys[n]].m_szPathName = vszKeys[n];
+				m_hJPGClasses[vszKeys[n]] = vector<int>(nSize1*nSize2, 0);
+			}
+			else
+			{
+
+			}
+			
+		}
+		m_vszKeyOrder = vszKeys;
+	}
+	void SaveJPGInfo(string szLabelPathName)
+	{
+		//string& szLabelPathName = m_szLabelPathName;
+		unordered_map<string, JPGLabelInfo>& hJPGLavelInfo = m_hJPGLavelInfo;
+		unordered_map<string, int>& hszJPGFiles = m_hszJPGFiles;
+		vector<string>& vszJPGFiles = m_vszKeyOrder;
+		ofstream fout;
+		fout.open(szLabelPathName.c_str());
+		size_t stFiles = hJPGLavelInfo.size();
+		size_t stCurrFileLists = vszJPGFiles.size();
+		vector<string> vszOthers;
+		int nIndex = 0;
+		for(int nnn = 0; nnn < (int)vszJPGFiles.size(); nnn++)
+		{
+			if(hJPGLavelInfo.find(vszJPGFiles[nnn]) != hJPGLavelInfo.end())
+			{
+				nIndex = nnn;
+			}
+		}
+		//for(unordered_map<string, JPGLabelInfo>::iterator itr = m_hJPGLavelInfo.begin();itr!=m_hJPGLavelInfo.end(); itr++)
+		for(size_t st = 0; st < (size_t)nIndex; st++)
+		{
+			//string szKey = itr->first;
+			string szKey = vszJPGFiles[st];
+			fout<<hJPGLavelInfo[szKey].m_szPathName<<","<<hJPGLavelInfo[szKey].m_nBlockWidth
+				<<","<<hJPGLavelInfo[szKey].m_nBlockHeight<<","<<hszJPGFiles[szKey]<<endl;
+			for(int mm = 0; mm < hJPGLavelInfo[szKey].m_nBlockWidth; mm++)
+			{
+				for(int nn = 0; nn < hJPGLavelInfo[szKey].m_nBlockHeight; nn++)
+				{
+					if(hJPGLavelInfo[szKey].m_ppnLabel[nn][mm] == 1)
+					{
+						fout<<mm<<","<<nn<<","<<1<<endl;
+					}
+				}
+			}
+			for(int mm = 0; mm < hJPGLavelInfo[szKey].m_nBlockWidth; mm++)
+			{
+				for(int nn = 0; nn < hJPGLavelInfo[szKey].m_nBlockHeight; nn++)
+				{
+					if(hJPGLavelInfo[szKey].m_ppnLabel[nn][mm] == -1)
+					{
+						fout<<mm<<","<<nn<<","<<-1<<endl;
+					}
+				}
+			}
+			fout<<"."<<endl;
+		}
+		fout.close();
+	}
+
+	void MarkSelectedPointWithoutDrawing(string szCurrFile, int x, int y, int val, 
+		int nWidth,
+		int nHeight)
+	{
+		unordered_map<string, JPGLabelInfo>& hJPGLavelInfo = m_hJPGLavelInfo;
+		int& nCountO = m_nCountO;
+		int& nCountX = m_nCountX;
+
+		int BLKSIZE = BLOCKSIZE;
+
+		if(hJPGLavelInfo.find(szCurrFile) == hJPGLavelInfo.end())
+		{
+			hJPGLavelInfo[szCurrFile].SetWidthHeight(nWidth*BLKSIZE, nHeight*BLKSIZE, BLKSIZE);
+			hJPGLavelInfo[szCurrFile].m_szPathName = szCurrFile;
+		}
+		if(val == 0)
+		{
+			hJPGLavelInfo[szCurrFile].SetAsNonSkinPixel(x, y);
+		}
+		else if(val == 1)
+		{
+			if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == 1)
+			{
+				hJPGLavelInfo[szCurrFile].SetAsNonSkinPixel(x, y);
+				nCountO--;
+			}
+			else
+			{
+				if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == -1)
+				{
+					nCountX--;
+				}
+				hJPGLavelInfo[szCurrFile].SetAsSkinPixel(x, y);
+				nCountO++;
+			}
+		}
+		else if(val == -1)
+		{
+			if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == -1)
+			{
+				hJPGLavelInfo[szCurrFile].SetAsNonSkinPixel(x, y);
+				nCountX--;
+			}
+			else
+			{
+				if(hJPGLavelInfo[szCurrFile].m_ppnLabel[y][x] == 1)
+				{
+					nCountO--;
+				}
+				hJPGLavelInfo[szCurrFile].SetAsNotSurePixel(x, y);
+				nCountX++;
+			}
+		}
+	}
+
+
+};
diff --git a/LocalFeatuers.h b/LocalFeatuers.h
new file mode 100644
index 0000000..4a56915
--- /dev/null
+++ b/LocalFeatuers.h
@@ -0,0 +1,853 @@
+#pragma once
+#include "GMMAdaptTool.h"
+
+#define MYNULLINDEX 0x80000000
+
+class BlockFeatures
+{
+public:
+	static void cvmat2vec(cv::Mat& mat, vector< vector<double> >& vvData)
+	{
+		int channels = mat.channels();
+		int ndepth = mat.depth();
+		vector<Mat> planes;
+		cv::split(mat, planes);
+		vvData.resize(channels, vector<double>(mat.rows * mat.cols, 0.0));
+				
+		for(int c = 0; c < channels; c++)
+		{
+			int ncount = 0;
+			for(int n = 0; n < mat.rows; n++)
+			{
+				if(ndepth == CV_8U)
+				{
+					uchar* pfirst = planes[c].ptr<uchar>(n);
+					for(int m = 0; m < mat.cols; m++)
+					{
+						vvData[c][ncount] = (double)pfirst[m];
+						ncount++;
+					}
+				}
+				else if(ndepth == CV_8S)
+				{
+					char* pfirst = planes[c].ptr<char>(n);
+					for(int m = 0; m < mat.cols; m++)
+					{
+						vvData[c][ncount] = (double)pfirst[m];
+						ncount++;
+					}
+				}
+				else if(ndepth == CV_16U)
+				{
+					ushort* pfirst = planes[c].ptr<ushort>(n);
+					for(int m = 0; m < mat.cols; m++)
+					{
+						vvData[c][ncount] = (double)pfirst[m];
+						ncount++;
+					}
+				}
+				else if(ndepth == CV_16S)
+				{
+					short* pfirst = planes[c].ptr<short>(n);
+					for(int m = 0; m < mat.cols; m++)
+					{
+						vvData[c][ncount] = (double)pfirst[m];
+						ncount++;
+					}
+				}
+				else if(ndepth == CV_32S)
+				{
+					int* pfirst = planes[c].ptr<int>(n);
+					for(int m = 0; m < mat.cols; m++)
+					{
+						vvData[c][ncount] = (double)pfirst[m];
+						ncount++;
+					}
+				}
+				else if(ndepth == CV_32F)
+				{
+					float* pfirst = planes[c].ptr<float>(n);
+					for(int m = 0; m < mat.cols; m++)
+					{
+						vvData[c][ncount] = (double)pfirst[m];
+						ncount++;
+					}
+				}
+				else if(ndepth == CV_64F)
+				{
+					double* pfirst = planes[c].ptr<double>(n);
+					for(int m = 0; m < mat.cols; m++)
+					{
+						vvData[c][ncount] = (double)pfirst[m];
+						ncount++;
+					}
+				}
+			}
+		}
+	}
+
+	static void compquantilesrangemode(vector<double>& vData, double& quad25, double& median, double& quad75, double& range, double& mode)
+	{
+		int N = (int)vData.size();
+		if(N <= 0)
+		{
+			cerr<<"Empty data, cannot compute quantiles"<<endl;
+			return;
+		}
+		vector<int> dummy(N, 0);
+		for(size_t n = 0; n < N; n++)
+		{
+			dummy[n] = n;
+		}
+		sort(dummy.begin(), dummy.end(), index_cmp_ascend< vector<double>& >(vData));
+		int q25n1 = (int)floor((double)(N + 1) * 0.25);
+		int q25n2 = (int)ceil((double)(N + 1) * 0.25);
+		int q50n1 = (int)floor((double)(N + 1) * 0.50);
+		int q50n2 = (int)ceil((double)(N + 1) * 0.50);
+		int q75n1 = (int)floor((double)(N + 1) * 0.75);
+		int q75n2 = (int)ceil((double)(N + 1) * 0.75);
+		quad25 = (vData[dummy[q25n1]] + vData[dummy[q25n2]])/2.0;
+		median = (vData[dummy[q50n1]] + vData[dummy[q50n2]])/2.0;
+		quad75 = (vData[dummy[q75n1]] + vData[dummy[q75n2]])/2.0;
+		range = vData[dummy[N-1]] - vData[dummy[0]];
+		// compute mode
+		unordered_map<int, int> hCounts;
+		for(size_t n = 0; n < N; ++n)
+		{
+			hCounts[(int)vData[n]]++;
+		}
+		int nmaxcount = 0;
+		for(unordered_map<int, int>::iterator itr = hCounts.begin(); itr != hCounts.end(); ++itr)
+		{
+			int ncountnow = itr->second;
+			if(nmaxcount < ncountnow)
+			{
+				nmaxcount = ncountnow;
+				mode = itr->first;
+			}
+		}
+	}
+
+
+	void CompQuantiles_n_Range_Mode()
+	{
+		size_t C = m_vvData.size();
+		m_vQuad25 = vector<double>(3, 0.0);
+		m_vMedian = vector<double>(3, 0.0);
+		m_vQuad75 = vector<double>(3, 0.0);
+		m_vMode = vector<double>(3, 0.0);
+		m_vRange = vector<double>(3, 0.0);
+		for(size_t c = 0; c < C; c++)
+		{
+			compquantilesrangemode(m_vvData[c], m_vQuad25[c], m_vMedian[c], m_vQuad75[c], m_vRange[c], m_vMode[c]); 
+		}
+	}
+	void extractBlockMean()
+	{
+		size_t C = m_vvData.size();
+		m_vMeans = vector<double>(C, 0.0);
+		for(size_t c = 0; c < C; ++c)
+		{
+			size_t Nc = m_vvData[c].size();
+			for(size_t n = 0; n < Nc; ++n)
+			{
+				m_vMeans[c] += m_vvData[c][n];
+			}
+			m_vMeans[c] /= (double)Nc;
+		}
+	}
+
+	void extractBlockVars()
+	{
+		size_t C = m_vvData.size();
+		m_vVars = vector<double>(C, 0.0);
+		for(size_t c = 0; c < C; ++c)
+		{
+			size_t Nc = m_vvData[c].size();
+			for(size_t n = 0; n < Nc; ++n)
+			{
+				m_vVars[c] += pow((m_vvData[c][n] - m_vMeans[c]), 2.0);
+			}
+			m_vVars[c] /= (double)((Nc > 1)?(Nc - 1):Nc);
+		}
+	}
+	
+	void compCorrelation(BlockFeatures& rhs, vector<double>& vCorr)
+	{
+		if(rhs.m_vvData.size() != m_vvData.size())
+		{
+			cerr<<"number of channel mismatched in compCorrelation"<<endl;
+			return;
+		}
+
+		for(size_t n = 0; n < m_vvData.size(); n++)
+		{
+			if(rhs.m_vvData[n].size() != m_vvData[n].size())
+			{
+				cerr<<"number of data mismatched in channel "<<n<<" in compCorrelation"<<endl;
+				return;
+			}
+		}
+
+		size_t C = m_vvData.size();
+		vCorr.reserve(C);
+		vCorr.resize(C);
+		for(size_t c = 0; c < C; ++c)
+		{
+			size_t Nc = m_vvData[c].size();
+			double dbVal = 0.0;
+			for(size_t i = 0; i < Nc; ++i)
+			{
+				dbVal += (m_vvData[c][i] - m_vMeans[c]) * (rhs.m_vvData[c][i] - rhs.m_vMeans[c]);
+			}
+			double norm = (double)((Nc > 1)?(Nc-1):Nc);
+			double trnorm = 10.0;
+			double dbVar1 = sqrt(m_vVars[c] * norm);
+			double dbVar2 = sqrt(rhs.m_vVars[c] * norm);
+			double dbVar = dbVar1 * dbVar2;
+			if(dbVar1 < trnorm && dbVar2 < trnorm) // constant to constant map
+			{
+				vCorr[c] = 1.0;
+			}
+			else
+			{
+				vCorr[c] = fabs((dbVar > 0)?(dbVal / dbVar):0.0);
+			}
+		}
+	}
+
+	void compDiffCorrelation(BlockFeatures& rhs)
+	{
+		compCorrelation(rhs, m_vDiffCorr);
+	}
+
+	void compBSCorrelation(BlockFeatures& rhs)
+	{
+		compCorrelation(rhs, m_vBSCorr);
+	}
+
+	//;
+
+	void CompDeltaQuantiles_n_Range_Mode()
+	{
+		size_t C = m_vvDeltaData.size();
+		m_vDeltaQuad25 = vector<double>(3, 0.0);
+		m_vDeltaMedian = vector<double>(3, 0.0);
+		m_vDeltaQuad75 = vector<double>(3, 0.0);
+		m_vDeltaMode = vector<double>(3, 0.0);
+		m_vDeltaRange = vector<double>(3, 0.0);
+		for(size_t c = 0; c < C; c++)
+		{
+			compquantilesrangemode(m_vvDeltaData[c], m_vDeltaQuad25[c], m_vDeltaMedian[c], m_vDeltaQuad75[c], m_vDeltaRange[c], m_vDeltaMode[c]); 
+		}
+	}
+	void extractDeltaBlockMean()
+	{
+		size_t C = m_vvDeltaData.size();
+		m_vDeltaMeans = vector<double>(C, 0.0);
+		for(size_t c = 0; c < C; ++c)
+		{
+			size_t Nc = m_vvDeltaData[c].size();
+			for(size_t n = 0; n < Nc; ++n)
+			{
+				m_vDeltaMeans[c] += m_vvDeltaData[c][n];
+			}
+			m_vDeltaMeans[c] /= (double)Nc;
+		}
+	}
+
+	void extractDeltaBlockVars()
+	{
+		size_t C = m_vvDeltaData.size();
+		m_vDeltaVars = vector<double>(C, 0.0);
+		for(size_t c = 0; c < C; ++c)
+		{
+			size_t Nc = m_vvDeltaData[c].size();
+			for(size_t n = 0; n < Nc; ++n)
+			{
+				m_vDeltaVars[c] += pow((m_vvDeltaData[c][n] - m_vDeltaMeans[c]), 2.0);
+			}
+			m_vDeltaVars[c] /= (double)((Nc > 1)?(Nc - 1):Nc);
+		}
+	}
+
+	void CompBSQuantiles_n_Range_Mode()
+	{
+		size_t C = m_vvBSData.size();
+		m_vBSQuad25 = vector<double>(3, 0.0);
+		m_vBSMedian = vector<double>(3, 0.0);
+		m_vBSQuad75 = vector<double>(3, 0.0);
+		m_vBSMode = vector<double>(3, 0.0);
+		m_vBSRange = vector<double>(3, 0.0);
+		for(size_t c = 0; c < C; c++)
+		{
+			compquantilesrangemode(m_vvBSData[c], m_vBSQuad25[c], m_vBSMedian[c], m_vBSQuad75[c], m_vBSRange[c], m_vBSMode[c]); 
+		}
+	}
+	void extractBSBlockMean()
+	{
+		size_t C = m_vvBSData.size();
+		m_vBSMeans = vector<double>(C, 0.0);
+		for(size_t c = 0; c < C; ++c)
+		{
+			size_t Nc = m_vvBSData[c].size();
+			for(size_t n = 0; n < Nc; ++n)
+			{
+				m_vBSMeans[c] += m_vvBSData[c][n];
+			}
+			m_vBSMeans[c] /= (double)Nc;
+		}
+	}
+
+	void extractBSBlockVars()
+	{
+		size_t C = m_vvBSData.size();
+		m_vBSVars = vector<double>(C, 0.0);
+		for(size_t c = 0; c < C; ++c)
+		{
+			size_t Nc = m_vvBSData[c].size();
+			for(size_t n = 0; n < Nc; ++n)
+			{
+				m_vBSVars[c] += pow((m_vvBSData[c][n] - m_vBSMeans[c]), 2.0);
+			}
+			m_vBSVars[c] /= (double)((Nc > 1)?(Nc - 1):Nc);
+		}
+	}
+
+	int m_nx;
+	int m_ny;
+	int m_nLabel; 
+	int m_nIndex; // -1/-2, forward/backword background, others are purely indices
+	vector< vector<double> > m_vvData;
+	// variables to store local features
+	vector<double> m_vMeans;
+	vector<double> m_vVars;
+	vector<double> m_vQuad25;
+	vector<double> m_vMedian;
+	vector<double> m_vQuad75;
+	vector<double> m_vMode;
+	vector<double> m_vRange;
+
+	vector< vector<double> > m_vvDeltaData;
+	// variables to store local features
+	vector<double> m_vDeltaMeans;
+	vector<double> m_vDeltaVars;
+	vector<double> m_vDeltaQuad25;
+	vector<double> m_vDeltaMedian;
+	vector<double> m_vDeltaQuad75;
+	vector<double> m_vDeltaMode;
+	vector<double> m_vDeltaRange;
+
+	vector< vector<double> > m_vvBSData;
+	// variables to store local features
+	vector<double> m_vBSMeans;
+	vector<double> m_vBSVars;
+	vector<double> m_vBSQuad25;
+	vector<double> m_vBSMedian;
+	vector<double> m_vBSQuad75;
+	vector<double> m_vBSMode;
+	vector<double> m_vBSRange;
+	
+	vector<double> m_vDiffCorr;
+	vector<double> m_vBSCorr;
+
+};
+
+class SingleFrameFeatures
+{
+public:
+	static void cvmat2vec(cv::Mat& mat, vector< vector<double> >& vvData)
+	{
+		BlockFeatures::cvmat2vec(mat, vvData);
+	}
+
+	void init(cv::Mat& mat, JPGLabelInfo* pinfo, int nIndex, int BlockSize = 16)
+	{
+		cv::Mat fmat;
+		int C = mat.channels();
+		int newtype = CV_MAKE_TYPE(CV_64F, C);
+		mat.convertTo(fmat, newtype);
+		m_nBlockSize = BlockSize;
+		m_nBlockWidth = mat.cols / m_nBlockSize;
+		m_nBlockHeight = mat.rows / m_nBlockSize;
+		int nsize = m_nBlockWidth * m_nBlockHeight;
+		if(nsize <= 0)
+		{
+			cerr<<"the image is empty, so cannot extract feature!"<<endl;
+			return;
+		}
+		m_nBlocks = nsize;
+		m_vBlocks.reserve(nsize);
+		m_vBlocks.resize(nsize);
+		int ncount = 0;
+		for(int n = 0; n < m_nBlockHeight; ++n)
+		{
+			cv::Mat fmatn = fmat.rowRange(n*m_nBlockSize, (n+1)*m_nBlockSize);
+			for(int m = 0; m < m_nBlockWidth; ++m)
+			{
+				cv::Mat fmatnm = fmatn.colRange(m*m_nBlockSize, (m+1)*m_nBlockSize);
+				m_vBlocks[ncount].m_nx = m;
+				m_vBlocks[ncount].m_ny = n;
+				m_vBlocks[ncount].m_nLabel = pinfo->m_ppnLabel[n][m];
+				m_vBlocks[ncount].m_nIndex = m_nIndex = nIndex;
+				cvmat2vec(fmatnm, m_vBlocks[ncount].m_vvData);
+				ncount++;
+			}
+		}
+	}
+	// should only be called after init
+	void ExtractSingleFrameStaticFeatures(cv::Mat& mat, int BlockSize = 16)
+	{
+		// Extract block mean and variance;
+		cv::Scalar mean1, stddev1;
+		cv::meanStdDev(mat, mean1, stddev1);
+		m_vMeans.push_back(mean1.val[0]);
+		m_vMeans.push_back(mean1.val[1]);
+		m_vMeans.push_back(mean1.val[2]);
+		m_vVars.push_back(stddev1.val[0] * stddev1.val[0]);
+		m_vVars.push_back(stddev1.val[1] * stddev1.val[1]);
+		m_vVars.push_back(stddev1.val[2] * stddev1.val[2]);
+		for(int n = 0; n < m_nBlocks; ++n)
+		{
+			// Call feature extraction function of BlockFeatures
+			m_vBlocks[n].extractBlockMean();
+			m_vBlocks[n].extractBlockVars();
+			m_vBlocks[n].CompQuantiles_n_Range_Mode();
+		}
+	}
+
+	string m_szSeqName;
+	int m_nBlockSize;
+	int m_nBlockWidth;
+	int m_nBlockHeight;
+	int m_nBlocks;
+	int m_nIndex;
+	int m_nPrevIndex;
+	int m_nNextIndex;
+
+
+	vector<double> m_vMeans;
+	vector<double> m_vVars;
+	vector< BlockFeatures > m_vBlocks;
+
+	vector<double> m_vDeltaMeans;
+	vector<double> m_vDeltaVars;
+
+	vector<double> m_vBSMeans;
+	vector<double> m_vBSVars;
+};
+
+class LocalFeatures
+{
+public:
+	LocalFeatures()
+	{
+		unsigned long nan[2]={0xffffffff, 0x7fffffff};
+		m_nan = *((double*)nan);
+		m_nCurrIndex = 0;
+	}
+	static void cvmat2vec(cv::Mat& mat, vector< vector<double> >& vvData)
+	{
+		BlockFeatures::cvmat2vec(mat, vvData);
+	}
+	void init(int N)
+	{
+		m_vFeatures.reserve(N);
+		m_vFeatures.resize(N);
+		m_nCurrIndex = 0;
+	}
+	void CompFrameDiff_and_BS_Features()
+	{
+		int nIndex = m_nCurrIndex;
+		int nPrevIndex = nIndex - 1;
+		int nBkGndIndex = 0;
+		if(nPrevIndex < 0)
+		{
+			size_t Cn = m_vFeatures[nIndex].m_vMeans.size();
+			m_vFeatures[nIndex].m_vDeltaMeans = vector<double>(Cn, m_nan);
+			m_vFeatures[nIndex].m_vDeltaVars = vector<double>(Cn, m_nan);
+			m_vFeatures[nIndex].m_vBSMeans = vector<double>(Cn, m_nan);
+			m_vFeatures[nIndex].m_vBSVars = vector<double>(Cn, m_nan);
+			for(size_t nn = 0; nn < m_vFeatures[nIndex].m_nBlocks; ++nn)
+			{
+				size_t Cnn = m_vFeatures[nIndex].m_vBlocks[nn].m_vvData.size();
+				size_t nnSize = (size_t)m_vFeatures[nIndex].m_nBlockSize * m_vFeatures[nIndex].m_nBlockSize;
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vvDeltaData = vector< vector<double> >(Cnn, vector<double>(nnSize, m_nan));
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDeltaMeans = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDeltaVars = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDeltaQuad25 = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDeltaMedian = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDeltaQuad75 = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDeltaMode = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDeltaRange = vector<double>(Cnn, m_nan);
+
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vvBSData = vector< vector<double> >(Cnn, vector<double>(nnSize, m_nan));
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSMeans = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSVars = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSQuad25 = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSMedian = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSQuad75 = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSMode = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSRange = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vDiffCorr = vector<double>(Cnn, m_nan);
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vBSCorr = vector<double>(Cnn, m_nan);
+			}
+		}
+		else
+		{
+			size_t Cn = m_vFeatures[nIndex].m_vMeans.size();
+			m_vFeatures[nIndex].m_vDeltaMeans = vector<double>(Cn, 0.0);
+			m_vFeatures[nIndex].m_vDeltaVars = vector<double>(Cn, 0.0);
+			m_vFeatures[nIndex].m_vBSMeans = vector<double>(Cn, 0.0);
+			m_vFeatures[nIndex].m_vBSVars = vector<double>(Cn, 0.0);
+			for(size_t cn0 = 0; cn0 < Cn; cn0++)
+			{
+				m_vFeatures[nIndex].m_vDeltaMeans[cn0] = m_vFeatures[nIndex].m_vMeans[cn0] - 
+															m_vFeatures[nPrevIndex].m_vMeans[cn0];
+				m_vFeatures[nIndex].m_vDeltaVars[cn0] = m_vFeatures[nIndex].m_vVars[cn0] + 
+															m_vFeatures[nPrevIndex].m_vVars[cn0];
+				m_vFeatures[nIndex].m_vBSMeans[cn0] = m_vFeatures[nIndex].m_vMeans[cn0] - 
+															m_vFeatures[nBkGndIndex].m_vMeans[cn0];
+				m_vFeatures[nIndex].m_vBSVars[cn0] = m_vFeatures[nIndex].m_vVars[cn0] + 
+															m_vFeatures[nBkGndIndex].m_vVars[cn0];
+			}
+
+			for(size_t nn = 0; nn < m_vFeatures[nIndex].m_nBlocks; ++nn)
+			{
+				size_t Cnn = m_vFeatures[nIndex].m_vBlocks[nn].m_vvData.size();
+				size_t nnSize = (size_t)m_vFeatures[nIndex].m_nBlockSize * m_vFeatures[nIndex].m_nBlockSize;
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vvDeltaData = vector< vector<double> >(Cnn, vector<double>(nnSize, 0.0));
+				m_vFeatures[nIndex].m_vBlocks[nn].m_vvBSData = vector< vector<double> >(Cnn, vector<double>(nnSize, 0.0));
+				for(size_t cnnn = 0; cnnn < Cnn; ++cnnn)
+				{
+					for(size_t nnn = 0; nnn < nnSize; ++nnn)
+					{
+						m_vFeatures[nIndex].m_vBlocks[nn].m_vvDeltaData[cnnn][nnn] = 
+							m_vFeatures[nIndex].m_vBlocks[nn].m_vvData[cnnn][nnn] - 
+							m_vFeatures[nPrevIndex].m_vBlocks[nn].m_vvData[cnnn][nnn];
+						m_vFeatures[nIndex].m_vBlocks[nn].m_vvBSData[cnnn][nnn] = 
+							m_vFeatures[nIndex].m_vBlocks[nn].m_vvData[cnnn][nnn] - 
+							m_vFeatures[nBkGndIndex].m_vBlocks[nn].m_vvData[cnnn][nnn];
+					}
+				}
+				m_vFeatures[nIndex].m_vBlocks[nn].extractDeltaBlockMean();
+				m_vFeatures[nIndex].m_vBlocks[nn].extractDeltaBlockVars();
+				m_vFeatures[nIndex].m_vBlocks[nn].CompDeltaQuantiles_n_Range_Mode();
+				m_vFeatures[nIndex].m_vBlocks[nn].extractBSBlockMean();
+				m_vFeatures[nIndex].m_vBlocks[nn].extractBSBlockVars();
+				m_vFeatures[nIndex].m_vBlocks[nn].CompBSQuantiles_n_Range_Mode();
+				m_vFeatures[nIndex].m_vBlocks[nn].compDiffCorrelation(m_vFeatures[nPrevIndex].m_vBlocks[nn]);
+				m_vFeatures[nIndex].m_vBlocks[nn].compBSCorrelation(m_vFeatures[nBkGndIndex].m_vBlocks[nn]);
+			}
+		}
+		//int nIndex = m_vFeatures[m_nCurrIndex].m_nIndex;
+		//int nPrevIndex = m_vFeatures[m_nCurrIndex].m_nPrevIndex;
+
+	}
+
+	void ExtFeaturesForFrame(int nIndex, cv::Mat& mat, JPGLabelInfo* pinfo, int nBlockSize)
+	{
+		// Check if this is the first data
+		m_vFeatures[m_nCurrIndex].init(mat, pinfo, nIndex, nBlockSize);
+		m_vFeatures[m_nCurrIndex].ExtractSingleFrameStaticFeatures(mat, nBlockSize);
+		if(nIndex == -1)
+		{
+			m_vFeatures[m_nCurrIndex].m_nPrevIndex = MYNULLINDEX;
+		}
+		else if(nIndex == -2)
+		{
+			m_vFeatures[m_nCurrIndex].m_nPrevIndex = m_vFeatures[m_nCurrIndex - 1].m_nIndex;
+			m_vFeatures[m_nCurrIndex].m_nNextIndex = MYNULLINDEX;
+		}
+		else
+		{
+			m_vFeatures[m_nCurrIndex].m_nPrevIndex = m_vFeatures[m_nCurrIndex - 1].m_nIndex;
+			m_vFeatures[m_nCurrIndex - 1].m_nNextIndex = nIndex;
+		}
+		// Compute frame diff features and bs features
+		CompFrameDiff_and_BS_Features();
+		m_nCurrIndex++;
+	}
+	friend ostream& operator<<(ostream& ostrm, const LocalFeatures& fe)
+	{
+		size_t N = fe.m_vFeatures.size();
+		ostrm<<"Sequence_Name\t"
+			<<"Index\t"
+			<<"Position_X\t"
+			<<"Position_Y\t"
+			<<"Label\t"
+			<<"Frame_B_Mean\t"
+			<<"Frame_G_Mean\t"
+			<<"Frame_R Mean\t"
+			<<"Frame_B_Variance\t"
+			<<"Frame_G_Variance\t"
+			<<"Frame_R_Variance\t"
+			<<"Frame_Diff_B_Mean\t"
+			<<"Frame_Diff_G_Mean\t"
+			<<"Frame_Diff_R Mean\t"
+			<<"Frame_Diff_B_Variance\t"
+			<<"Frame_Diff_G_Variance\t"
+			<<"Frame_Diff_R_Variance\t"
+			<<"Frame_BkGnd_Sub_B_Mean\t"
+			<<"Frame_BkGnd_Sub_G_Mean\t"
+			<<"Frame_BkGnd_Sub_R Mean\t"
+			<<"Frame_BkGnd_Sub_B_Variance\t"
+			<<"Frame_BkGnd_Sub_G_Variance\t"
+			<<"Frame_BkGnd_Sub_R_Variance\t"
+			<<"Block_B_Mean\t"
+			<<"Block_G_Mean\t"
+			<<"Block_R_Mean\t"
+			<<"Block_B_Median\t"
+			<<"Block_G_Median\t"
+			<<"Block_R_Meddian\t"
+			<<"Block_B_25_Quantile\t"
+			<<"Block_G_25_Quantile\t"
+			<<"Block_R_25_Quantile\t"
+			<<"Block_B_75_Quantile\t"
+			<<"Block_G_75_Quantile\t"
+			<<"Block_R_75_Quantile\t"
+			<<"Block_B_Mode\t"
+			<<"Block_G_Mode\t"
+			<<"Block_R_Mode\t"
+			<<"Block_B_Range\t"
+			<<"Block_G_Range\t"
+			<<"Block_R_Range\t"
+			<<"Block_B_Variance\t"
+			<<"Block_G_Variance\t"
+			<<"Block_R_Variance\t"
+			<<"Block_Diff_B_Mean\t"
+			<<"Block_Diff_G_Mean\t"
+			<<"Block_Diff_R_Mean\t"
+			<<"Block_Diff_B_Median\t"
+			<<"Block_Diff_G_Median\t"
+			<<"Block_Diff_R_Meddian\t"
+			<<"Block_Diff_B_25_Quantile\t"
+			<<"Block_Diff_G_25_Quantile\t"
+			<<"Block_Diff_R_25_Quantile\t"
+			<<"Block_Diff_B_75_Quantile\t"
+			<<"Block_Diff_G_75_Quantile\t"
+			<<"Block_Diff_R_75_Quantile\t"
+			<<"Block_Diff_B_Mode\t"
+			<<"Block_Diff_G_Mode\t"
+			<<"Block_Diff_R_Mode\t"
+			<<"Block_Diff_B_Range\t"
+			<<"Block_Diff_G_Range\t"
+			<<"Block_Diff_R_Range\t"
+			<<"Block_Diff_B_Variance\t"
+			<<"Block_Diff_G_Variance\t"
+			<<"Block_Diff_R_Variance\t"
+			<<"Block_Diff_B_Corr\t"
+			<<"Block_Diff_G_Corr\t"
+			<<"Block_Diff_R_Corr\t"
+			<<"Block_BkGnd_Sub_B_Mean\t"
+			<<"Block_BkGnd_Sub_G_Mean\t"
+			<<"Block_BkGnd_Sub_R_Mean\t"
+			<<"Block_BkGnd_Sub_B_Median\t"
+			<<"Block_BkGnd_Sub_G_Median\t"
+			<<"Block_BkGnd_Sub_R_Meddian\t"
+			<<"Block_BkGnd_Sub_B_25_Quantile\t"
+			<<"Block_BkGnd_Sub_G_25_Quantile\t"
+			<<"Block_BkGnd_Sub_R_25_Quantile\t"
+			<<"Block_BkGnd_Sub_B_75_Quantile\t"
+			<<"Block_BkGnd_Sub_G_75_Quantile\t"
+			<<"Block_BkGnd_Sub_R_75_Quantile\t"
+			<<"Block_BkGnd_Sub_B_Mode\t"
+			<<"Block_BkGnd_Sub_G_Mode\t"
+			<<"Block_BkGnd_Sub_R_Mode\t"
+			<<"Block_BkGnd_Sub_B_Range\t"
+			<<"Block_BkGnd_Sub_G_Range\t"
+			<<"Block_BkGnd_Sub_R_Range\t"
+			<<"Block_BkGnd_Sub_B_Variance\t"
+			<<"Block_BkGnd_Sub_G_Variance\t"
+			<<"Block_BkGnd_Sub_R_Variance\t"
+			<<"Block_BkGnd_Sub_B_Corr\t"
+			<<"Block_BkGnd_Sub_G_Corr\t"
+			<<"Block_BkGnd_Sub_R_Corr\n";
+		for(size_t n = 0; n < N; ++n)
+		{
+			size_t NB = fe.m_vFeatures[n].m_nBlocks;
+			for(size_t m = 0; m < NB; m++)
+			{
+				ostrm<<fe.m_vFeatures[n].m_szSeqName<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_nIndex<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_nx<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_ny<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_nLabel<<"\t"
+					<<fe.m_vFeatures[n].m_vMeans[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vMeans[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vMeans[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vVars[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vVars[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vVars[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vDeltaMeans[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vDeltaMeans[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vDeltaMeans[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vDeltaVars[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vDeltaVars[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vDeltaVars[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBSMeans[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBSMeans[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBSMeans[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBSVars[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBSVars[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBSVars[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMeans[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMeans[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMeans[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMedian[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMedian[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMedian[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vQuad25[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vQuad25[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vQuad25[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vQuad75[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vQuad75[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vQuad75[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMode[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMode[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vMode[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vRange[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vRange[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vRange[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vVars[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vVars[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vVars[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMeans[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMeans[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMeans[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMedian[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMedian[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMedian[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaQuad25[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaQuad25[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaQuad25[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaQuad75[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaQuad75[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaQuad75[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMode[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMode[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaMode[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaRange[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaRange[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaRange[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaVars[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaVars[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDeltaVars[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDiffCorr[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDiffCorr[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vDiffCorr[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMeans[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMeans[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMeans[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMedian[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMedian[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMedian[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSQuad25[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSQuad25[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSQuad25[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSQuad75[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSQuad75[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSQuad75[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMode[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMode[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSMode[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSRange[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSRange[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSRange[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSVars[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSVars[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSVars[2]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSCorr[0]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSCorr[1]<<"\t"
+					<<fe.m_vFeatures[n].m_vBlocks[m].m_vBSCorr[2]<<"\n";
+			}
+		}
+		return ostrm;
+	}
+
+	//static void DataSubtraction(vector<double> )
+	//void cvmat2vec(cv::Mat& mat, vector< vector<double> >& vvData)
+	//{
+	//	int channels = mat.channels();
+	//	int ndepth = mat.depth();
+	//	vector<Mat> planes;
+	//	cv::split(mat, planes);
+	//	vvData.resize(channels, vector<double>(mat.rows * mat.cols, 0.0));
+	//			
+	//	for(int c = 0; c < channels; c++)
+	//	{
+	//		int ncount = 0;
+	//		for(int n = 0; n < mat.rows; n++)
+	//		{
+	//			if(ndepth == CV_8U)
+	//			{
+	//				uchar* pfirst = planes[c].ptr<uchar>(n);
+	//				for(int m = 0; m < mat.cols; m++)
+	//				{
+	//					vvData[c][ncount] = (double)pfirst[m];
+	//					ncount++;
+	//				}
+	//			}
+	//			else if(ndepth == CV_8S)
+	//			{
+	//				char* pfirst = planes[c].ptr<char>(n);
+	//				for(int m = 0; m < mat.cols; m++)
+	//				{
+	//					vvData[c][ncount] = (double)pfirst[m];
+	//					ncount++;
+	//				}
+	//			}
+	//			else if(ndepth == CV_16U)
+	//			{
+	//				ushort* pfirst = planes[c].ptr<ushort>(n);
+	//				for(int m = 0; m < mat.cols; m++)
+	//				{
+	//					vvData[c][ncount] = (double)pfirst[m];
+	//					ncount++;
+	//				}
+	//			}
+	//			else if(ndepth == CV_16S)
+	//			{
+	//				short* pfirst = planes[c].ptr<short>(n);
+	//				for(int m = 0; m < mat.cols; m++)
+	//				{
+	//					vvData[c][ncount] = (double)pfirst[m];
+	//					ncount++;
+	//				}
+	//			}
+	//			else if(ndepth == CV_32S)
+	//			{
+	//				int* pfirst = planes[c].ptr<int>(n);
+	//				for(int m = 0; m < mat.cols; m++)
+	//				{
+	//					vvData[c][ncount] = (double)pfirst[m];
+	//					ncount++;
+	//				}
+	//			}
+	//			else if(ndepth == CV_32F)
+	//			{
+	//				float* pfirst = planes[c].ptr<float>(n);
+	//				for(int m = 0; m < mat.cols; m++)
+	//				{
+	//					vvData[c][ncount] = (double)pfirst[m];
+	//					ncount++;
+	//				}
+	//			}
+	//			else if(ndepth == CV_64F)
+	//			{
+	//				double* pfirst = planes[c].ptr<double>(n);
+	//				for(int m = 0; m < mat.cols; m++)
+	//				{
+	//					vvData[c][ncount] = (double)pfirst[m];
+	//					ncount++;
+	//				}
+	//			}
+	//		}
+	//	}
+	//}
+	vector< SingleFrameFeatures > m_vFeatures;
+	string m_szSeqName;
+	int m_nCurrIndex;
+	double m_nan;
+};
+
diff --git a/VideoFE.h b/VideoFE.h
new file mode 100644
index 0000000..7a7bea3
--- /dev/null
+++ b/VideoFE.h
@@ -0,0 +1,7450 @@
+#pragma once
+
+#include "LoadJPGLabelInfo.h"
+#include "GMM.h"
+#include "GMMAdaptTool.h"
+#include "LocalFeatuers.h"
+
+#ifdef _MSC_VER
+#include "Mmsystem.h"
+#pragma comment( lib, "Winmm.lib")
+#endif
+
+//#include <stdio.h>
+//#include <direct.h>
+//#include <io.h>
+//#include "matrix.h"
+//using namespace math;
+//#include <cctype>
+//#include <vector>
+//#include <list>
+//#include <fstream>
+//#include <iostream>
+//#include <hash_map>
+//
+//#include "cv.h"
+//#include "cxcore.h"
+//#include "cvaux.h"
+//#include "highgui.h"
+//#include "ml.h"
+//
+////#include "include/cv.h"
+////#include "include/cxcore.h"
+////#include "include/cvaux.h"
+////#include "include/highgui.h"
+////#include "include/ml.h"
+//
+//using namespace std;
+//using namespace stdext;
+//
+//#define MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN 15
+//#define PI 3.14159265358979323846264338327950288
+//#define MY_MAX_DOUBLE 1.7976931348623158e+308
+//
+//// From HTK
+//#define LZERO  (-1.0E10)   /* ~log(0) */
+//#define LSMALL (-0.5E10)   /* log values < LSMALL are set to LZERO */
+//#define DIAGONAL
+//#define LOGHALF -0.69314718055994530941723212145818
+//#define TWOPI 6.28318530717958647692528676655900576
+//#define LOGTWOPI 1.8378770664093454835606594728112
+//#define LOGLOGTWOPI 0.60861113726210809872881467715665
+//static double minLogExp = -log(-LZERO);
+//
+//
+//#ifndef FENode
+//struct FENode
+//{
+//	vector<IplImage*> vpImgs;
+//	string szOutFeatureFile;
+//	string szOutFeatureFile_uhalf;
+//	string szOutFeatureFile_lhalf;
+//	string szErrLog;
+//	string szMLFName;
+//	string szLabelName;
+//	string szKeyName;
+//};
+//#endif
+//
+//#ifndef DoublePoint
+//struct DoublePoint
+//{
+//	double x;
+//	double y;
+//}typedef DoublePoint;
+//#endif
+//#ifndef VideoNode
+//struct VideoNode
+//{
+//	int nStart;
+//	int nStop;
+//	string szName;
+//}typedef VideoNode;
+//#endif
+//
+//// For sorting
+//struct LessDereference {
+//	template <class T>
+//	bool operator()(const T * lhs, const T * rhs) const {
+//	return *lhs > *rhs;
+//	}
+//};
+//
+//// For HMM stuff
+//class Mixture
+//{
+//public:
+//	Mixture()
+//	{
+//		m_dbWeight = 0.0;
+//		m_dbgconst = 0.0;
+//	}
+//	double m_dbWeight;
+//	vector<double> m_vMean;
+//	vector<double> m_vDiagVar;
+//	double m_dbgconst;
+//};
+//
+//class State
+//{
+//public:
+//	State()
+//	{
+//		m_nNumMixs = 0;
+//	}
+//	int m_nNumMixs;
+//	vector<Mixture> m_Mixtures;
+//};
+//
+//class Model
+//{
+//public:
+//	Model()
+//	{
+//		m_nNumStates = 0;
+//	}
+//	string m_szName;
+//	int m_nNumStates;
+//	vector<double> m_vPis;
+//	vector< vector<double> > m_vvTransp;
+//	vector<State> m_States;
+//};
+//class GaussianNode
+//{
+//
+//public:
+//
+//	GaussianNode()
+//	{
+//		m_nPrevClosestMix = 0;
+//	}
+//	void SetDimMix(int nDim, int nMixs)
+//	{
+//		m_vdbWeight.resize(nMixs, 1.0/(double)nMixs);
+//		m_vvdbMean.resize(nMixs);
+//		m_vvdbDiagvar.resize(nMixs);
+//		for(int n = 0; n < nMixs; n++)
+//		{
+//			m_vvdbMean[n].resize(nDim, 0.0);
+//			m_vvdbDiagvar[n].resize(nDim, 0.0);
+//		}
+//	}
+//	void Mixup(int nNexMixs)
+//	{
+//		int nCurrMixSize = (int)m_vdbWeight.size();
+//		m_vdbWeight.resize(nNexMixs);
+//		m_vvdbMean.resize(nNexMixs);
+//		m_vvdbDiagvar.resize(nNexMixs);
+//		for(int n = nCurrMixSize; n < nNexMixs; n++)
+//		{
+//			m_vvdbMean[n].resize(m_vvdbMean[0].size(), 0.0);
+//			m_vvdbDiagvar[n].resize(m_vvdbMean[0].size(), 0.0);
+//		}
+//	}
+//	vector<double> m_vdbWeight;
+//	vector< vector<double> > m_vvdbMean;
+//	vector< vector<double> > m_vvdbDiagvar;
+//	int m_nPrevClosestMix;
+//};
+//
+//// Skin color GMM class
+//class GMM
+//{
+//public:
+//	GMM()
+//	{
+//		m_nVecSize = 0;
+//		m_nMixes = 0;
+//		m_szCovType = "diagonal";
+//	}
+//	GMM(int nVecSize, int nMixes = 1, string szCovType = "diagonal")
+//	{
+//		m_nVecSize = nVecSize;
+//		m_nMixes = nMixes;
+//		m_vmdMean.resize(m_nMixes);
+//		m_szCovType = szCovType;
+//		m_vMixWeights = vector<double>(nMixes, (1.0/(double)nMixes));
+//		for(int n = 0; n < m_nMixes; n++)
+//		{
+//			m_vmdMean[n].SetSize(m_nVecSize, 1);
+//			m_vmdMean[n].Null();
+//			m_vmdCovar[n].SetSize(m_nVecSize, m_nVecSize);
+//			m_vmdInvCovar[n].SetSize(m_nVecSize, m_nVecSize);
+//			m_vmdCovar[n].Null();
+//			m_vmdInvCovar[n].Null();
+//			for(int d = 0; d < m_nVecSize; d++)
+//			{
+//				m_vmdCovar[n](d,d) = 1.0;
+//				m_vmdInvCovar[n](d,d) = 1.0;
+//			}
+//		}
+//	}
+//	GMM(const GMM& rhs)
+//	{
+//		m_nVecSize = rhs.m_nVecSize;
+//		m_nMixes = rhs.m_nMixes;
+//		m_szCovType = rhs.m_szCovType;
+//		m_szFeatureType = rhs.m_szFeatureType;
+//		m_vdgconst = rhs.m_vdgconst;
+//		m_vMixWeights = rhs.m_vMixWeights;
+//		m_vmdMean = rhs.m_vmdMean;
+//		m_vmdCovar = rhs.m_vmdCovar;
+//		m_vmdInvCovar = rhs.m_vmdInvCovar;
+//		m_vlogMixWeights = rhs.m_vlogMixWeights;
+//		m_vvddiaggconst = rhs.m_vvddiaggconst;
+//
+//	}
+//	double LogAdd(double x, double y)
+//	{
+//	   double temp,diff,z;
+//	   if (x<y) {
+//		  temp = x; x = y; y = temp;
+//	   }
+//	   diff = y-x;
+//	   if (diff<minLogExp) 
+//		  return  (x<LSMALL)?LZERO:x;
+//	   else {
+//		  z = exp(diff);
+//		  return x+log(1.0+z);
+//	   }
+//	}
+//	void InitGMMMeans(int nVecSize, int nMixes = 1)
+//	{
+//		m_nVecSize = nVecSize;
+//		m_nMixes = nMixes;
+//		m_vmdMean.resize(m_nMixes);
+//		double oneovern = 1.0/(double)nMixes;
+//		double log1n = log(oneovern);
+//		m_vMixWeights = vector<double>(nMixes, oneovern);
+//		m_vlogMixWeights = vector<double>(nMixes, log1n);
+//		for(int n = 0; n < m_nMixes; n++)
+//		{
+//			m_vmdMean[n].SetSize(m_nVecSize, 1);
+//			m_vmdMean[n].Null();
+//		}
+//	}
+//	void InitGMMVars(int nVecSize, int nMixIndex, string szCovType = "diagonal")
+//	{
+//		m_nVecSize = nVecSize;
+//		m_szCovType = szCovType;
+//		if(nMixIndex >= m_vmdCovar.size())
+//		{
+//			m_vmdCovar.resize(nMixIndex + 1);
+//			m_vmdInvCovar.resize(nMixIndex + 1);
+//		}
+//		for(int n = 0; n < m_nMixes; n++)
+//		{
+//			m_vmdCovar[nMixIndex].SetSize(m_nVecSize, m_nVecSize);
+//			m_vmdInvCovar[nMixIndex].SetSize(m_nVecSize, m_nVecSize);
+//			m_vmdCovar[nMixIndex].Null();
+//			m_vmdInvCovar[nMixIndex].Null();
+//			for(int d = 0; d < m_nVecSize; d++)
+//			{
+//				m_vmdCovar[nMixIndex](d,d) = 1.0;
+//				m_vmdInvCovar[nMixIndex](d,d) = 1.0;
+//			}
+//		}
+//	}
+//	void CompGconsts()
+//	{
+//		m_vdgconst.resize(m_nMixes, 0.0);
+//		m_vvddiaggconst.resize(m_nMixes, vector<double>(m_nVecSize, 0.0));
+//		for(int n = 0; n < m_nMixes; n++)
+//		{
+//			m_vdgconst[n] = (double)m_nVecSize * log(TWOPI) + log(m_vmdCovar[n].Det());
+//			for(int d = 0; d < m_nVecSize; d++)
+//			{
+//				m_vvddiaggconst[n][d] = log(TWOPI) + log(m_vmdCovar[n](d,d));
+//			}
+//		}
+//	}
+//	// Actually, return log likelihood instead of likelihood
+//	double CompLikelihood(const vector<double>& vec)
+//	{
+//		matrix<double> mvec;
+//		size_t nsize = vec.size();
+//		mvec.SetSize(nsize, 1);
+//		for(size_t n = 0; n < nsize; n++)
+//		{
+//			mvec(n, 0) = vec[n];
+//		}
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		double dTemp = LZERO;
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x = (mvec - m_vmdMean[n]);
+//			if(m_szCovType == "diagonal")
+//			{
+//#ifndef DIAGONAL			
+//				for(size_t j = 0; j < m_nVecSize; j++)
+//				{
+//					for(size_t i = j+1; i < m_nVecSize; i++)
+//					{
+//						vdTemp[n] += x(i, 0) * x(j, 0) * m_vmdInvCovar[n](i,j);
+//					}
+//				}
+//				vdTemp[n] *= 2;
+//				for(size_t i = 0; i < m_nVecSize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+//				}
+//				vdTemp[n] += m_vdgconst[n];
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//#else
+//				vdTemp[n] += m_vdgconst[n];
+//				for(size_t i = 0; i < m_nVecSize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+//				}
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//#endif
+//			}
+//			else if(m_szCovType == "full")
+//			{
+//				vdTemp[n] += m_vdgconst[n];
+//				vdTemp[n] += (~x * m_vmdInvCovar[n] * x)(0, 0);
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//			}
+//			dTemp = LogAdd(dTemp, vdTemp[n]);
+//		}
+//		return dTemp; //exp(dTemp)
+//	}
+//	double CompLikelihood(const matrix<double>& mvec)
+//	{
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		size_t nsize = mvec.ColNo();
+//		double dTemp = LZERO;
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x = (mvec - m_vmdMean[n]);
+//			if(m_szCovType == "diagonal")
+//			{
+//#ifndef DIAGONAL			
+//				for(size_t j = 0; j < m_nVecSize; j++)
+//				{
+//					for(size_t i = j+1; i < m_nVecSize; i++)
+//					{
+//						vdTemp[n] += x(i, 0) * x(j, 0) * m_vmdInvCovar[n](i,j);
+//					}
+//				}
+//				vdTemp[n] *= 2;
+//				for(size_t i = 0; i < m_nVecSize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+//				}
+//				vdTemp[n] += m_vdgconst[n];
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//#else
+//				vdTemp[n] += m_vdgconst[n];
+//				for(size_t i = 0; i < m_nVecSize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+//				}
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//#endif
+//			}
+//			else if(m_szCovType == "full")
+//			{
+//				vdTemp[n] += m_vdgconst[n];
+//				vdTemp[n] += (~x * m_vmdInvCovar[n] * x)(0, 0);
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//			}
+//			dTemp = LogAdd(dTemp, vdTemp[n]);
+//		}
+//		return dTemp; //exp(dTemp)
+//	}
+//	// the posterior probability ( not log )
+//	void CompPosteriori(const vector<double>& vec, vector<double>& vPost)
+//	{
+//		matrix<double> mvec;
+//		size_t nsize = vec.size();
+//		mvec.SetSize(nsize, 1);
+//		for(size_t n = 0; n < nsize; n++)
+//		{
+//			mvec(n, 0) = vec[n];
+//		}
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		double dTemp = LZERO;
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x = (mvec - m_vmdMean[n]);
+//			if(m_szCovType == "diagonal")
+//			{
+//#ifndef DIAGONAL			
+//				for(size_t j = 0; j < m_nVecSize; j++)
+//				{
+//					for(size_t i = j+1; i < m_nVecSize; i++)
+//					{
+//						vdTemp[n] += x(i, 0) * x(j, 0) * m_vmdInvCovar[n](i,j);
+//					}
+//				}
+//				vdTemp[n] *= 2;
+//				for(size_t i = 0; i < m_nVecSize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+//				}
+//				vdTemp[n] += m_vdgconst[n];
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//#else
+//				vdTemp[n] += m_vdgconst[n];
+//				for(size_t i = 0; i < m_nVecSize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](i,i);
+//				}
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//#endif
+//			}
+//			else if(m_szCovType == "full")
+//			{
+//				vdTemp[n] += m_vdgconst[n];
+//				vdTemp[n] += (~x * m_vmdInvCovar[n] * x)(0, 0);
+//				vdTemp[n] *= -0.5;
+//				vdTemp[n] += m_vlogMixWeights[n];
+//			}
+//			dTemp = LogAdd(dTemp, vdTemp[n]);
+//		}
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			vdTemp[n] -= dTemp;
+//			vdTemp[n] = exp(vdTemp[n]);
+//		}
+//		vPost = vdTemp;
+//	}
+//	// Get mean vector for subspace, the space chosen is indicated by vDimConsidered
+//	void GetPartialMeans(vector< matrix<double> >& PartialMeans, vector<int>& vDimConsidered)
+//	{
+//		PartialMeans.resize(m_nMixes);
+//		for(size_t k = 0; k < m_vmdMean.size(); k++)
+//		{
+//			PartialMeans[k].SetSize(vDimConsidered.size(), 1);
+//			for(size_t n = 0; n < vDimConsidered.size(); n++)
+//			{
+//				PartialMeans[k](n, 0) = m_vmdMean[k](vDimConsidered[n], 0);
+//			}
+//		}
+//	}
+//	// Get covariance matrix for subspace, the space chosen is indicated by vDimConsidered
+//	void GetPartialVars(vector< matrix<double> >& PartialVars, vector< matrix<double> >& PartialInvVars, vector<double>& vPartialGconst, vector<int>& vDimConsidered)
+//	{
+//		PartialVars.resize(m_nMixes);
+//		PartialInvVars.resize(m_nMixes);
+//		for(size_t k = 0; k < m_vmdMean.size(); k++)
+//		{
+//			PartialVars[k].SetSize(vDimConsidered.size(), vDimConsidered.size());
+//			PartialInvVars[k].SetSize(vDimConsidered.size(), vDimConsidered.size());
+//			for(size_t n = 0; n < vDimConsidered.size(); n++)
+//			{
+//				for(size_t m = 0; m < vDimConsidered.size(); m++)
+//				{
+//					PartialVars[k](n, m) = m_vmdCovar[k](vDimConsidered[n], vDimConsidered[m]);
+//					PartialInvVars[k](n, m) = m_vmdInvCovar[k](vDimConsidered[n], vDimConsidered[m]);
+//				}
+//			}
+//		}
+//		vPartialGconst.resize(m_nMixes, 0.0);
+//		for(int n = 0; n < m_nMixes; n++)
+//		{
+//			vPartialGconst[n] = (double)vDimConsidered.size() * log(TWOPI)+log(PartialVars[n].Det());
+//		}
+//	}	
+//    // obsolete function, don't use it
+//	void CompPosterioriPartOld(const vector<double>& vec, vector<double>& vPost, vector<int>& vDimConsidered)
+//	{
+//		matrix<double> mvec;
+//		vector< matrix<double> > PartialMeans;
+//		vector< matrix<double> > PartialVars;
+//		vector< matrix<double> > PartialInvVars;
+//		vector<double> vPartialGconst;
+//
+//		size_t nsize = vDimConsidered.size();
+//		mvec.SetSize(nsize, 1);
+//		for(size_t n = 0; n < nsize; n++)
+//		{
+//			mvec(n, 0) = vec[vDimConsidered[n]];
+//		}
+//		
+//		
+//		GetPartialMeans(PartialMeans, vDimConsidered);
+//		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+//		
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		double dTemp = 0.0;
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x = (mvec - PartialMeans[n]);
+//			matrix<double> xt = ~x;
+//			matrix<double> mval = 0.5 * xt * PartialInvVars[n] * x;
+//			vdTemp[n] = -0.5 * vPartialGconst[n] - mval(0,0);
+//			vdTemp[n] = m_vMixWeights[n] * exp(vdTemp[n]);
+//			dTemp += vdTemp[n];
+//		}
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			vdTemp[n] /= dTemp;
+//		}
+//		vPost = vdTemp;
+//	}
+//
+//	// Compute posterior probability from subspace
+//	void CompPosterioriPart(const vector<double>& vec, vector<double>& vPost, vector<int>& vDimConsidered)
+//	{
+//		matrix<double> mvec;
+//		vector< matrix<double> > PartialMeans;
+//		vector< matrix<double> > PartialVars;
+//		vector< matrix<double> > PartialInvVars;
+//		vector<double> vPartialGconst;
+//
+//		size_t nsize = vDimConsidered.size();
+//
+//		//mvec.SetSize(nsize, 1);
+//		//for(size_t n = 0; n < nsize; n++)
+//		//{
+//		//	mvec(n, 0) = vec[vDimConsidered[n]];
+//		//}
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		double dTemp = LZERO;
+//#ifndef DIAGONAL		
+//		//mvec.SetSize(nsize, 1);
+//		//for(size_t n = 0; n < nsize; n++)
+//		//{
+//		//	mvec(n, 0) = mvec0(vDimConsidered[n], 0);
+//		//}
+//		//dw2 = timeGetTime();
+//		//cout<<"CompLikelihoodPart: Prepare vector takes "<<dw2-dw1<<" ms"<<endl;
+//		//dw1 = timeGetTime();
+//		//GetPartialMeans(PartialMeans, vDimConsidered);
+//		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+//#endif
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x(nsize, 1);
+//			for(size_t d = 0; d < nsize; d++)
+//				x(d,0) = (vec[vDimConsidered[d]] - m_vmdMean[n](vDimConsidered[d], 0));
+//#ifndef DIAGONAL			
+//			for(size_t j = 0; j < nsize; j++)
+//			{
+//				for(size_t i = j+1; i < nsize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(j, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[j]);
+//				}
+//			}
+//			vdTemp[n] *= 2;
+//			for(size_t i = 0; i < nsize; i++)
+//			{
+//				vdTemp[n] += x(i, 0) * x(i, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[i]);
+//			}
+//			vdTemp[n] += vPartialGconst[n];
+//			vdTemp[n] *= -0.5;
+//			vdTemp[n] += m_vlogMixWeights[n];
+//#else
+//			for(size_t d = 0; d < nsize; d++)
+//				vdTemp[n] += m_vvddiaggconst[n][vDimConsidered[d]];
+//			for(size_t i = 0; i < nsize; i++)
+//			{
+//				vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](vDimConsidered[i],vDimConsidered[i]);
+//			}
+//			vdTemp[n] *= -0.5;
+//			vdTemp[n] += m_vlogMixWeights[n];
+//#endif
+//			dTemp = LogAdd(dTemp, vdTemp[n]);
+//		}
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			vdTemp[n] -= dTemp;
+//			vdTemp[n] = exp(vdTemp[n]);
+//		}
+//		vPost = vdTemp;
+//	}
+//	// Obsolete function, don't use it
+//	double CompLikelihoodPartOld(const vector<double>& vec, vector<int>& vDimConsidered)
+//	{
+//		DWORD dw1 = 0, dw2 = 0;
+//		//dw1 = timeGetTime();
+//		matrix<double> mvec;
+//		vector< matrix<double> > PartialMeans;
+//		vector< matrix<double> > PartialVars;
+//		vector< matrix<double> > PartialInvVars;
+//		vector<double> vPartialGconst;
+//		
+//		size_t nsize = vDimConsidered.size();
+//		mvec.SetSize(nsize, 1);
+//		for(size_t n = 0; n < nsize; n++)
+//		{
+//			mvec(n, 0) = vec[vDimConsidered[n]];
+//		}
+//		
+//		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+//		GetPartialMeans(PartialMeans, vDimConsidered);
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		double dTemp = 0;
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x = mvec - PartialMeans[n];
+//			matrix<double> xt = ~x;
+//			matrix<double> mval = 0.5 * xt * PartialInvVars[n] * x;
+//			vdTemp[n] = -0.5 * vPartialGconst[n] - mval(0,0);
+//			vdTemp[n] = m_vMixWeights[n] * exp(vdTemp[n]);
+//			dTemp += vdTemp[n];
+//		}
+//		return log(dTemp); //exp(dTemp);
+//	}
+//	// Compuete log likelihood from subspace
+//	double CompLikelihoodPart(const vector<double>& vec, vector<int>& vDimConsidered)
+//	{
+//		DWORD dw1 = 0, dw2 = 0;
+//		//dw1 = timeGetTime();
+//		matrix<double> mvec;
+//		vector< matrix<double> > PartialMeans;
+//		vector< matrix<double> > PartialVars;
+//		vector< matrix<double> > PartialInvVars;
+//		vector<double> vPartialGconst;
+//		
+//		size_t nsize = vDimConsidered.size();
+//#ifndef DIAGONAL		
+//		//mvec.SetSize(nsize, 1);
+//		//for(size_t n = 0; n < nsize; n++)
+//		//{
+//		//	mvec(n, 0) = vec[vDimConsidered[n]];
+//		//}
+//		//dw2 = timeGetTime();
+//		//cout<<"CompLikelihoodPart: Prepare vector takes "<<dw2-dw1<<" ms"<<endl;
+//		//dw1 = timeGetTime();
+//		//GetPartialMeans(PartialMeans, vDimConsidered);
+//		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+//#endif		
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		double dTemp = LZERO;
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x(nsize, 1);
+//			for(size_t d = 0; d < nsize; d++)
+//				x(d,0) = (vec[vDimConsidered[d]] - m_vmdMean[n](vDimConsidered[d], 0));
+//#ifndef DIAGONAL			
+//			for(size_t j = 0; j < nsize; j++)
+//			{
+//				for(size_t i = j+1; i < nsize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(j, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[j]);
+//				}
+//			}
+//			vdTemp[n] *= 2;
+//			for(size_t i = 0; i < nsize; i++)
+//			{
+//				vdTemp[n] += x(i, 0) * x(i, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[i]);
+//			}
+//			vdTemp[n] += vPartialGconst[n];
+//			vdTemp[n] *= -0.5;
+//			vdTemp[n] += m_vlogMixWeights[n];
+//#else
+//			for(size_t d = 0; d < nsize; d++)
+//				vdTemp[n] += m_vvddiaggconst[n][vDimConsidered[d]];
+//			for(size_t i = 0; i < nsize; i++)
+//			{
+//				vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](vDimConsidered[i],vDimConsidered[i]);
+//			}
+//			vdTemp[n] *= -0.5;
+//			vdTemp[n] += m_vlogMixWeights[n];
+//#endif
+//			dTemp = LogAdd(dTemp, vdTemp[n]);
+//		}
+//		return dTemp; //exp(dTemp);
+//	}
+//	// Compute log likelihood from subspace
+//	double CompLikelihoodPart(const matrix<double>& mvec0, vector<int>& vDimConsidered)
+//	{
+//		matrix<double> mvec;
+//		vector< matrix<double> > PartialMeans;
+//		vector< matrix<double> > PartialVars;
+//		vector< matrix<double> > PartialInvVars;
+//		vector<double> vPartialGconst;
+//
+//		size_t nsize = vDimConsidered.size();
+//		
+//#ifndef DIAGONAL		
+//		//mvec.SetSize(nsize, 1);
+//		//for(size_t n = 0; n < nsize; n++)
+//		//{
+//		//	mvec(n, 0) = mvec0(vDimConsidered[n], 0);
+//		//}
+//		//dw2 = timeGetTime();
+//		//cout<<"CompLikelihoodPart: Prepare vector takes "<<dw2-dw1<<" ms"<<endl;
+//		//dw1 = timeGetTime();
+//		//GetPartialMeans(PartialMeans, vDimConsidered);
+//		GetPartialVars(PartialVars, PartialInvVars, vPartialGconst, vDimConsidered);
+//#endif
+//		vector<double> vdTemp(m_nMixes, 0.0);
+//		double dTemp = LZERO;
+//		for(size_t n = 0; n < m_nMixes; n++)
+//		{
+//			matrix<double> x(nsize, 1);
+//			for(size_t d = 0; d < nsize; d++)
+//				x(d,0) = (mvec0(vDimConsidered[d], 0) - m_vmdMean[n](vDimConsidered[d], 0));
+//#ifndef DIAGONAL			
+//			for(size_t j = 0; j < nsize; j++)
+//			{
+//				for(size_t i = j+1; i < nsize; i++)
+//				{
+//					vdTemp[n] += x(i, 0) * x(j, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[j]);
+//				}
+//			}
+//			vdTemp[n] *= 2;
+//			for(size_t i = 0; i < nsize; i++)
+//			{
+//				vdTemp[n] += x(i, 0) * x(i, 0) * PartialInvVars(vDimConsidered[i],vDimConsidered[i]);
+//			}
+//			vdTemp[n] += vPartialGconst[n];
+//			vdTemp[n] *= -0.5;
+//			vdTemp[n] += m_vlogMixWeights[n];
+//#else
+//			for(size_t d = 0; d < nsize; d++)
+//				vdTemp[n] += m_vvddiaggconst[n][vDimConsidered[d]];
+//			for(size_t i = 0; i < nsize; i++)
+//			{
+//				vdTemp[n] += x(i, 0) * x(i, 0) * m_vmdInvCovar[n](vDimConsidered[i],vDimConsidered[i]);
+//			}
+//			vdTemp[n] *= -0.5;
+//			vdTemp[n] += m_vlogMixWeights[n];
+//#endif
+//			dTemp = LogAdd(dTemp, vdTemp[n]);
+//		}
+//		return dTemp;
+//	}
+//	int m_nVecSize;
+//	int m_nMixes;
+//	string m_szCovType;
+//	string m_szFeatureType;
+//	vector<double> m_vMixWeights;
+//	vector< matrix<double> > m_vmdMean;
+//	vector< matrix<double> > m_vmdCovar;
+//	vector< matrix<double> > m_vmdInvCovar;
+//	vector<double> m_vdgconst;
+//	vector<double> m_vlogMixWeights;
+//	vector< vector<double> > m_vvddiaggconst;
+//};
+//
+
+class CVideoFE
+{
+public:
+	// CVideoFE(void);
+	// ~CVideoFE(void);
+	// HRESULT GMMAdaptTool::AccBackground(const CvArr* src, CvArr*& dst);
+	// void AggMerge(vector<CvRect>& vRect, vector<CvRect>& vAggRect, int& nROI);
+	// HRESULT AvgBackground(const CvArr* src, CvArr*& dst, unsigned int nnum);
+	// void AutoLabelRGBOnly(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio);
+	// void AutoLabelPart(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio);
+	// void AutoLabelPartSM(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio);
+	// void CalcDist(vector<CvRect>& vRect, list< list<double> >& llRectDist, double& dMin, int& argminx, int& argminy);
+	// bool CheckRectInt9r2(CvRect r1, CvRect r2);
+	// HRESULT CloseImage(const CvArr* src, CvArr*& dst);
+	// double CompRectDistNN(CvRect r1, CvRect r2);
+	// double ComputeCvVectorCosine(const CvPoint& vec1, const CvPoint& vec2);
+	// HRESULT GetKCurvaturePoint(CvPoint* pArr, int nSize, unsigned int i, int k, CvPoint& Pik, int MaxX, int MaxY);
+	// HRESULT EstCOMandFingerLoc1(IplImage*& src, vector<double>& vec);
+	// HRESULT EstCOMandFingerLoc2(IplImage*& src, vector<double>& vec, const vector<double>& lastvec);
+	// int GMMBiasAdapt(vector< vector<double> >& vvData, matrix<double>& newmub, vector<GMM>& oldGMMs, vector<GMM>& newGMMs);
+	// int GMMAdaptRcogAFrame(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vrecogclasses);
+	// int LoadGMM(string szGMM, hash_map<string, GMM>& hGMMs);
+	// HRESULT Makein01(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData);
+	// HRESULT GetvvRangeAtnD(const vector< vector<double> >& vvData, unsigned int n, double& dbMin, double& dbMax);
+	// int Test2ClassesGMMs(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses);
+	// int Test2ClassesGMMsFull(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses);
+	// bool UpdateDistRect(vector<CvRect>& vRect, list< list<double> >& llRectDist, double& dMin, int& argminx, int& argminy);
+	// HRESULT GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vector<IplImage*> vpImgs, int& nDetStopBkGnd, int& nStop);
+	// HRESULT OfflineFEImgSeq2_2_3_part(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs);
+	// HRESULT OfflineFEImgSeq2_2_3_part_cheat(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs, LoadJPGLabelInfo& lab);
+	// HRESULT WriteFeatureAsHTKMFCC(const vector< vector<double> >& vvData, string szOutFileName);
+	// HRESULT WriteFeatureAsHTKMFCCAndItsHalves(const vector< vector<double> >& vvData, string szOutFileName, string szOutFileName_uhalf, string szOutFileName_lhalf);
+	// int MkdirHier(string sztmp);
+	// vector<int> vDimConsidered;
+	// int m_nHandModelIndex;
+	// int m_nBkGndModelIndex;
+	// int m_nK;
+	// double m_duth;
+	// //==================================================================================================================================================================================================//
+	// // New functions
+	// void MakeDebugOutputName(string szPathName0, string szSubFolder, string szKeyName, string szExt, string& szOutFileName);
+	// void SavecvImageForDebug(string szPathName0, string szSubFolder, string szKeyName, int n, int nLength, string szExt, IplImage* pImg);
+	// // Calculate the mean vector of a vector< vector<double> > data matrix by trating each vector<double> as a data point
+	// HRESULT CalcvvMean(const vector< vector<double> >& vvData, vector<double>& vMean);
+	// // Get the minimum and maximum value of matrix stored in vector< vector<double> > form at n-th dimension
+	// //HRESULT GetvvRangeAtnD(const vector< vector<double> >& vvData, unsigned int n, double& dbMin, double& dbMax);
+	// // Make vector< vector<double> > data zero mean and range from [0, 1]
+	// HRESULT MakeZeroMeanAndUnitRange(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData);
+	// HRESULT WriteFeatureAsDEBUGTRAJ(const vector< vector<double> >& vvData, string szOutFileName1, string szOutFileName2);
+	// CVideoFE(void);
+	// ~CVideoFE(void);
+	// HRESULT GMMAdaptTool::AccBackground(const CvArr* src, CvArr*& dst);
+	// void AggMerge(vector<CvRect>& vRect, vector<CvRect>& vAggRect, int& nROI);
+	// HRESULT AvgBackground(const CvArr* src, CvArr*& dst, unsigned int nnum);
+	// void AutoLabelRGBOnly(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio);
+	// void AutoLabelPart(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio);
+	// void AutoLabelPartSM(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio);
+	// void CalcDist(vector<CvRect>& vRect, list< list<double> >& llRectDist, double& dMin, int& argminx, int& argminy);
+	// bool CheckRectInt9r2(CvRect r1, CvRect r2);
+	// HRESULT CloseImage(const CvArr* src, CvArr*& dst);
+	// double CompRectDistNN(CvRect r1, CvRect r2);
+	// double ComputeCvVectorCosine(const CvPoint& vec1, const CvPoint& vec2);
+	// HRESULT GetKCurvaturePoint(CvPoint* pArr, int nSize, unsigned int i, int k, CvPoint& Pik, int MaxX, int MaxY);
+	// HRESULT EstCOMandFingerLoc1(IplImage*& src, vector<double>& vec);
+	// HRESULT EstCOMandFingerLoc2(IplImage*& src, vector<double>& vec, const vector<double>& lastvec);
+	// int GMMBiasAdapt(vector< vector<double> >& vvData, matrix<double>& newmub, vector<GMM>& oldGMMs, vector<GMM>& newGMMs);
+	// int GMMAdaptRcogAFrame(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vrecogclasses);
+	// int LoadGMM(string szGMM, hash_map<string, GMM>& hGMMs);
+	// HRESULT Makein01(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData);
+	// HRESULT GetvvRangeAtnD(const vector< vector<double> >& vvData, unsigned int n, double& dbMin, double& dbMax);
+	// int Test2ClassesGMMs(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses);
+	// int Test2ClassesGMMsFull(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses);
+	// bool UpdateDistRect(vector<CvRect>& vRect, list< list<double> >& llRectDist, double& dMin, int& argminx, int& argminy);
+	// HRESULT GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vector<IplImage*> vpImgs, int& nDetStopBkGnd, int& nStop);
+	// HRESULT OfflineFEImgSeq2_2_3_part(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs);
+	// HRESULT OfflineFEImgSeq2_2_3_part_cheat(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs, LoadJPGLabelInfo& lab);
+	// HRESULT WriteFeatureAsHTKMFCC(const vector< vector<double> >& vvData, string szOutFileName);
+	// HRESULT WriteFeatureAsHTKMFCCAndItsHalves(const vector< vector<double> >& vvData, string szOutFileName, string szOutFileName_uhalf, string szOutFileName_lhalf);
+	// int MkdirHier(string sztmp);
+	// //==================================================================================================================================================================================================//
+	// // New functions
+	// void MakeDebugOutputName(string szPathName0, string szSubFolder, string szKeyName, string szExt, string& szOutFileName);
+	// void SavecvImageForDebug(string szPathName0, string szSubFolder, string szKeyName, int n, int nLength, string szExt, IplImage* pImg);
+	// // Calculate the mean vector of a vector< vector<double> > data matrix by trating each vector<double> as a data point
+	// HRESULT CalcvvMean(const vector< vector<double> >& vvData, vector<double>& vMean);
+	// // Get the minimum and maximum value of matrix stored in vector< vector<double> > form at n-th dimension
+	// //HRESULT GetvvRangeAtnD(const vector< vector<double> >& vvData, unsigned int n, double& dbMin, double& dbMax);
+	// // Make vector< vector<double> > data zero mean and range from [0, 1]
+	// HRESULT MakeZeroMeanAndUnitRange(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData);
+	// HRESULT WriteFeatureAsDEBUGTRAJ(const vector< vector<double> >& vvData, string szOutFileName1, string szOutFileName2);
+
+	// int LoadGMM(string szGMM, hash_map<string, GMM>& hGMMs)
+	// {
+		// ifstream fin;
+		// fin.open(szGMM.c_str());
+		// string szBuf;
+		// if(fin.is_open())
+		// {
+			// int nVecSize = 0;
+			// while(getline(fin, szBuf))
+			// {
+				// string strName = "";
+				// string szFeatureType = "";
+				// int nfindtilt = -1;
+				// int nMixes = 0;
+
+				// if(szBuf.npos != (nfindtilt = szBuf.find("~o")))
+				// {
+					
+					// while(1)
+					// {
+						// getline(fin, szBuf);
+						// int nfoundpos = -1;
+						// if(szBuf.npos != (nfoundpos = szBuf.find("<VECSIZE>")))
+						// {
+							// int npos01 = szBuf.find_last_of("<");
+							// int npos02 = szBuf.find_last_of(">");
+							// string szVecSize = szBuf.substr(nfoundpos + 9, npos01 - nfoundpos - 9);
+							// nVecSize = atoi(szVecSize.c_str());
+							// szFeatureType = szBuf.substr(npos01 + 1, npos02 - npos01 - 1);
+							// break;
+						// }
+					// }
+				// }
+				// else if(szBuf.npos != (nfindtilt = szBuf.find("~h")))
+				// {
+					// strName = szBuf.substr(nfindtilt+2, szBuf.length() - nfindtilt - 2);
+					// int npos1 = strName.find_first_of('\"');
+					// int npos2 = strName.find_last_of('\"');
+					// strName = strName.substr(npos1+1, npos2-npos1-1);
+					// getline(fin, szBuf);
+					// while(1)
+					// {
+						// int nfoundpos = -1;
+						// if(szBuf.npos != szBuf.find('<') && szBuf.npos != szBuf.find('>'))
+						// {
+							// std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+							// if(szBuf.npos != szBuf.find("<BEGINHMM>"))
+							// {
+							// }
+							// else if(szBuf.npos != (nfoundpos = szBuf.find("<VECSIZE>")))
+							// {
+								// int npos01 = szBuf.find_last_of("<");
+								// int npos02 = szBuf.find_last_of(">");
+								// string szVecSize = szBuf.substr(nfoundpos + 9, npos01 - nfoundpos - 9);
+								// nVecSize = atoi(szVecSize.c_str());
+								// szFeatureType = szBuf.substr(npos01 + 1, npos02 - npos01 - 1);
+							// }
+							// else if(szBuf.npos != (nfoundpos = szBuf.find("<NUMMIXES>")))
+							// {
+								// int npos01 = szBuf.length() - 1;
+								// string szMixes = szBuf.substr(nfoundpos + 10, npos01 - nfoundpos - 9);
+								// nMixes = atoi(szMixes.c_str());
+								// hGMMs[strName].InitGMMMeans(nVecSize, nMixes);
+								// int nMixIndex = 0;
+								// int nDims = 0;
+								// double dMixWeight;
+								// for(int kk = 0; kk < nMixes; kk++)
+								// {
+									// fin>>szBuf>>nMixIndex>>dMixWeight;
+									// nMixIndex--;
+									// fin>>szBuf>>nDims;
+									// hGMMs[strName].m_vMixWeights[nMixIndex] = dMixWeight;
+									// hGMMs[strName].m_vlogMixWeights[nMixIndex] = log(dMixWeight);
+									// std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+									// if(szBuf.npos != szBuf.find("<MEAN>"))
+									// {
+										// //hGMMs[strName].InitGMMMeans(nVecSize, nMixes);
+										// for(int d = 0; d < nDims; d++)
+										// {
+											// double db1 = 0.0;
+											// fin>>db1;
+											// hGMMs[strName].m_vmdMean[nMixIndex](d, 0) = db1;
+										// }
+										// fin>>szBuf>>nDims;
+										// std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+										// if(szBuf.npos != szBuf.find("<VARIANCE>"))
+										// {
+											// hGMMs[strName].InitGMMVars(nVecSize, nMixIndex);
+											// for(int d = 0; d < nDims; d++)
+											// {
+												// fin>>hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+												// hGMMs[strName].m_vmdInvCovar[nMixIndex](d,d) = 1.0 / hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+											// }
+										// }
+										// else if(szBuf.npos != szBuf.find("<INVCOVAR>"))
+										// {
+											// hGMMs[strName].InitGMMVars(nVecSize, nMixIndex, "full");
+// #ifdef DIAGONAL
+// #undef DIAGONAL
+// #endif
+											// for(int d = 0; d < nDims; d++)
+											// {
+												// for(int dd = d; dd < nDims; dd++)
+												// {
+													// fin>>hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+													// hGMMs[strName].m_vmdInvCovar[nMixIndex](dd, d) = hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+												// }
+											// }
+											// hGMMs[strName].m_vmdCovar[nMixIndex] = !hGMMs[strName].m_vmdInvCovar[nMixIndex];
+										// }
+										// double dbgconst = 0.0;
+										// fin>>szBuf>>dbgconst;
+									// }
+									// else if(szBuf.npos != szBuf.find("<VARIANCE>"))
+									// {
+										// hGMMs[strName].InitGMMVars(nVecSize, nMixIndex);
+										// for(int d = 0; d < nDims; d++)
+										// {
+											// fin>>hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+											// hGMMs[strName].m_vmdInvCovar[nMixIndex](d,d) = 1.0 / hGMMs[strName].m_vmdCovar[nMixIndex](d,d);
+										// }
+										// fin>>szBuf>>nDims;
+										// std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+										// if(szBuf.npos != szBuf.find("<MEAN>"))
+										// {
+											// for(int d = 0; d < nDims; d++)
+											// {
+												// fin>>hGMMs[strName].m_vmdMean[nMixIndex](d, 0);
+											// }
+										// }
+										// double dbgconst = 0.0;
+										// fin>>szBuf>>dbgconst;
+									// }
+									// else if(szBuf.npos != szBuf.find("<INVCOVAR>"))
+									// {
+										// hGMMs[strName].InitGMMVars(nVecSize, nMixIndex, "full");
+										// for(int d = 0; d < nDims; d++)
+										// {
+											// for(int dd = d; dd < nDims; dd++)
+											// {
+												// fin>>hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+												// hGMMs[strName].m_vmdInvCovar[nMixIndex](dd, d) = hGMMs[strName].m_vmdInvCovar[nMixIndex](d,dd);
+											// }
+										// }									
+										// hGMMs[strName].m_vmdCovar[nMixIndex] = !hGMMs[strName].m_vmdInvCovar[nMixIndex];
+
+										// fin>>szBuf>>nDims;
+										// std::transform(szBuf.begin(), szBuf.end(), szBuf.begin(), (int(*)(int)) std::toupper);
+										// if(szBuf.npos != szBuf.find("<MEAN>"))
+										// {
+											// for(int d = 0; d < nDims; d++)
+											// {
+												// fin>>hGMMs[strName].m_vmdMean[nMixIndex](d, 0);
+											// }
+										// }
+										// double dbgconst = 0.0;
+										// fin>>szBuf>>dbgconst;
+									// }
+
+								// }
+							// }
+						// }
+						// getline(fin, szBuf);
+						// if(szBuf.npos != szBuf.find("<ENDHMM>"))
+						// {
+							// break;
+						// }
+					// }
+				// }
+			// }
+		// }
+		// fin.close();
+		// hash_map<string, GMM>::iterator itr;
+		// for(itr = hGMMs.begin(); itr != hGMMs.end(); itr++)
+		// {
+			// string szKey = itr->first;
+			// hGMMs[szKey].CompGconsts();
+		// }
+		// return 1;
+
+	// }
+	
+	CVideoFE(void)
+	{
+		vDimConsidered.resize(7);
+		for(int n = 0; n < 7; n++)
+			vDimConsidered[n] = n+1;
+		m_nHandModelIndex = 0;
+		m_nBkGndModelIndex = 0;
+		m_nK = 20;
+		m_duth = 0.75;
+		m_szGMMPath = "";
+	}
+
+	~CVideoFE(void)
+	{
+	}
+
+	// maximum likelihood decision for 2 classes
+	int Test2ClassesGMMs(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses)
+	{
+		return (HRESULT) GMMAdaptTool::Test2ClassesGMMsPart(vvData, GMMs, recogClasses);
+		// int N = (int)vvData.size();
+		// recogClasses.resize(N, 0);
+		// int I = (int)GMMs.size();
+		// for(int n = 0; n < N; n++)
+		// {
+			// double maxni = GMMs[0].CompLikelihoodPart(vvData[n], vDimConsidered);
+			// int argmaxni = 0;
+			// for(int i = 1; i < I ;i++)
+			// {
+				// double dbi = GMMs[i].CompLikelihoodPart(vvData[n], vDimConsidered);
+				// if(dbi > maxni)
+				// {
+					// maxni = dbi;
+					// argmaxni = i;
+				// }
+			// }
+			// recogClasses[n] = argmaxni;
+		// }
+		// return 1;
+	}
+
+	// maximum likelihood decision for 2 classes, without considering partial dimension
+	int Test2ClassesGMMsFull(vector< vector<double> >& vvData, vector<GMM>& GMMs, vector<int>& recogClasses)
+	{
+		return GMMAdaptTool::Test2ClassesGMMsFull(vvData, GMMs, recogClasses);
+	}
+
+	// Stochastic matching on feature space
+	int GMMAdaptRcogAFrame(vector<GMM>& oldGMMs, vector< vector<double> >& vvData, vector<int>& vrecogclasses)
+	{
+		return GMMAdaptTool::GMMAdaptRcogAFrame(oldGMMs, vvData, vrecogclasses);
+	}
+
+	void AutoLabelRGBOnly(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio)
+	{
+		return GMMAdaptTool::AutoLabelRGBOnly(szPath, vGMMs, mask, shrinkratio, m_nHandModelIndex);
+	}
+	void AutoLabel_BS0(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio, cv::Mat& ref)
+	{
+		return GMMAdaptTool::AutoLabel_BS0(szPath, vGMMs, mask, shrinkratio, m_nHandModelIndex, ref);
+	}
+	void Approx_AutoLabel_BS0(string szPath, bool*** vvvDecisionTable, cv::Mat& mask, int shrinkratio, cv::Mat& ref)
+	{
+		return GMMAdaptTool::Approx_AutoLabel_BS0(szPath, vvvDecisionTable, mask, shrinkratio, m_nHandModelIndex, ref);
+	}
+	// Get skin/nonskin color label, only consider RGB mean
+	void AutoLabelPart(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio)
+	{
+		return GMMAdaptTool::AutoLabelPart(szPath, vGMMs, mask, shrinkratio, m_nHandModelIndex);
+	}
+	// Get skin/nonskin color label with stochastic feature matching
+	void AutoLabelPartSM(string szPath, vector<GMM>& vGMMs, cv::Mat& mask, int shrinkratio)
+	{
+		return GMMAdaptTool::AutoLabelPartSM(szPath, vGMMs, mask, shrinkratio, m_nHandModelIndex);
+	}
+	double CompRectDistNN(CvRect r1, CvRect r2)
+	{
+		// compute the nearest distance between 2 rectangles
+		double x1 = (double)r1.x;
+		double y1 = (double)r1.y;
+		double x2 = (double)(r1.x + r1.width);
+		double y2 = (double)(r1.y + r1.height);
+		double x3 = (double)r2.x;
+		double y3 = (double)r2.y;
+		double x4 = (double)(r2.x + r2.width);
+		double y4 = (double)(r2.y + r2.height);
+		double minx = MAX(x1,x3);
+		double miny = MAX(y1,y3);
+		double maxx = MIN(x2,x4);
+		double maxy = MIN(y2,y4);
+		double compx = ((minx > maxx)?(minx - maxx):0.0);
+		double compy = ((miny > maxy)?(miny - maxy):0.0);
+		double comp = ((compx > 0 && compy > 0)?sqrt(compx*compx+compy*compy):MAX(compx,compy));
+		double area1 = (double)(r1.width * r1.height);
+		double area2 =  (double)(r2.width * r2.height);
+		comp /= sqrt(MIN(area1, area2));
+		return comp;
+	}
+
+	void CalcDist(vector<CvRect>& vRect, list< list<double> >& llRectDist, double& dMin, int& argminx, int& argminy)
+	{
+		int N = (int)vRect.size();
+		dMin = 1.7976931348623158e+308;
+		llRectDist.resize(N-1);
+		list< list<double> >::iterator llitr = llRectDist.begin();
+		for(int i = 0; i < N-1; i++)
+		{	
+			for(int j = i+1; j < N; j++)
+			{
+				double dij = CompRectDistNN(vRect[i], vRect[j]);
+				if(dij < dMin)
+				{
+					dMin = dij;
+					argminx = j;
+					argminy = i;
+				}
+				(*llitr).push_back(dij);
+			}
+			llitr++;
+		}
+	}
+
+	bool CheckRectInt9r2(CvRect r1, CvRect r2)
+	{
+		// check if 4x rect2 intersect r1
+		double x1 = (double)r1.x;
+		double y1 = (double)r1.y;
+		double x2 = (double)(r1.x + r1.width);
+		double y2 = (double)(r1.y + r1.height);
+
+		double x3 = (double)r2.x - (double)r2.width;
+		double y3 = (double)r2.y - (double)r2.height;
+		double x4 = x3 + 3.0 * (double)r2.width;
+		double y4 = y3 + 3.0 * (double)r2.height;
+
+		double minx = MAX(x1,x3);
+		double miny = MAX(y1,y3);
+		double maxx = MIN(x2,x4);
+		double maxy = MIN(y2,y4);
+		if((minx>maxx)|(miny>maxy))
+		{
+			return false;
+		}
+		return true;
+	}
+
+	bool UpdateDistRect(vector<CvRect>& vRect, list< list<double> >& llRectDist, double& dMin, int& argminx, int& argminy)
+	{
+		int N = (int)vRect.size();
+		if(N == 1)
+		{
+			return false;
+		}
+		dMin = DBL_MAX; //1.7976931348623158e+308;
+		//llRectDist.resize(N-1);
+		list< list<double> >::iterator llitr = llRectDist.begin();
+		int i = MIN(argminx, argminy);
+		int j = MAX(argminx, argminy);
+		double Areai = (double)(vRect[i].width * vRect[i].height);
+		double Areaj = (double)(vRect[j].width * vRect[j].height);
+		CvRect LRect = vRect[i];
+		CvRect SRect = vRect[j];
+		if(Areai < Areaj)
+		{
+			LRect = vRect[j];
+			SRect = vRect[i];
+		}
+		bool bCanMerge = CheckRectInt9r2(LRect, SRect);
+		if(bCanMerge)
+		{
+			CvRect Rectij = ::cvMaxRect(&LRect, &SRect);
+			// Update the ith column of 0 to i-1 th rows,
+			for(int m = 0; m < i; m++)
+			{
+				list<double>::iterator itrmn = (*llitr).begin();
+				int mi = 0;
+				while(mi < i - m - 1)
+				{
+					itrmn++;
+					mi++;
+				}
+				(*itrmn) = CompRectDistNN(Rectij, vRect[m]);
+				llitr++;
+			}
+			// Update ith row
+			list<double>::iterator itrmn = (*llitr).begin();
+			for(int n = i+1; n < N; n++)
+			{
+				if(n != j)
+				{
+					(*itrmn) = CompRectDistNN(Rectij, vRect[n]);
+				}
+				itrmn++;
+			}
+			// Delete jth row
+			for(int k = i; k < j; k++)
+			{
+				llitr++;
+			}
+			int N1 = N - 1;
+			if(llitr != llRectDist.end())
+			{
+				llRectDist.erase(llitr);
+			}
+			// Delete jth column for 0 to j-1 th row
+			llitr = llRectDist.begin();
+			for(int k = 0; k < j; k++)
+			{
+				itrmn = (*llitr).begin();
+				int mi = 0;
+				while(mi < j - k - 1)
+				{
+					itrmn++;
+					mi++;
+				}
+				(*llitr).erase(itrmn);
+				if(0 == (*llitr).size())
+				{
+					llRectDist.erase(llitr);
+				}
+				else
+				{
+					llitr++;
+				}
+			}
+			// Find the new minimum distance
+			llitr = llRectDist.begin();
+			for(int n = 0; n < N1-1; n++)
+			{	
+				itrmn = (*llitr).begin();
+				for(int m = n+1; m < N1; m++)
+				{
+					double dnm = (*itrmn);
+					if(dnm < dMin)
+					{
+						dMin = dnm;
+						argminx = m;
+						argminy = n;
+					}
+					itrmn++;
+				}
+				llitr++;
+			}
+			// Update vRect
+			vRect[i] = Rectij;
+			for(int k = j; k < N1; k++)
+			{
+				vRect[k] = vRect[k+1];
+			}
+			vRect.pop_back();
+		}
+		return bCanMerge;
+	}
+
+	void AggMerge(vector<CvRect>& vRect, vector<CvRect>& vAggRect, int& nROI)
+	{
+		int N = (int) vRect.size();
+		list< list<double> > llRectDist;
+		double dMin = 1.7976931348623158e+308;
+		int argminx = 0;
+		int argminy = 0;
+		for(int n = 0; n < N; n++)
+		{
+			vAggRect.push_back(vRect[n]);
+		}
+		CalcDist(vAggRect, llRectDist, dMin, argminx, argminy);
+		while(UpdateDistRect(vAggRect, llRectDist, dMin, argminx, argminy))
+		{
+		}
+		double dArea = 0.0;
+		nROI = 0;
+		for(int n = 0; n < (int)vAggRect.size(); n++)
+		{
+			double dArean = (double)(vAggRect[n].width * vAggRect[n].height);
+			if(dArean > dArea)
+			{
+				dArea = dArean;
+				nROI = n;
+			}
+		}
+
+	}
+
+	HRESULT GetKCurvaturePoint(CvPoint* pArr, int nSize, unsigned int i, int k, CvPoint& Pik, int MaxX, int MaxY)
+	{
+		if(pArr == 0)
+		{
+			return E_POINTER;
+		}
+		if((unsigned int)nSize <= i)
+		{
+			return ERROR_INVALID_ADDRESS;
+		}
+		CvPoint Pi = pArr[i];
+
+		if(Pi.x >= MaxX - 2 || Pi.y >= MaxY - 2)
+		{
+			// Boundary point, set its cosine to -1 outside this function
+			return ERROR_INVALID_INDEX;
+		}
+		if(k == 0)
+		{
+			// k must be integer other than 0
+			return ERROR_INVALID_INDEX;
+		}
+			int nnk = 1;
+		int nk = (k > 0)?i+1:i-1;
+		nk = nk % nSize;
+		if(nk < 0)
+			nk += nSize;
+		int ak = abs(k);
+		bool bTouchBoundary = false;
+		while(nnk <= ak)
+		{
+			CvPoint Pnk = pArr[nk];
+			if(Pnk.x >= MaxX - 2 || Pnk.y >= MaxY - 2)
+			{
+				Pik.x = ak / nnk * (Pnk.x - Pi.x) + Pi.x;
+				Pik.y = ak / nnk * (Pnk.y - Pi.y) + Pi.y;
+				bTouchBoundary = true;
+				break;
+			}
+			nnk++;
+			nk = (k > 0)?nk+1:nk-1;
+			nk = nk % nSize;
+			if(nk < 0)
+				nk += nSize;		
+		}
+		if(bTouchBoundary == false)
+		{
+			int nIndex = i + k;
+			nIndex %= nSize;
+			while(nIndex < 0)
+			{
+				nIndex += nSize;
+			}
+			Pik.x = pArr[nIndex].x;
+			Pik.y = pArr[nIndex].y;
+		}
+		return S_OK;
+	}
+
+	// return the cosine value between 2 vectors
+	double ComputeCvVectorCosine(const CvPoint& vec1, const CvPoint& vec2)
+	{
+		double norm1 = sqrt((double)(vec1.x * vec1.x + vec1.y * vec1.y));
+		double norm2 = sqrt((double)(vec2.x * vec2.x + vec2.y * vec2.y));
+		double dot = (double)(vec1.x * vec2.x + vec1.y * vec2.y);
+		double dbcos = dot/(norm1 * norm2);
+		return dbcos;
+	}	
+	HRESULT COMPoints(Mat& src, vector<double>& vec)
+	{
+		cv::Mat srccpy;
+		src.copyTo(srccpy);
+		vector< vector<Point> > contours;
+		vector<double> vcontour_area;
+		cv::findContours(srccpy, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
+		vcontour_area.resize(contours.size(),0);
+		if(0 == contours.size())
+		{
+			vec.resize(2,-1.0);
+			return S_FALSE;
+		}
+		double dbmaxarea = 0;
+		for(size_t nn = 0; nn < contours.size(); ++nn)
+		{
+			vcontour_area[nn] = cv::contourArea(cv::Mat(contours[nn]));
+			if(vcontour_area[nn] > dbmaxarea)
+				dbmaxarea = vcontour_area[nn];
+		}
+		double area_tr = dbmaxarea*0.1;
+		area_tr = (area_tr>10)?area_tr:10;
+		vector<size_t> valid_idx;
+		for(size_t nn = 0; nn < contours.size(); ++nn)
+		{
+			if(vcontour_area[nn]>area_tr)
+			{
+				valid_idx.push_back(nn);
+			}
+		}
+		vec.resize(2,0.0);
+		double dbcount = 0.0;
+		for(size_t nn = 0; nn < src.cols; ++nn)
+		{
+			for(size_t mm = 0; mm < src.rows; ++mm)
+			{
+				CvMat tmpmat = src.operator CvMat();
+				double dbVal = cvGetReal2D(&tmpmat, mm,nn);
+				if(dbVal != 0)
+				{
+					Point2f pt((float)nn, (float)mm);
+					for(size_t nn1 = 0; nn1 < valid_idx.size(); ++nn1)
+					{
+						double resnn1 = pointPolygonTest(cv::Mat(contours[valid_idx[nn1]]), pt, false);
+						if(resnn1 >=0)
+						{
+							vec[0] += (double)nn;
+							vec[1] += (double)mm;
+							dbcount += 1.0;
+							break;
+						}
+					}
+				}
+			}
+		}
+		vec[0]/=dbcount;
+		vec[1]/=dbcount;
+		return S_OK;
+	}
+	// Estimate center of mass (vec[0], vec[1]) and finger location (vec[2], vec[3])
+	HRESULT EstCOMandFingerLoc1(IplImage*& src, vector<double>& vec)
+	{
+		CvMemStorage* storage = cvCreateMemStorage(0);
+		CvMemStorage* chstorage = cvCreateMemStorage(0);
+		CvSeq* first_contour = 0;
+		double dbAngleThreshold = 0.1;
+		int M = src->height;
+		int N = src->width;
+		int mode = CV_RETR_EXTERNAL;
+		IplImage* srcpy = cvCreateImage(cvSize(src->width, src->height), src->depth, src->nChannels);
+		cvCopy(src, srcpy);
+		cvFindContours( srcpy, storage, &first_contour, sizeof(CvContour), 
+			  mode, CV_CHAIN_APPROX_NONE/*CV_CHAIN_APPROX_SIMPLE*/, cvPoint(0,0));
+
+		if(first_contour == 0) // No contour found
+		{
+			cvReleaseMemStorage(&storage);
+			cvReleaseImage(&srcpy);
+			return ERROR_OUT_OF_PAPER;
+		}
+		double dMaxArea = fabs(cvContourArea(first_contour));
+		CvSeq* Maxcontour = first_contour;
+		CvSeq* contour = first_contour->h_next;
+		
+		// For debug only
+		/*
+		if(m_pImg4DrawContour != 0)
+		{
+			cvDrawContours(m_pImg4DrawContour, 
+				first_contour, 
+				CV_RGB(0, 255, 255), 
+				CV_RGB(255, 0, 255), 0, 2 
+				);
+		}
+		*/
+
+		while(contour != NULL)
+		{
+			double dArea = fabs(cvContourArea(contour));
+			// For debug only
+			/*
+			if(m_pImg4DrawContour != 0)
+			{
+				cvDrawContours(m_pImg4DrawContour, 
+					contour, 
+					CV_RGB(0, 255, 255), 
+					CV_RGB(255, 0, 255), 0, 2 
+					);
+			}
+			*/
+			if(dArea > dMaxArea)
+			{
+				Maxcontour = contour;
+				dMaxArea = dArea;
+			}
+			contour = contour->h_next;
+		}
+		CvPoint* Arr = new CvPoint[Maxcontour->total];
+		cvCvtSeqToArray(Maxcontour, Arr);
+		int* pnCH = new int [Maxcontour->total];
+		int nhullsize = 0;
+		cvConvexHull(Arr, Maxcontour->total, NULL, CV_CLOCKWISE, pnCH, &nhullsize);
+
+		CvPoint* Arrch = new CvPoint[nhullsize];
+		for(int n = 0; n < nhullsize; n++)
+		{
+			Arrch[n].x = Arr[pnCH[n]].x;
+			Arrch[n].y = Arr[pnCH[n]].y;
+		}
+
+		int my = src->height;
+		int My = 0;
+		int mx = src->width; 
+		int Mx = 0;
+		for(int n = 0; n < Maxcontour->total; n++)
+		{
+			if(Arr[n].y < my)
+			{
+				my = Arr[n].y;
+			}
+			if(Arr[n].x < mx)
+			{
+				mx = Arr[n].x;
+			}
+			if(Arr[n].x > Mx)
+			{
+				Mx = Arr[n].x;
+			}
+			if(Arr[n].y > My)
+			{
+				My = Arr[n].y;
+			}
+		}
+		int tempx = Mx-mx+1;
+		int tempy = My-my+1;
+		cvSetImageROI(src, cvRect(mx, my, tempx, tempy));
+		int tempx0 = 0;
+		int tempy0 = 0;	
+		int npts = 0;
+		for(int m = 0; m < tempx; m++)
+		{
+			for(int n = 0; n < tempy; n++)
+			{
+				CvScalar val = cvGet2D(src, n, m);
+				if(val.val[0] == 255.0)
+				{
+					tempx0 += m;
+					tempy0 += n;
+					npts++;
+				}
+			}
+		}
+		double cx = ((double)tempx0/(double)npts);
+		double cy = ((double)tempy0/(double)npts);
+
+		cvResetImageROI(src);
+		cx += (double)mx;
+		cy += (double)my;
+
+		vector<double> vKK(Maxcontour->total);
+
+		// For debug only
+		/*
+		if(m_pImg4DrawContour != 0)
+		{
+			cvDrawContours(m_pImg4DrawContour, 
+				Maxcontour, 
+				CV_RGB(0, 255, 255), 
+				CV_RGB(255, 0, 255), 0 
+				);
+			for(int nch = 0; nch < nhullsize - 1; nch++)
+			{
+				cvLine(m_pImg4DrawContour, 
+					Arrch[nch],
+					Arrch[nch+1],
+					CV_RGB(255, 0, 255));
+			}
+
+			cvLine(m_pImg4DrawContour, 
+				Arrch[nhullsize - 1],
+				Arrch[0],
+				CV_RGB(255, 0, 255));
+		}
+		*/
+
+		double MaxKK = -1.0;
+		int MaxKKPos = 0;
+		double MaxKK2 = -1.0;
+		int MaxKKPos2 = 0;
+		vector<double> vKK2(nhullsize);
+
+		int nNumPts = nhullsize;
+		double dbrK = (double)m_nK * (double)nNumPts / (double)Maxcontour->total;
+		int nrK = (int)dbrK;
+		if(nrK <= 2)
+		{
+			nrK = 2;
+		}
+		CvPoint* ArrToTrack = Arrch;
+		for(int n = 0; n < nNumPts; n++)
+		{
+			CvPoint Pi = ArrToTrack[n];
+
+			CvPoint Pip1;
+			CvPoint Pim1;
+			CvPoint Pip2;
+			CvPoint Pim2;
+			HRESULT hrp1 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, 1, Pip1, N, M);
+			HRESULT hrm1 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, -1, Pim1, N, M);
+			HRESULT hrp2 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, 2, Pip2, N, M);
+			HRESULT hrm2 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, -2, Pim2, N, M);
+			CvPoint Pip1ip2 = cvPoint(Pip2.x - Pip1.x, Pip2.y - Pip1.y);
+			CvPoint Pip1i = cvPoint(Pi.x - Pip1.x, Pi.y - Pip1.y);
+			CvPoint Pim1im2 = cvPoint(Pim2.x - Pim1.x, Pim2.y - Pim1.y);
+			CvPoint Pim1i = cvPoint(Pi.x - Pim1.x, Pi.y - Pim1.y);
+			double cosp1 = (double)(Pip1ip2.x * Pip1i.x + Pip1ip2.y * Pip1i.y)/
+					( sqrt((double)(Pip1ip2.x * Pip1ip2.x + Pip1ip2.y * Pip1ip2.y)) * 
+					sqrt((double)(Pip1i.x * Pip1i.x + Pip1i.y * Pip1i.y)));
+			double cosm1 = (double)(Pim1im2.x * Pim1i.x + Pim1im2.y * Pim1i.y)/
+					( sqrt((double)(Pim1im2.x * Pim1im2.x + Pim1im2.y * Pim1im2.y)) * 
+					sqrt((double)(Pim1i.x * Pim1i.x + Pim1i.y * Pim1i.y)));
+
+			CvPoint Pipk;
+			CvPoint Pimk;
+			
+			HRESULT hrpk = GetKCurvaturePoint(ArrToTrack, nNumPts, n, nrK, Pipk, N, M);
+			HRESULT hrmk = GetKCurvaturePoint(ArrToTrack, nNumPts, n, -1 * nrK, Pimk, N, M);
+			if(hrpk == ERROR_INVALID_INDEX ||
+				hrmk == ERROR_INVALID_INDEX ||
+				hrp1 == ERROR_INVALID_INDEX ||
+				hrm1 == ERROR_INVALID_INDEX ||
+				hrp2 == ERROR_INVALID_INDEX ||
+				hrm2 == ERROR_INVALID_INDEX)
+			{
+				vKK[n] = -1.0;
+				vKK2[n] = -1.0;
+			}
+			else
+			{
+				CvPoint DPipk = cvPoint(Pipk.x - Pi.x, Pipk.y - Pi.y);
+				CvPoint DPimk = cvPoint(Pimk.x - Pi.x, Pimk.y - Pi.y);
+				// For debug only
+				/*
+				if(m_pImg4DrawContour != 0)
+				{
+					cvCircle(m_pImg4DrawContour,
+						Pi,
+						2,
+						CV_RGB(255, 64, 255));
+				}
+				*/
+				double dyi = (double)(Pi.y - my);
+				vKK2[n] = (double)(DPipk.x * DPimk.x + DPipk.y * DPimk.y)/
+					( sqrt((double)(DPipk.x * DPipk.x + DPipk.y * DPipk.y)) * 
+					sqrt((double)(DPimk.x * DPimk.x + DPimk.y * DPimk.y)));
+				if(vKK2[n] > MaxKK2 && Pi.x != Mx)
+				{
+					MaxKKPos2 = n;
+					MaxKK2 = vKK2[n];
+				}
+				if(dyi >= 0 && dyi < (1 - m_duth) * (double)(M - my))
+				{
+					vKK[n] = (double)(DPipk.x * DPimk.x + DPipk.y * DPimk.y)/
+						( sqrt((double)(DPipk.x * DPipk.x + DPipk.y * DPipk.y)) * 
+						sqrt((double)(DPimk.x * DPimk.x + DPimk.y * DPimk.y)));
+
+					if(fabs(cosp1) >= dbAngleThreshold &&
+						fabs(cosm1) >= dbAngleThreshold &&
+						Pi.x < N - 2
+		/*				!(Pip1.x == Pip2.x || Pip1.y == Pip2.y) &&
+						!(Pim1.x == Pim2.x || Pim1.y == Pim2.y) && 
+						Pim1.x != Pi.x*/)
+					{
+						if(vKK[n] > MaxKK)
+						{
+							MaxKKPos = n;
+							MaxKK = vKK[n];
+						}
+					}
+				}
+				else
+				{
+					vKK[n] = -1.0;
+				}
+			}
+		}
+		
+		if(MaxKK < -0.9 /*&& (M - my) < 0.2 * M*/)
+		{
+			MaxKK = MaxKK2;
+			MaxKKPos = MaxKKPos2;
+		}
+
+		double dfx = ArrToTrack[MaxKKPos].x;
+		double dfy = ArrToTrack[MaxKKPos].y;
+		// For debug only
+		/*
+		if(m_pImg4DrawContour != 0 )
+		{
+			cvCircle(m_pImg4DrawContour,cvPoint(cx, cy), 2, CV_RGB(255, 0, 0));
+			cvCircle(m_pImg4DrawContour,cvPoint(dfx, dfy), 2, CV_RGB(0, 255, 0));
+		}
+		*/
+		vec.resize(4);
+		vec[0] = cx;
+		vec[1] = cy;
+		vec[2] = dfx;
+		vec[3] = dfy;
+		cvReleaseMemStorage(&storage);
+		cvReleaseMemStorage(&chstorage);
+		cvReleaseImage(&srcpy);
+		delete [] Arr;
+		delete [] Arrch;
+		return S_OK;
+	}
+
+	// Estimate center of mass (vec[0], vec[1]) and finger location (vec[2], vec[3])
+	HRESULT EstCOMandFingerLoc2(IplImage*& src, vector<double>& vec, const vector<double>& lastvec)
+	{
+		CvMemStorage* storage = cvCreateMemStorage(0);
+		CvMemStorage* chstorage = cvCreateMemStorage(0);
+		CvSeq* first_contour = 0;
+		double dbAngleThreshold = 0.1;
+		int M = src->height;
+		int N = src->width;
+		int mode = CV_RETR_EXTERNAL;
+		IplImage* srcpy = cvCreateImage(cvSize(src->width, src->height), src->depth, src->nChannels);
+		cvCopy(src, srcpy);
+		cvFindContours( srcpy, storage, &first_contour, sizeof(CvContour), 
+			  mode, CV_CHAIN_APPROX_NONE/*CV_CHAIN_APPROX_SIMPLE*/, cvPoint(0,0));
+		if(first_contour == 0) // No contour found
+		{
+			cvReleaseMemStorage(&storage);
+			cvReleaseImage(&srcpy);
+			return ERROR_OUT_OF_PAPER;
+		}
+		double dMaxArea = fabs(cvContourArea(first_contour));
+		CvSeq* Maxcontour = first_contour;
+		CvSeq* contour = first_contour->h_next;
+		// For debug only
+		/*
+		if(m_pImg4DrawContour != 0)
+		{
+			cvDrawContours(m_pImg4DrawContour, 
+				first_contour, 
+				CV_RGB(0, 255, 255), 
+				CV_RGB(255, 0, 255), 0, 2 
+				);
+		}
+		*/
+		while(contour != NULL)
+		{
+			double dArea = fabs(cvContourArea(contour));
+			// For debug only
+			/*
+			if(m_pImg4DrawContour != 0)
+			{
+				cvDrawContours(m_pImg4DrawContour, 
+					contour, 
+					CV_RGB(0, 255, 255), 
+					CV_RGB(255, 0, 255), 0);
+			}
+			*/
+			if(dArea > dMaxArea)
+			{
+				Maxcontour = contour;
+				dMaxArea = dArea;
+			}
+			contour = contour->h_next;
+		}
+
+		// K-curvature Algorithm
+		CvPoint* Arr = new CvPoint[Maxcontour->total];
+		cvCvtSeqToArray(Maxcontour, Arr);
+		int* pnCH = new int [Maxcontour->total];
+		int nhullsize = 0;
+		cvConvexHull(Arr, Maxcontour->total, NULL, CV_CLOCKWISE, pnCH, &nhullsize);
+
+		CvPoint* Arrch = new CvPoint[nhullsize];
+		for(int n = 0; n < nhullsize; n++)
+		{
+			Arrch[n].x = Arr[pnCH[n]].x;
+			Arrch[n].y = Arr[pnCH[n]].y;
+		}
+
+		int my = src->height;
+		int My = 0;
+		int mx = src->width; 
+		int Mx = 0;
+		for(int n = 0; n < Maxcontour->total; n++)
+		{
+			if(Arr[n].y < my)
+			{
+				my = Arr[n].y;
+			}
+			if(Arr[n].x < mx)
+			{
+				mx = Arr[n].x;
+			}
+			if(Arr[n].x > Mx)
+			{
+				Mx = Arr[n].x;
+			}
+			if(Arr[n].y > My)
+			{
+				My = Arr[n].y;
+			}
+		}
+		int tempx = Mx-mx+1;
+		int tempy = My-my+1;
+		cvSetImageROI(src, cvRect(mx, my, tempx, tempy));
+		int tempx0 = 0;
+		int tempy0 = 0;	
+		int npts = 0;
+		for(int m = 0; m < tempx; m++)
+		{
+			for(int n = 0; n < tempy; n++)
+			{
+				CvScalar val = cvGet2D(src, n, m);
+				if(val.val[0] == 255.0)
+				{
+					tempx0 += m;
+					tempy0 += n;
+					npts++;
+				}
+			}
+		}
+		double cx = ((double)tempx0/(double)npts);
+		double cy = ((double)tempy0/(double)npts);
+		cvResetImageROI(src);
+		cx += (double)mx;
+		cy += (double)my;
+
+		vector<double> vKK(Maxcontour->total);
+		// For debug only
+		/*
+		if(m_pImg4DrawContour != 0)
+		{
+			cvDrawContours(m_pImg4DrawContour, 
+				Maxcontour, 
+				CV_RGB(0, 255, 255), 
+				CV_RGB(255, 0, 255), 
+				0);
+			for(int nch = 0; nch < nhullsize - 1; nch++)
+			{
+				cvLine(m_pImg4DrawContour, 
+					Arrch[nch],
+					Arrch[nch+1],
+					CV_RGB(255, 0, 255));
+			}
+			cvLine(m_pImg4DrawContour, 
+				Arrch[nhullsize - 1],
+				Arrch[0],
+				CV_RGB(255, 0, 255));
+		}
+		*/
+		double MaxKK = -1.0;
+		int MaxKKPos = 0;
+		double MaxKK2 = -1.0;
+		int MaxKKPos2 = 0;
+		vector<double> vKK2(nhullsize);
+
+		int nNumPts = nhullsize;
+		double dbrK = (double)m_nK * (double)nNumPts / (double)Maxcontour->total;
+		int nrK = (int)dbrK;
+		if(nrK <= 2)
+		{
+			nrK = 2;
+		}
+		CvPoint* ArrToTrack = Arrch;
+		CvPoint mcMove = cvPoint((int)(cx - lastvec[0]), (int)(cy - lastvec[1]));
+		CvPoint lastmcfg = cvPoint((int)(lastvec[2] - lastvec[0]), (int)(lastvec[3] - lastvec[1]));
+		ofstream outf;
+
+		for(int n = 0; n < nNumPts; n++)
+		{
+			CvPoint Pi = ArrToTrack[n];		
+			CvPoint fgMove = cvPoint((int)(Pi.x - lastvec[2]), (int)(Pi.y - lastvec[3]));
+			CvPoint mcfg = cvPoint((int)(Pi.x - cx), (int)(Pi.y - cy));
+			double dMovecos = ComputeCvVectorCosine(mcMove, fgMove);
+			double dmcfgcos = ComputeCvVectorCosine(lastmcfg, mcfg);
+
+			if(dmcfgcos > 0/*mcMove.x * fgMove.x >= 0 /*&& 
+				mcMove.y * fgMove.y >= 0 &&
+				lastmcfg.x * mcfg.x >= 0 &&
+				lastmcfg.y * mcfg.y >= 0*/)
+			{
+				CvPoint Pip1;
+				CvPoint Pim1;
+				CvPoint Pip2;
+				CvPoint Pim2;
+				HRESULT hrp1 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, 1, Pip1, N, M);
+				HRESULT hrm1 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, -1, Pim1, N, M);
+				HRESULT hrp2 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, 2, Pip2, N, M);
+				HRESULT hrm2 = GetKCurvaturePoint(ArrToTrack, nNumPts, n, -2, Pim2, N, M);
+				CvPoint Pip1ip2 = cvPoint(Pip2.x - Pip1.x, Pip2.y - Pip1.y);
+				CvPoint Pip1i = cvPoint(Pi.x - Pip1.x, Pi.y - Pip1.y);
+				CvPoint Pim1im2 = cvPoint(Pim2.x - Pim1.x, Pim2.y - Pim1.y);
+				CvPoint Pim1i = cvPoint(Pi.x - Pim1.x, Pi.y - Pim1.y);
+				double cosp1 = (double)(Pip1ip2.x * Pip1i.x + Pip1ip2.y * Pip1i.y)/
+						( sqrt((double)(Pip1ip2.x * Pip1ip2.x + Pip1ip2.y * Pip1ip2.y)) * 
+						sqrt((double)(Pip1i.x * Pip1i.x + Pip1i.y * Pip1i.y)));
+				double cosm1 = (double)(Pim1im2.x * Pim1i.x + Pim1im2.y * Pim1i.y)/
+						( sqrt((double)(Pim1im2.x * Pim1im2.x + Pim1im2.y * Pim1im2.y)) * 
+						sqrt((double)(Pim1i.x * Pim1i.x + Pim1i.y * Pim1i.y)));
+
+				CvPoint Pipk;
+				CvPoint Pimk;
+				
+				HRESULT hrpk = GetKCurvaturePoint(ArrToTrack, nNumPts, n, nrK, Pipk, N, M);
+				HRESULT hrmk = GetKCurvaturePoint(ArrToTrack, nNumPts, n, -1 * nrK, Pimk, N, M);
+				if(hrpk == ERROR_INVALID_INDEX ||
+					hrmk == ERROR_INVALID_INDEX ||
+					hrp1 == ERROR_INVALID_INDEX ||
+					hrm1 == ERROR_INVALID_INDEX ||
+					hrp2 == ERROR_INVALID_INDEX ||
+					hrm2 == ERROR_INVALID_INDEX)
+				{
+					vKK[n] = -1.0;
+					vKK2[n] = -1.0;
+				}
+				else
+				{
+					CvPoint DPipk = cvPoint(Pipk.x - Pi.x, Pipk.y - Pi.y);
+					CvPoint DPimk = cvPoint(Pimk.x - Pi.x, Pimk.y - Pi.y);
+					// For debug only
+					/*
+					if(m_pImg4DrawContour != 0)
+					{
+						cvCircle(m_pImg4DrawContour,
+							Pi,
+							2,
+							CV_RGB(255, 64, 255));
+					}
+					*/
+					double dyi = (double)(Pi.y - my);
+					vKK2[n] = (double)(DPipk.x * DPimk.x + DPipk.y * DPimk.y)/
+						( sqrt((double)(DPipk.x * DPipk.x + DPipk.y * DPipk.y)) * 
+						sqrt((double)(DPimk.x * DPimk.x + DPimk.y * DPimk.y)));
+					if(vKK2[n] > MaxKK2 && Pi.x != Mx)
+					{
+						MaxKKPos2 = n;
+						MaxKK2 = vKK2[n];
+					}
+					if(dyi >= 0 && dyi < (1 - m_duth) * (double)(M - my))
+					{
+						vKK[n] = (double)(DPipk.x * DPimk.x + DPipk.y * DPimk.y)/
+							( sqrt((double)(DPipk.x * DPipk.x + DPipk.y * DPipk.y)) * 
+							sqrt((double)(DPimk.x * DPimk.x + DPimk.y * DPimk.y)));
+
+						if(1/*fabs(cosp1) >= dbAngleThreshold &&
+							fabs(cosm1) >= dbAngleThreshold &&
+							Pi.x < N - 2*/ 
+							/*
+							!(Pip1.x == Pip2.x || Pip1.y == Pip2.y) &&
+							!(Pim1.x == Pim2.x || Pim1.y == Pim2.y) && 
+							Pim1.x != Pi.x*/)
+						{
+							if(vKK[n] > MaxKK)
+							{
+								MaxKKPos = n;
+								MaxKK = vKK[n];
+							}
+						}
+					}
+					else
+					{
+						vKK[n] = -1.0;
+					}
+				}
+			}
+			else
+			{
+				vKK[n] = -1.0;
+				vKK2[n] = -1.0;
+			}
+		}
+		if(MaxKK < -0.9 /*&& (M - my) < 0.2 * M*/)
+		{
+			MaxKK = MaxKK2;
+			MaxKKPos = MaxKKPos2;
+		}
+		double dfx = ArrToTrack[MaxKKPos].x;
+		double dfy = ArrToTrack[MaxKKPos].y;
+		// For debug only
+		/*
+		if(m_pImg4DrawContour != 0 )
+		{
+			cvCircle(m_pImg4DrawContour,cvPoint(cx, cy), 2, CV_RGB(255, 0, 0));
+			cvCircle(m_pImg4DrawContour,cvPoint(dfx, dfy), 2, CV_RGB(0, 255, 0));
+		}
+		*/
+		vec.resize(4);
+		vec[0] = cx;
+		vec[1] = cy;
+		vec[2] = dfx;
+		vec[3] = dfy;
+		cvReleaseMemStorage(&storage);
+		cvReleaseMemStorage(&chstorage);
+		cvReleaseImage(&srcpy);
+		delete [] Arr;
+		delete [] Arrch;
+		return S_OK;
+	}
+
+	// Morphological closing operation
+	HRESULT CloseImage(const CvArr* src, CvArr*& dst)
+	{
+		if(dst == NULL)
+		{
+			if(CV_IS_MAT_HDR(src))
+			{
+				dst = cvCreateMat(((CvMat*)src)->rows, ((CvMat*)src)->cols, ((CvMat*)src)->type);
+			}
+			else if(CV_IS_IMAGE_HDR(src))
+			{
+				dst = cvCreateImage(cvSize(((IplImage*)src)->width, ((IplImage*)src)->height), ((IplImage*)src)->depth, ((IplImage*)src)->nChannels );
+			}
+		}
+		// construct the structured element
+		IplConvKernel* pelem = ::cvCreateStructuringElementEx(4, 4, 0, 0, CV_SHAPE_ELLIPSE);
+		//Mat elem = cv::getStructuringElement(MORPH_ELLIPSE, Size(6, 6));
+		//Mat temp = Mat();
+		CvArr* temp = 0 ;
+		if(CV_IS_MAT_HDR(src))
+		{
+			temp = cvCreateMat(((CvMat*)src)->rows, ((CvMat*)src)->cols, ((CvMat*)src)->type);
+		}
+		else if(CV_IS_IMAGE_HDR(src))
+		{
+			temp = cvCreateImage(cvSize(((IplImage*)src)->width, ((IplImage*)src)->height), ((IplImage*)src)->depth, ((IplImage*)src)->nChannels );
+		}
+		cvMorphologyEx(src, dst, temp, pelem, CV_MOP_CLOSE, 2); 
+		cvReleaseStructuringElement(&pelem);
+		if(CV_IS_MAT_HDR(src))
+		{
+			cvReleaseMat((CvMat**)&temp);
+		}
+		else if(CV_IS_IMAGE_HDR(src))
+		{
+			cvReleaseImage((IplImage**)&temp);
+		}	
+		return S_OK;
+	}
+
+	HRESULT OfflineFEImgSeq2_2_3_part(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		//for(n = nStart; n <= nStopBkGnd; n++)
+		//{
+		//	pcurr = vpImgs[n];
+		//	if(n == nStart)
+		//	{
+		//		pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+		//		pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+		//		cvSet(pBkGnd, cvScalar(0.0));
+		//		cvSet(pBkGndTmp, cvScalar(0.0));
+		//	}
+		//	pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+		//	cvConvert(pcurr, pcurr2);
+		//	GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+		//	cvReleaseImage(&pcurr);
+		//	cvReleaseImage(&pcurr2);
+		//}
+		//AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		//cvReleaseImage(&pBkGndTmp);
+		//=============================================================================//
+
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask2, 4);
+			AutoLabelRGBOnly(szImgNamen, vGMMs, refmask0, 32);
+			AutoLabelRGBOnly(szImgNamen, vGMMs, refmask, 16);
+			AutoLabelRGBOnly(szImgNamen, vGMMs, refmask2, 4);
+
+			//AutoLabelPart(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask2, 4);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+
+			for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 4.0);
+					nn2 = (int)floor((double)kk2 / 4.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			//=============================================================================//
+		
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrtemp = &iplcurrtemp;
+			cvCopy(piplcurrtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+				cvCurrImgTemp.release();
+			}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		//cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(hrlast == S_OK)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		return hr;
+	}
+
+	HRESULT OfflineFEImgSeq2_2_3_part_BS0(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		for(n = nStart; n <= nStopBkGnd; n++)
+		{
+			pcurr = cvLoadImage(ImgPathNames[n].c_str()); //vpImgs[n];
+			if(n == nStart)
+			{
+				pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				cvSet(pBkGnd, cvScalar(0.0));
+				cvSet(pBkGndTmp, cvScalar(0.0));
+			}
+			pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+			cvConvert(pcurr, pcurr2);
+			GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+			cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2);
+		}
+		AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		cvReleaseImage(&pBkGndTmp);
+		cv::Mat BkGnd(pBkGnd);
+		//=============================================================================//
+
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask2, 4);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask0, 32, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask2, 4, BkGnd);
+
+//#ifdef _MSC_VER
+			//DWORD dw1 = ::timeGetTime();
+//#endif
+			AutoLabel_BS0(szImgNamen, vGMMs, refmask0, 32, BkGnd);
+//#ifdef _MSC_VER
+			//DWORD dw2 = ::timeGetTime();
+//#endif
+			AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+//#ifdef _MSC_VER
+//			DWORD dw3 = ::timeGetTime();
+//#endif
+			AutoLabel_BS0(szImgNamen, vGMMs, refmask2, 4, BkGnd);
+
+//#ifdef _MSC_VER
+//			DWORD dw4 = ::timeGetTime();
+			//cout<<"Scale 32*32 takes "<<dw2-dw1<<" ms"<<endl;
+			//cout<<"Scale 16*16 takes "<<dw3-dw2<<" ms"<<endl;
+			//cout<<"Scale 4*4 takes "<<dw4-dw3<<" ms"<<endl;
+//#endif
+			//AutoLabelPart(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask2, 4);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+
+			for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 4.0);
+					nn2 = (int)floor((double)kk2 / 4.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			vector<double> comvec;
+			//COMPoints(refmask2, comvec);
+			//=============================================================================//
+		
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+			//cv::resize(refmask, refmask2, cv::Size(), 4, 4, INTER_NEAREST);
+			//iplrefmask2 = refmask2.operator IplImage();
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrtemp = &iplcurrtemp;
+			cvCopy(piplcurrtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+				cvCurrImgTemp.release();
+			}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(hrlast == S_OK)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		return hr;
+	}
+
+
+
+	// bFrameBatch: true: framewise, false: batch
+	// nAdaptMode: 0: MAPOnly 1: ScoreFusion Only 2: MAP+Score Fusion
+	// old version
+	//HRESULT OfflineFEImgSeq2_2_3_part_BS0_Fusion(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs, vector<GMM>& vFusionGMMs, bool bFrameBatch, int nAdaptMode)
+	//{
+	//#ifdef _WIN32
+	//	string delim = "\\";
+	//#else
+	//	string delim = "/";
+	//#endif
+	//	string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+	//	string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+	//	string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+	//	string szMLFName = vFEN[nID].szMLFName;
+	//	string szLabelName = vFEN[nID].szLabelName;
+	//	string szKeyName = vFEN[nID].szKeyName; 
+	//	string szErrLog = vFEN[nID].szErrLog;
+	//	size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+	//	string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+	//	IplImage* pcurr = 0;
+	//	IplImage* pBkGndTmp = 0;
+	//	IplImage* pBkGnd = 0;
+	//	IplImage* pRef1 = 0;
+	//	IplImage* pRef2 = 0;
+	//	IplImage* pcurr2 = 0;
+	//	IplImage* pcurr2c = 0;
+	//	IplImage* pcurr2b = 0;
+	//	//IplImage* pcurr2bcpy = 0;
+	//	IplImage* pcurr2b_tempb = 0;
+	//	//IplImage* pcurr2b_tempb2 = 0;
+	//	IplImage* pcurr2b_tempb3 = 0;
+	//	IplImage* pImgb = 0;
+	//	IplImage* pImgbs = 0;
+	//	IplImage iplrefmask0;
+	//	IplImage iplrefmask;
+	//	IplImage iplrefmask2;
+	//	CvMemStorage* storage = 0;
+	//	CvSeq* first_contour = 0;
+	//	CvSeq* contour = 0;
+	//	cv::Mat curr2b;
+	//	cv::Mat curr2b2;
+	//	vector< vector<double> > vvFeature;
+	//	vector<double> vTmpTmp(4);
+	//	vector<double> vTmp;
+	//	vector<int> vHandVanishIndices;
+	//	vector<CvRect> vRect;
+	//	vector<CvRect> vAggRect;
+	//	CvRect rectROI;
+	//	CvRect rect1;
+	//	CvRect recti;
+	//	IplImage* pImgbSWM = 0;
+	//	IplImage* pSWMask = 0;
+
+	//	HRESULT hr = S_OK;
+	//	HRESULT hrTrackFinger = S_OK;
+	//	int nStopBkGnd = 0;
+	//	int nStart = 0;
+	//	int nStop = (int)vpImgs.size() - 1;
+	//	int n = 0;
+	//	int kk1 = 0;
+	//	int kk2 = 0;
+	//	int nn1 = 0;
+	//	int nn2 = 0;
+	//	int nk = 0;
+	//	int nrectnum = 0;
+	//	int nROIIndex = 0;
+	//	
+	//	
+	//	double db1 = 0.0;
+	//	double cxn_k = 0.0;
+	//	double cyn_k = 0.0;
+	//	double dxn_k = 0.0;
+	//	double dyn_k = 0.0;
+	//	double cxn = 0.0;
+	//	double cyn = 0.0;;
+	//	double dxn = 0.0;
+	//	double dyn = 0.0;					
+	//	double r = 0.0;
+	//	//=============================================================================//
+	//	// Begin feature extraction
+	//	//=============================================================================//
+	//	if(nStop <= 0)
+	//	{
+	//		return ERROR_EMPTY;
+	//	}
+	//	//=============================================================================//
+
+	//	//=============================================================================//
+	//	// Check where hand is inside the frame and outside 
+	//	//=============================================================================//
+	//	hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+	//	if(hr == ERROR_EMPTY)
+	//	{
+	//		return hr;
+	//	}
+	//	//=============================================================================//
+
+
+	//	//=============================================================================//
+	//	//Accumulate and average background images
+	//	//=============================================================================//
+	//	for(n = nStart; n <= nStopBkGnd; n++)
+	//	{
+	//		pcurr = cvLoadImage(ImgPathNames[n].c_str()); //vpImgs[n];
+	//		if(n == nStart)
+	//		{
+	//			pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+	//			pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+	//			cvSet(pBkGnd, cvScalar(0.0));
+	//			cvSet(pBkGndTmp, cvScalar(0.0));
+	//		}
+	//		pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+	//		cvConvert(pcurr, pcurr2);
+	//		GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+	//		cvReleaseImage(&pcurr);
+	//		cvReleaseImage(&pcurr2);
+	//	}
+	//	AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+	//	cvReleaseImage(&pBkGndTmp);
+	//	cv::Mat BkGnd(pBkGnd);
+	//	//=============================================================================//
+
+	//	//=============================================================================//
+	//	// SMAP for frames
+	//	//=============================================================================//
+	//	vector<string> vszImagePathNames;
+	//	vector<cv::Mat> vMasks1;
+	//	vector<cv::Mat> vMasks2;
+	//	vector<cv::Mat> vMasks3;
+	//	vector<cv::Mat> vMasks01;
+	//	for(n = 0/*nStopBkGnd + 1*/; n < vpImgs.size()/*= nStop*/; n++)
+	//	{
+	//		vszImagePathNames.push_back(ImgPathNames[n]);
+	//	}
+	//	if(m_nHandModelIndex == 0)
+	//		m_nHandModelIndex = 1;
+	//	//GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion(vszImagePathNames, vGMMs, vMasks1, 32, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1);
+	//	//GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion(vszImagePathNames, vGMMs, vMasks2, 16, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1);
+	//	//GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion(vszImagePathNames, vGMMs, vMasks3, 4, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1);
+	//	vector<cv::Mat> vScore0_1;
+	//	vector<cv::Mat> vScore1_1;
+	//	vector<cv::Mat> vScore0_2;
+	//	vector<cv::Mat> vScore1_2;
+	//	vector<cv::Mat> vScore0_3;
+	//	vector<cv::Mat> vScore1_3;
+
+	//	GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion_with_Scores(vszImagePathNames, vGMMs, vMasks1, 32, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1, vScore0_1, vScore1_1);
+	//	GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion_with_Scores(vszImagePathNames, vGMMs, vMasks2, 16, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1, vScore0_2, vScore1_2);
+	//	GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion_with_Scores(vszImagePathNames, vGMMs, vMasks3, 4, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1, vScore0_3, vScore1_3);
+
+	//	//IplImage tmp1 = vMasks1[16].operator IplImage();
+	//	//IplImage tmp01 = vMasks01[16].operator IplImage();
+
+	//	//SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, 16, 5, "_o.jpg", &(tmp1));
+	//	//SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, 16, 5, "_ws.jpg", &(tmp01));
+
+	//	
+	//	
+	//	//=============================================================================//
+	//	// Do feature extraction for those frames with hands
+	//	//=============================================================================//
+	//	for(n = nStopBkGnd + 1; n <= nStop; n++)
+	//	{
+	//		string szImgNamen = ImgPathNames[n];
+	//		cv::Mat refmask, refmaskq, refmask2, refmask0;
+	//		//=============================================================================//
+	//		// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+	//		// stochastic matching:
+	//		// AutoLabelPart: direct label with current GMM in 3 different block sizes
+	//		// around 1.5% performance gain using AutoLabelPartSM
+	//		//=============================================================================//
+	//		//AutoLabelPartSM(szImgNamen, vGMMs, refmask0, 32);
+	//		//AutoLabelPartSM(szImgNamen, vGMMs, refmask, 16);
+	//		//AutoLabelPartSM(szImgNamen, vGMMs, refmask2, 4);
+	//		//AutoLabel_BS0(szImgNamen, vGMMs, refmask0, 32, BkGnd);
+	//		//AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+	//		//AutoLabel_BS0(szImgNamen, vGMMs, refmask2, 4, BkGnd);
+	//		refmask0 = vMasks1[n];// - nStopBkGnd - 1];
+	//		refmask = vMasks2[n];// - nStopBkGnd - 1];
+	//		refmask2 = vMasks3[n];// - nStopBkGnd - 1];
+	//		IplImage iplrefmask0 = refmask0.operator IplImage();
+	//		IplImage iplrefmask1 = refmask.operator IplImage();
+	//		IplImage iplrefmask2 = refmask2.operator IplImage();
+	//		IplImage* prefmask0 = &iplrefmask0;
+	//		IplImage* prefmask1 = &iplrefmask1;
+	//		IplImage* prefmask2 = &iplrefmask2;
+	//		SaveMATForDebug(szPathName0, "mask_32_32", szKeyName, n, 5, ".dat", prefmask0);
+	//		SaveMATForDebug(szPathName0, "mask_16_16", szKeyName, n, 5, ".dat", prefmask1);
+	//		SaveMATForDebug(szPathName0, "mask_4_4", szKeyName, n, 5, ".dat", prefmask2);
+	//		IplImage iplscore0_1 = vScore0_1[n].operator IplImage();
+	//		IplImage iplscore1_1 = vScore1_1[n].operator IplImage();
+	//		IplImage iplscore0_2 = vScore0_2[n].operator IplImage();
+	//		IplImage iplscore1_2 = vScore1_2[n].operator IplImage();
+	//		IplImage iplscore0_3 = vScore0_3[n].operator IplImage();
+	//		IplImage iplscore1_3 = vScore1_3[n].operator IplImage();
+	//		IplImage* piplscore0_1 = &iplscore0_1;
+	//		IplImage* piplscore1_1 = &iplscore1_1;
+	//		IplImage* piplscore0_2 = &iplscore0_2;
+	//		IplImage* piplscore1_2 = &iplscore1_2;
+	//		IplImage* piplscore0_3 = &iplscore0_3;
+	//		IplImage* piplscore1_3 = &iplscore1_3;
+	//		SaveMATForDebug(szPathName0, "mask_32_32_score0", szKeyName, n, 5, ".dat", piplscore0_1);
+	//		SaveMATForDebug(szPathName0, "mask_32_32_score1", szKeyName, n, 5, ".dat", piplscore1_1);
+	//		SaveMATForDebug(szPathName0, "mask_16_16_score0", szKeyName, n, 5, ".dat", piplscore0_2);
+	//		SaveMATForDebug(szPathName0, "mask_16_16_score1", szKeyName, n, 5, ".dat", piplscore1_2);
+	//		SaveMATForDebug(szPathName0, "mask_4_4_score0", szKeyName, n, 5, ".dat", piplscore0_3);
+	//		SaveMATForDebug(szPathName0, "mask_4_4_score1", szKeyName, n, 5, ".dat", piplscore1_3);
+
+
+
+	//		//AutoLabelPart(szImgNamen, vGMMs, refmask0, 32);
+	//		//AutoLabelPart(szImgNamen, vGMMs, refmask, 16);
+	//		//AutoLabelPart(szImgNamen, vGMMs, refmask2, 4);
+	//		//=============================================================================//
+
+	//		//=============================================================================//
+	//		// Then make all 3 labels consistent, that is,
+	//		// If 4x4 block some blocks are detected as skin, 
+	//		// but corresponding and adjacent 16x16 block 
+	//		// didn't have skin label, then discard it.
+	//		//=============================================================================//
+	//		iplrefmask0 = refmask0.operator IplImage();
+	//		iplrefmask = refmask.operator IplImage();
+	//		iplrefmask2 = refmask2.operator IplImage();
+	//		for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+	//		{
+	//			for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+	//			{
+	//				db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+	//				nn1 = (int)floor((double)kk1 / 2.0);
+	//				nn2 = (int)floor((double)kk2 / 2.0);
+	//				cv::Point pt0 = cv::Point(nn1, nn2);
+	//				cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+	//				cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+	//				cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+	//				cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+	//				if(cvGetReal2D(&iplrefmask, kk1, kk2))
+	//				{
+	//					if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+	//						cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+	//						cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+	//						cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+	//						cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+	//					{
+	//					}
+	//					else
+	//					{
+	//						cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+	//					}
+	//				}
+	//			}
+	//		}
+
+	//		for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+	//		{
+	//			for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+	//			{
+	//				db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+	//				nn1 = (int)floor((double)kk1 / 4.0);
+	//				nn2 = (int)floor((double)kk2 / 4.0);
+	//				cv::Point pt0 = cv::Point(nn1, nn2);
+	//				cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+	//				cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+	//				cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+	//				cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+	//				if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+	//				{
+	//					if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+	//						cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+	//						cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+	//						cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+	//						cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+	//					{
+	//					}
+	//					else
+	//					{
+	//						cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+	//					}
+	//				}
+	//			}
+	//		}
+	//		//=============================================================================//
+	//	
+	//		pcurr = vpImgs[n];
+
+	//		pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+	//		pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+	//		//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+	//		pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+	//		pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+	//		//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+	//		pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+	//		cvConvert(&iplrefmask2,pcurr2b);
+	//		//curr2b = cv::Mat(cv::abs(pcurr2b));
+	//		//curr2b.convertTo(curr2b2, CV_8UC1);
+
+	//		//=============================================================================//
+	//		// Find ROI
+	//		//=============================================================================//
+	//		//storage = cvCreateMemStorage(0);
+	//		//cvConvert(pcurr2b, pcurr2bcpy);
+	//		//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+	//		//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+	//		//vRect.clear();
+	//		//rectROI = CvRect();
+	//		////=============================================================================//
+	//		//// Compute the bounding rectangle so that ROI can be assured	
+	//		////=============================================================================//
+	//		//if(first_contour == 0) // No contour found, no hand found
+	//		//{
+	//		//	cvReleaseMemStorage(&storage);
+	//		//	cvReleaseImage(&pcurr2bcpy);
+	//		//}
+	//		//else
+	//		//{
+	//		//	rect1 = cvBoundingRect(first_contour);
+	//		//	vRect.push_back(rect1);
+	//		//	contour = first_contour->h_next;			
+	//		//	while(contour != NULL)
+	//		//	{
+	//		//		recti = cvBoundingRect(contour);
+	//		//		vRect.push_back(recti);
+	//		//		contour = contour->h_next;
+	//		//	}
+	//		//	// Now, try to merge these rectangles
+	//		//	nrectnum = (int)vRect.size();
+	//		//	// Aggolomerate clustering here:
+	//		//	vAggRect.clear();
+	//		//	nROIIndex = 0;
+	//		//	AggMerge(vRect, vAggRect, nROIIndex);
+	//		//	// Take he region with largest area
+	//		//	rectROI = vAggRect[nROIIndex];
+	//		//}
+	//		//=============================================================================//
+
+	//;
+
+	//		//=============================================================================//
+	//		// Now, combine the mask result with ROI
+	//		//=============================================================================//
+	//		cvConvert(pcurr2b, pcurr2b_tempb);
+	//		//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+	//		cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+	//		IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+	//		IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+	//		cvSet(pMask1, CV_RGB(64, 128, 64));
+	//		//cv::Mat Mask1(pMask1);
+	//		cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+	//		//cv::Mat Tmp(pTmp);
+	//		IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+	//		IplImage* piplcurrtemp = &iplcurrtemp;
+	//		cvCopy(piplcurrtemp, pMask1, pTmp);
+	//		//cvCurrImgTemp.copyTo(Mask1, Tmp);
+	//		SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+	//		cvReleaseImage(&pTmp);
+	//		cvReleaseImage(&pMask1);
+	//		//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+	//		//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+	//		cvCopy(pcurr2b, pcurr2b_tempb3);
+	//		//=============================================================================//
+
+	//		//=============================================================================//
+	//		// Morphological closing/ hole filling
+	//		//=============================================================================//
+	//		CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+	//		cvConvert(pcurr2c, pImgb);
+	//		IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+	//		cvAnd(pcurr, pImgb, pMask2);
+	//		SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+	//		cvReleaseImage(&pMask2);
+	//		cvReleaseImage(&pcurr2b_tempb);
+	//		//cvReleaseImage(&pcurr2b_tempb2);
+	//		cvReleaseImage(&pcurr2b_tempb3);
+	//		//=============================================================================//
+	//		
+	//		//=============================================================================//
+	//		// Now, try to detect center of mass of the hand region along with
+	//		// fingertip.
+	//		// However, currently, finger detection is not good in in car dataset,
+	//		// we only use the center of mass, so this part should be simplified in the 
+	//		// future if only COM is used
+	//		//=============================================================================//
+	//		hrTrackFinger = S_OK;
+	//		if(vvFeature.size() == 0)
+	//		{
+	//			hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+	//		}
+	//		else
+	//		{
+	//			hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+	//		}
+
+	//		if( S_OK == hrTrackFinger)
+	//		{
+	//			size_t nWait = vHandVanishIndices.size();
+	//			if(nWait > 0)
+	//			{
+	//				// simply discard those you cannot save
+	//				if(0 < vvFeature.size())
+	//				{
+	//					cxn_k = vvFeature[vvFeature.size()-1][0];
+	//					cyn_k = vvFeature[vvFeature.size()-1][1];
+	//					dxn_k = vvFeature[vvFeature.size()-1][2];
+	//					dyn_k = vvFeature[vvFeature.size()-1][3];
+	//					cxn = vTmp[0];
+	//					cyn = vTmp[1];
+	//					dxn = vTmp[2];
+	//					dyn = vTmp[3];					
+	//					for(nk = 1; nk <= (int)nWait; nk++)
+	//					{
+	//						r = (double)nk / ((double)nWait + 1.0);
+	//						vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+	//						vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+	//						vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+	//						vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+	//						vvFeature.push_back(vTmpTmp);
+	//					}
+	//				}
+	//				nWait = 0;
+	//				vHandVanishIndices.clear();
+	//			}
+	//			vvFeature.push_back(vTmp);
+	//		}
+	//		else
+	//		{
+	//			vHandVanishIndices.push_back(n);
+	//			if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+	//			{	
+	//				// Means the gesture ends in online FE				
+	//			}
+	//			// When it comes to the frame before the last frame,
+	//			// we just assume the point stay at the last observation 
+	//			// all the time
+	//			//!!!! Can be wrong!!!!
+	//			else if(n == nStop - 1)
+	//			{
+	//				for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+	//				{
+	//					if(vTmp.size() == 4)
+	//					{
+	//						vvFeature.push_back(vTmp);
+	//					}
+	//				}
+	//				vHandVanishIndices.clear();
+	//			}
+	//			else if(n == nStop)
+	//			{
+	//				// Do nothing, coz nothing is observed 
+	//				vHandVanishIndices.clear();
+	//			}
+	//			cvCurrImgTemp.release();
+	//		}
+	//		refmask0.release();
+	//		refmask.release();
+	//		refmask2.release();
+	//		//cvReleaseImage(&pcurr);
+	//		cvReleaseImage(&pcurr2c);
+	//		cvReleaseImage(&pcurr2b);
+	//		//cvReleaseImage(&pcurr2bcpy);
+	//		cvReleaseImage(&pImgb);
+	//		//cvReleaseMemStorage(&storage);
+	//		//cvReleaseImage(&pcurr2bcpy);
+
+	//	}
+	//	//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+	//	//{
+	//	//	IplImage* pimg = vpImgs[nn];
+	//	//	cvReleaseImage(&pimg);
+	//	//	pimg = NULL;
+	//	//}
+	//	cvReleaseImage(&pBkGnd);
+	//	// Write features
+	//	if(0 < vvFeature.size())
+	//	{
+	//		HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+	//		if(hrlast == S_OK)
+	//		{
+	//			vFEN[nID].IsCreated = true;
+	//			string szOutFileName001, szOutFileName002;
+	//			MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+	//			MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+	//			WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+	//			//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+	//			//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+	//			size_t nSizet = vvFeature.size() - 1;
+	//			nSizet *= 666666;
+	//			htVN[szKeyName][0].nStart = 0;
+	//			htVN[szKeyName][0].nStop = (int)nSizet;
+	//			htVN[szKeyName][0].szName = szLabelName;
+	//		}
+	//		else if(hrlast == ERROR_INVALID_DATA)
+	//		{
+	//			vFEN[nID].IsCreated = false;
+	//			ofstream feout;
+	//			feout.open(szErrLog.c_str(), ios_base::app);
+	//			feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+	//			cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+	//			feout.close();
+	//		}
+	//		else
+	//		{
+	//			vFEN[nID].IsCreated = false;
+	//			ofstream feout;
+	//			feout.open(szErrLog.c_str(), ios_base::app);
+	//			feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+	//			cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+	//			feout.close();
+	//		}
+	//	}
+	//	else
+	//	{
+	//		vFEN[nID].IsCreated = false;
+	//		ofstream feout;
+	//		feout.open(szErrLog.c_str(), ios_base::app);
+	//		feout<<szOutFeatureFile<<" is not created!\n";
+	//		cerr<<szOutFeatureFile<<" is not created!\n";
+	//		feout.close();
+	//	}
+	//	return hr;
+	//}
+
+	HRESULT OfflineFEImgSeq2_2_3_part_BS0_Fusion(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs, vector<GMM>& vFusionGMMs, bool bFrameBatch, int nAdaptMode)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		cout<<"Begin Processing Feature file "<<szKeyName<<endl;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		for(n = nStart; n <= nStopBkGnd; n++)
+		{
+			pcurr = cvLoadImage(ImgPathNames[n].c_str()); //vpImgs[n];
+			if(n == nStart)
+			{
+				pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				cvSet(pBkGnd, cvScalar(0.0));
+				cvSet(pBkGndTmp, cvScalar(0.0));
+			}
+			pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+			cvConvert(pcurr, pcurr2);
+			GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+			cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2);
+		}
+		AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		cvReleaseImage(&pBkGndTmp);
+		cv::Mat BkGnd(pBkGnd);
+		//=============================================================================//
+
+		//=============================================================================//
+		// SMAP for frames
+		//=============================================================================//
+		vector<string> vszImagePathNames;
+		vector<cv::Mat> vMasks1;
+		vector<cv::Mat> vMasks2;
+		vector<cv::Mat> vMasks3;
+		vector<cv::Mat> vMasks01;
+		for(n = 0/*nStopBkGnd + 1*/; n < vpImgs.size()/*= nStop*/; n++)
+		{
+			vszImagePathNames.push_back(ImgPathNames[n]);
+		}
+		if(m_nHandModelIndex == 0)
+			m_nHandModelIndex = 1;
+		//GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion(vszImagePathNames, vGMMs, vMasks1, 32, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1);
+		//GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion(vszImagePathNames, vGMMs, vMasks2, 16, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1);
+		//GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion(vszImagePathNames, vGMMs, vMasks3, 4, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1);
+		vector<cv::Mat> vScore0_1;
+		vector<cv::Mat> vScore1_1;
+		vector<cv::Mat> vScore0_2;
+		vector<cv::Mat> vScore1_2;
+		vector<cv::Mat> vScore0_3;
+		vector<cv::Mat> vScore1_3;
+
+		GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion_with_Scores(vszImagePathNames, vGMMs, vMasks1, 32, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1, vScore0_1, vScore1_1);
+		GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion_with_Scores(vszImagePathNames, vGMMs, vMasks2, 16, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1, vScore0_2, vScore1_2);
+		GMMAdaptTool::AutoLabelHTKMAP_BS0_Fusion_with_Scores(vszImagePathNames, vGMMs, vMasks3, 4, m_nHandModelIndex, m_szGMMPath, BkGnd, vFusionGMMs, bFrameBatch, nAdaptMode, nStopBkGnd + 1, nStop + 1, vScore0_3, vScore1_3);
+
+		//IplImage tmp1 = vMasks1[16].operator IplImage();
+		//IplImage tmp01 = vMasks01[16].operator IplImage();
+
+		//SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, 16, 5, "_o.jpg", &(tmp1));
+		//SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, 16, 5, "_ws.jpg", &(tmp01));
+
+		
+		
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			//cout<<"Doing frame "<<n<<endl;
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask2, 4);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask0, 32, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask2, 4, BkGnd);
+			refmask0 = vMasks1[n];// - nStopBkGnd - 1];
+			refmask = vMasks2[n];// - nStopBkGnd - 1];
+			refmask2 = vMasks3[n];// - nStopBkGnd - 1];
+			IplImage iplrefmask0 = refmask0.operator IplImage();
+			IplImage iplrefmask1 = refmask.operator IplImage();
+			IplImage iplrefmask2 = refmask2.operator IplImage();
+			IplImage* prefmask0 = &iplrefmask0;
+			IplImage* prefmask1 = &iplrefmask1;
+			IplImage* prefmask2 = &iplrefmask2;
+			SaveMATForDebug(szPathName0, "mask_32_32", szKeyName, n, 5, ".dat", prefmask0);
+			SaveMATForDebug(szPathName0, "mask_16_16", szKeyName, n, 5, ".dat", prefmask1);
+			SaveMATForDebug(szPathName0, "mask_4_4", szKeyName, n, 5, ".dat", prefmask2);
+			IplImage iplscore0_1 = vScore0_1[n].operator IplImage();
+			IplImage iplscore1_1 = vScore1_1[n].operator IplImage();
+			IplImage iplscore0_2 = vScore0_2[n].operator IplImage();
+			IplImage iplscore1_2 = vScore1_2[n].operator IplImage();
+			IplImage iplscore0_3 = vScore0_3[n].operator IplImage();
+			IplImage iplscore1_3 = vScore1_3[n].operator IplImage();
+			IplImage* piplscore0_1 = &iplscore0_1;
+			IplImage* piplscore1_1 = &iplscore1_1;
+			IplImage* piplscore0_2 = &iplscore0_2;
+			IplImage* piplscore1_2 = &iplscore1_2;
+			IplImage* piplscore0_3 = &iplscore0_3;
+			IplImage* piplscore1_3 = &iplscore1_3;
+			SaveMATForDebug(szPathName0, "mask_32_32_score0", szKeyName, n, 5, ".dat", piplscore0_1);
+			SaveMATForDebug(szPathName0, "mask_32_32_score1", szKeyName, n, 5, ".dat", piplscore1_1);
+			SaveMATForDebug(szPathName0, "mask_16_16_score0", szKeyName, n, 5, ".dat", piplscore0_2);
+			SaveMATForDebug(szPathName0, "mask_16_16_score1", szKeyName, n, 5, ".dat", piplscore1_2);
+			SaveMATForDebug(szPathName0, "mask_4_4_score0", szKeyName, n, 5, ".dat", piplscore0_3);
+			SaveMATForDebug(szPathName0, "mask_4_4_score1", szKeyName, n, 5, ".dat", piplscore1_3);
+
+
+
+			//AutoLabelPart(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask2, 4);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+
+			for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 4.0);
+					nn2 = (int)floor((double)kk2 / 4.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			vector<double> comvec;
+			COMPoints(refmask2, comvec);
+			vvFeature.push_back(comvec);
+			//=============================================================================//
+		
+			//pcurr = vpImgs[n];
+
+			//pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			////pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			////pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			//cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			//cvConvert(pcurr2b, pcurr2b_tempb);
+			////cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			//cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			//IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			//IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			//cvSet(pMask1, CV_RGB(64, 128, 64));
+			////cv::Mat Mask1(pMask1);
+			//cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			////cv::Mat Tmp(pTmp);
+			//IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			//IplImage* piplcurrtemp = &iplcurrtemp;
+			//cvCopy(piplcurrtemp, pMask1, pTmp);
+			////cvCurrImgTemp.copyTo(Mask1, Tmp);
+			//SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			//cvReleaseImage(&pTmp);
+			//cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			//cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			//CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			//cvConvert(pcurr2c, pImgb);
+			//IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//cvAnd(pcurr, pImgb, pMask2);
+			//SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			//cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			//hrTrackFinger = S_OK;
+			//if(vvFeature.size() == 0)
+			//{
+			//	hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			//}
+			//else
+			//{
+			//	hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			//}
+
+			//if( S_OK == hrTrackFinger)
+			//{
+			//	size_t nWait = vHandVanishIndices.size();
+			//	if(nWait > 0)
+			//	{
+			//		// simply discard those you cannot save
+			//		if(0 < vvFeature.size())
+			//		{
+			//			cxn_k = vvFeature[vvFeature.size()-1][0];
+			//			cyn_k = vvFeature[vvFeature.size()-1][1];
+			//			dxn_k = vvFeature[vvFeature.size()-1][2];
+			//			dyn_k = vvFeature[vvFeature.size()-1][3];
+			//			cxn = vTmp[0];
+			//			cyn = vTmp[1];
+			//			dxn = vTmp[2];
+			//			dyn = vTmp[3];					
+			//			for(nk = 1; nk <= (int)nWait; nk++)
+			//			{
+			//				r = (double)nk / ((double)nWait + 1.0);
+			//				vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+			//				vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+			//				vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+			//				vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+			//				vvFeature.push_back(vTmpTmp);
+			//			}
+			//		}
+			//		nWait = 0;
+			//		vHandVanishIndices.clear();
+			//	}
+			//	vvFeature.push_back(vTmp);
+			//}
+			//else
+			//{
+			//	vHandVanishIndices.push_back(n);
+			//	if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+			//	{	
+			//		// Means the gesture ends in online FE				
+			//	}
+			//	// When it comes to the frame before the last frame,
+			//	// we just assume the point stay at the last observation 
+			//	// all the time
+			//	//!!!! Can be wrong!!!!
+			//	else if(n == nStop - 1)
+			//	{
+			//		for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+			//		{
+			//			if(vTmp.size() == 4)
+			//			{
+			//				vvFeature.push_back(vTmp);
+			//			}
+			//		}
+			//		vHandVanishIndices.clear();
+			//	}
+			//	else if(n == nStop)
+			//	{
+			//		// Do nothing, coz nothing is observed 
+			//		vHandVanishIndices.clear();
+			//	}
+			//	cvCurrImgTemp.release();
+			//}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		cvReleaseImage(&pBkGnd);
+
+		if(0 < vvFeature.size())
+		{
+			vector< vector<double> > vvFeature2 = vvFeature;
+			vector<int> lastcom(vvFeature.size(), 0);
+			vector<int> nextcom(vvFeature.size(), 0);
+			int lastcomtmp = -1;
+			int nextcomtmp = -1;
+			for(int nn1 = 0; nn1 < (int)vvFeature.size(); nn1++)
+			{
+				if(vvFeature[nn1][0] > 0 && vvFeature[nn1][1] > 0)
+					lastcomtmp = nn1;
+				lastcom[nn1] = lastcomtmp;
+			}
+
+			for(int nn1 = (int)vvFeature.size() - 1; nn1 >=0 ; nn1--)
+			{
+				if(vvFeature[nn1][0] > 0 && vvFeature[nn1][1] > 0)
+					nextcomtmp = (int)nn1;
+				nextcom[nn1] = nextcomtmp;
+			}
+			// interpolate COM
+			for(int nn1 = 0; nn1 < (int)vvFeature.size(); nn1++)
+			{
+				if(lastcom[nn1] >= 0 && nextcom[nn1] >= 0 && nextcom[nn1] != lastcom[nn1])
+				{
+					double distcomtmpd = (double)(nextcom[nn1] - lastcom[nn1]);
+					double distcomtmpn = (double)(nn1 - lastcom[nn1]);
+					vector<double> distcomtmpv(2, 0.0);
+					distcomtmpv[0] = vvFeature[nextcom[nn1]][0] - vvFeature[lastcom[nn1]][0];
+					distcomtmpv[1] = vvFeature[nextcom[nn1]][1] - vvFeature[lastcom[nn1]][1];
+					vvFeature2[nn1][0] = vvFeature[nextcom[nn1]][0] + distcomtmpv[0]  * distcomtmpn / distcomtmpd;	
+					vvFeature2[nn1][1] = vvFeature[nextcom[nn1]][1] + distcomtmpv[1]  * distcomtmpn / distcomtmpd;	
+				}
+				else if(lastcom[nn1] < 0 && nextcom[nn1] >= 0)
+				{
+					vvFeature2[nn1][0] = vvFeature[nextcom[nn1]][0];
+					vvFeature2[nn1][1] = vvFeature[nextcom[nn1]][1];
+				}
+				else if(lastcom[nn1] >= 0 && nextcom[nn1] < 0)
+				{
+					vvFeature2[nn1][0] = vvFeature[lastcom[nn1]][0];
+					vvFeature2[nn1][1] = vvFeature[lastcom[nn1]][1];
+				}
+			}
+			//cout<<"ready to write HTK feature\n";
+			HRESULT hrlast = WriteFeatureAsHTKMFCC(vvFeature2, szOutFeatureFile_uhalf);
+			//cout<<"HTK feature written\n";
+			if(hrlast == S_OK)
+			{
+				//cout<<"before vFEN[nID].IsCreated = true;"<<endl;
+				vFEN[nID].IsCreated = true;
+				//cout<<"before string szOutFileName001, szOutFileName002;"<<endl;
+				string szOutFileName001, szOutFileName002;
+				//cout<<"before MakeDebugOutputName(szPathName0, \"COM\", szKeyName, \".jpg\", szOutFileName001);"<<endl;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				//cout<<"before writing trajectory to jpg\n";
+				WriteFeatureAsDEBUGTRAJ(vvFeature2, szOutFileName001);
+				//cout<<"after writing trajectory to jpg\n";
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		//cvReleaseImage(&pBkGnd);
+		// Write features
+
+
+		//if(0 < vvFeature.size())
+		//{
+		//	HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+		//	if(hrlast == S_OK)
+		//	{
+		//		vFEN[nID].IsCreated = true;
+		//		string szOutFileName001, szOutFileName002;
+		//		MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+		//		MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+		//		WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+		//		//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+		//		//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+		//		size_t nSizet = vvFeature.size() - 1;
+		//		nSizet *= 666666;
+		//		htVN[szKeyName][0].nStart = 0;
+		//		htVN[szKeyName][0].nStop = (int)nSizet;
+		//		htVN[szKeyName][0].szName = szLabelName;
+		//	}
+		//	else if(hrlast == ERROR_INVALID_DATA)
+		//	{
+		//		vFEN[nID].IsCreated = false;
+		//		ofstream feout;
+		//		feout.open(szErrLog.c_str(), ios_base::app);
+		//		feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+		//		cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+		//		feout.close();
+		//	}
+		//	else
+		//	{
+		//		vFEN[nID].IsCreated = false;
+		//		ofstream feout;
+		//		feout.open(szErrLog.c_str(), ios_base::app);
+		//		feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+		//		cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+		//		feout.close();
+		//	}
+		//}
+		//else
+		//{
+		//	vFEN[nID].IsCreated = false;
+		//	ofstream feout;
+		//	feout.open(szErrLog.c_str(), ios_base::app);
+		//	feout<<szOutFeatureFile<<" is not created!\n";
+		//	cerr<<szOutFeatureFile<<" is not created!\n";
+		//	feout.close();
+		//}
+		//cout<<"Finish properly\n";
+		return hr;
+	}
+
+
+	HRESULT OfflineFEImgSeq2_2_3_part_BS0_SMAPPerFrame(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		for(n = nStart; n <= nStopBkGnd; n++)
+		{
+			pcurr = cvLoadImage(ImgPathNames[n].c_str()); //vpImgs[n];
+			if(n == nStart)
+			{
+				pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				cvSet(pBkGnd, cvScalar(0.0));
+				cvSet(pBkGndTmp, cvScalar(0.0));
+			}
+			pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+			cvConvert(pcurr, pcurr2);
+			GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+			cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2);
+		}
+		AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		cvReleaseImage(&pBkGndTmp);
+		cv::Mat BkGnd(pBkGnd);
+		//=============================================================================//
+
+		//=============================================================================//
+		// SMAP for frames
+		//=============================================================================//
+		vector<string> vszImagePathNames;
+		vector<cv::Mat> vMasks1;
+		vector<cv::Mat> vMasks2;
+		vector<cv::Mat> vMasks3;
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			vszImagePathNames.push_back(ImgPathNames[n]);
+		}
+		if(m_nHandModelIndex == 0)
+			m_nHandModelIndex = 1;
+		GMMAdaptTool::AutoLabelSMAPPerFrame_BS0(vszImagePathNames, vGMMs, vMasks1, 32, m_nHandModelIndex, m_szGMMPath, BkGnd);
+		GMMAdaptTool::AutoLabelSMAPPerFrame_BS0(vszImagePathNames, vGMMs, vMasks2, 16, m_nHandModelIndex, m_szGMMPath, BkGnd);
+		GMMAdaptTool::AutoLabelSMAPPerFrame_BS0(vszImagePathNames, vGMMs, vMasks3, 4, m_nHandModelIndex, m_szGMMPath, BkGnd);
+		
+		
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask2, 4);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask0, 32, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask2, 4, BkGnd);
+			refmask0 = vMasks1[n - nStopBkGnd - 1];
+			refmask = vMasks2[n - nStopBkGnd - 1];
+			refmask2 = vMasks3[n - nStopBkGnd - 1];
+
+			//AutoLabelPart(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask2, 4);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+
+			for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 4.0);
+					nn2 = (int)floor((double)kk2 / 4.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			//=============================================================================//
+		
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrtemp = &iplcurrtemp;
+			cvCopy(piplcurrtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+				cvCurrImgTemp.release();
+			}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(hrlast == S_OK)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		return hr;
+	}
+	
+	HRESULT OfflineFEImgSeq2_2_3_part_BS0_SMAPASeq(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		for(n = nStart; n <= nStopBkGnd; n++)
+		{
+			pcurr = cvLoadImage(ImgPathNames[n].c_str()); //vpImgs[n];
+			if(n == nStart)
+			{
+				pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				cvSet(pBkGnd, cvScalar(0.0));
+				cvSet(pBkGndTmp, cvScalar(0.0));
+			}
+			pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+			cvConvert(pcurr, pcurr2);
+			GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+			cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2);
+		}
+		AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		cvReleaseImage(&pBkGndTmp);
+		cv::Mat BkGnd(pBkGnd);
+		//=============================================================================//
+
+		//=============================================================================//
+		// SMAP for frames
+		//=============================================================================//
+		vector<string> vszImagePathNames;
+		vector<cv::Mat> vMasks1;
+		vector<cv::Mat> vMasks2;
+		vector<cv::Mat> vMasks3;
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			vszImagePathNames.push_back(ImgPathNames[n]);
+		}
+		if(m_nHandModelIndex == 0)
+			m_nHandModelIndex = 1;
+		GMMAdaptTool::AutoLabelSMAPASeq_BS0(vszImagePathNames, vGMMs, vMasks1, 32, m_nHandModelIndex, m_szGMMPath, BkGnd);
+		GMMAdaptTool::AutoLabelSMAPASeq_BS0(vszImagePathNames, vGMMs, vMasks2, 16, m_nHandModelIndex, m_szGMMPath, BkGnd);
+		GMMAdaptTool::AutoLabelSMAPASeq_BS0(vszImagePathNames, vGMMs, vMasks3, 4, m_nHandModelIndex, m_szGMMPath, BkGnd);
+		
+		
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask2, 4);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask0, 32, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vGMMs, refmask2, 4, BkGnd);
+			refmask0 = vMasks1[n - nStopBkGnd - 1];
+			refmask = vMasks2[n - nStopBkGnd - 1];
+			refmask2 = vMasks3[n - nStopBkGnd - 1];
+
+			//AutoLabelPart(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask2, 4);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+
+			for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 4.0);
+					nn2 = (int)floor((double)kk2 / 4.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			//=============================================================================//
+		
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrtemp = &iplcurrtemp;
+			cvCopy(piplcurrtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+				cvCurrImgTemp.release();
+			}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(hrlast == S_OK)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		return hr;
+	}
+	
+
+	HRESULT OfflineFEImgSeq2_2_3_part_BS0_Rough(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector< GMM >& vGMMs)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		for(n = nStart; n <= nStopBkGnd; n++)
+		{
+			pcurr = cvLoadImage(ImgPathNames[n].c_str()); //vpImgs[n];
+			if(n == nStart)
+			{
+				pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				cvSet(pBkGnd, cvScalar(0.0));
+				cvSet(pBkGndTmp, cvScalar(0.0));
+			}
+			pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+			cvConvert(pcurr, pcurr2);
+			GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+			cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2);
+		}
+		AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		cvReleaseImage(&pBkGndTmp);
+		cv::Mat BkGnd(pBkGnd);
+		//=============================================================================//
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+			AutoLabel_BS0(szImgNamen, vGMMs, refmask0, 32, BkGnd);
+			AutoLabel_BS0(szImgNamen, vGMMs, refmask, 16, BkGnd);
+			//AutoLabel_BS0(szImgNamen, vvvDecisionTable, refmask2, 4, BkGnd);
+
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			//iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			cv::resize(refmask, refmask2, cv::Size(refmask.cols * 4, refmask.rows * 4), 0, 0, INTER_NEAREST); 
+			iplrefmask2 = refmask2.operator IplImage();
+			//=============================================================================//
+		
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrtemp = &iplcurrtemp;
+			cvCopy(piplcurrtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+				cvCurrImgTemp.release();
+			}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(hrlast == S_OK)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		return hr;
+	}
+
+	HRESULT OfflineFEImgSeq2_2_3_part_BS0_Table(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, bool*** vvvDecisionTable)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		for(n = nStart; n <= nStopBkGnd; n++)
+		{
+			pcurr = cvLoadImage(ImgPathNames[n].c_str()); //vpImgs[n];
+			if(n == nStart)
+			{
+				pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+				cvSet(pBkGnd, cvScalar(0.0));
+				cvSet(pBkGndTmp, cvScalar(0.0));
+			}
+			pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, pcurr->nChannels);
+			cvConvert(pcurr, pcurr2);
+			GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+			cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2);
+		}
+		AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		cvReleaseImage(&pBkGndTmp);
+		cv::Mat BkGnd(pBkGnd);
+		//=============================================================================//
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+
+
+
+#ifdef _MSC_VER
+			DWORD dw1 = ::timeGetTime();
+#endif
+			Approx_AutoLabel_BS0(szImgNamen, vvvDecisionTable, refmask0, 32, BkGnd);
+#ifdef _MSC_VER
+			DWORD dw2 = ::timeGetTime();
+#endif
+			Approx_AutoLabel_BS0(szImgNamen, vvvDecisionTable, refmask, 16, BkGnd);
+#ifdef _MSC_VER
+			DWORD dw3 = ::timeGetTime();
+#endif
+			Approx_AutoLabel_BS0(szImgNamen, vvvDecisionTable, refmask2, 4, BkGnd);
+#ifdef _MSC_VER
+			DWORD dw4 = ::timeGetTime();
+			cout<<"Scale 32*32 takes "<<dw2-dw1<<" ms"<<endl;
+			cout<<"Scale 16*16 takes "<<dw3-dw2<<" ms"<<endl;
+			cout<<"Scale 4*4 takes "<<dw4-dw3<<" ms"<<endl;
+#endif
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+
+			for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 4.0);
+					nn2 = (int)floor((double)kk2 / 4.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			//=============================================================================//
+		
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrtemp = &iplcurrtemp;
+			cvCopy(piplcurrtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+				cvCurrImgTemp.release();
+			}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(hrlast == S_OK)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		return hr;
+	}
+
+
+	HRESULT OfflineFEImgSeq2_2_3_with_MCD(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		hr = GMMAdaptTool::TestOnlineBkgndFrames1Dot2(vpImgs, nStopBkGnd, nStop);
+		if(hr == ERROR_EMPTY)
+		{
+			return hr;
+		}
+		//=============================================================================//
+
+
+		//=============================================================================//
+		//Accumulate and average background images
+		//=============================================================================//
+		//for(n = nStart; n <= nStopBkGnd; n++)
+		//{
+		//	pcurr = vpImgs[n];
+		//	if(n == nStart)
+		//	{
+		//		pBkGnd = cvCreateImage	(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+		//		pBkGndTmp = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+		//		cvSet(pBkGnd, cvScalar(0.0));
+		//		cvSet(pBkGndTmp, cvScalar(0.0));
+		//	}
+		//	pcurr2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+		//	cvConvert(pcurr, pcurr2);
+		//	GMMAdaptTool::AccBackground((const CvArr*)pcurr, (CvArr*&)pBkGndTmp);
+		//	cvReleaseImage(&pcurr);
+		//	cvReleaseImage(&pcurr2);
+		//}
+		//AvgBackground(pBkGndTmp, (CvArr*&)pBkGnd, nStopBkGnd - nStart + 1);
+		//cvReleaseImage(&pBkGndTmp);
+		//=============================================================================//
+
+		//=============================================================================//
+		// Do feature extraction for those frames with hands
+		//=============================================================================//
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			//=============================================================================//
+			// AutoLabelPartSM: label image in 3 different block sizes with feature space 
+			// stochastic matching:
+			// AutoLabelPart: direct label with current GMM in 3 different block sizes
+			// around 1.5% performance gain using AutoLabelPartSM
+			//=============================================================================//
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPartSM(szImgNamen, vGMMs, refmask2, 4);
+			AutoLabelRGBOnly(szImgNamen, vGMMs, refmask0, 32);
+			AutoLabelRGBOnly(szImgNamen, vGMMs, refmask, 16);
+			AutoLabelRGBOnly(szImgNamen, vGMMs, refmask2, 4);
+
+			//AutoLabelPart(szImgNamen, vGMMs, refmask0, 32);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask, 16);
+			//AutoLabelPart(szImgNamen, vGMMs, refmask2, 4);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Then make all 3 labels consistent, that is,
+			// If 4x4 block some blocks are detected as skin, 
+			// but corresponding and adjacent 16x16 block 
+			// didn't have skin label, then discard it.
+			//=============================================================================//
+			iplrefmask0 = refmask0.operator IplImage();
+			iplrefmask = refmask.operator IplImage();
+			iplrefmask2 = refmask2.operator IplImage();
+			for(kk1 = 0; kk1 < iplrefmask.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 2.0);
+					nn2 = (int)floor((double)kk2 / 2.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask0.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask0.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask0, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask0, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask0, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask0, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask0, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+
+			for(kk1 = 0; kk1 < iplrefmask2.height; kk1++)
+			{
+				for(kk2 = 0; kk2 < iplrefmask2.width; kk2++)
+				{
+					db1 = cvGetReal2D(&iplrefmask2, kk1, kk2);
+					nn1 = (int)floor((double)kk1 / 4.0);
+					nn2 = (int)floor((double)kk2 / 4.0);
+					cv::Point pt0 = cv::Point(nn1, nn2);
+					cv::Point pt1 = cv::Point(max(0, nn1-1), nn2);
+					cv::Point pt2 = cv::Point(nn1, max(0, nn2-1));
+					cv::Point pt3 = cv::Point(nn1, min(iplrefmask.width - 1, nn2 + 1));
+					cv::Point pt4 = cv::Point(min(iplrefmask.height - 1, nn1 + 1), nn2);
+
+					if(cvGetReal2D(&iplrefmask2, kk1, kk2))
+					{
+						if(cvGetReal2D(&iplrefmask, pt0.x, pt0.y) + 
+							cvGetReal2D(&iplrefmask, pt1.x, pt1.y) + 
+							cvGetReal2D(&iplrefmask, pt2.x, pt2.y) + 
+							cvGetReal2D(&iplrefmask, pt3.x, pt3.y) + 
+							cvGetReal2D(&iplrefmask, pt4.x, pt4.y))
+						{
+						}
+						else
+						{
+							cvSetReal2D(&iplrefmask2, kk1, kk2, 0.0);
+						}
+					}
+				}
+			}
+			//=============================================================================//
+		
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrtemp = &iplcurrtemp;
+			cvCopy(piplcurrtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+				cvCurrImgTemp.release();
+			}
+			refmask0.release();
+			refmask.release();
+			refmask2.release();
+
+			//cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//for(size_t nn = 0; nn < vpImgs.size(); nn++)
+		//{
+		//	IplImage* pimg = vpImgs[nn];
+		//	cvReleaseImage(&pimg);
+		//	pimg = NULL;
+		//}
+		//cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			vector< vector<double> > vvAdjustedFeature;
+			CheckTrajValidityBYU2D(vvFeature, vvAdjustedFeature);
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvAdjustedFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(hrlast == S_OK)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+MYRETURN:
+		return hr;
+	}
+
+
+
+	HRESULT OfflineFEImgSeq2_2_3_part_cheat(DWORD nID, hash_map<int, FENode>& vFEN, vector<IplImage*>& vpImgs, hash_map<string, vector<VideoNode> >& htVN, vector<string>& ImgPathNames, vector<GMM>& vGMMs, LoadJPGLabelInfo& lab)
+	{
+	#ifdef _WIN32
+		string delim = "\\";
+	#else
+		string delim = "/";
+	#endif
+		string szOutFeatureFile = vFEN[nID].szOutFeatureFile;
+		string szOutFeatureFile_uhalf = vFEN[nID].szOutFeatureFile_uhalf;
+		string szOutFeatureFile_lhalf = vFEN[nID].szOutFeatureFile_lhalf;
+		string szMLFName = vFEN[nID].szMLFName;
+		string szLabelName = vFEN[nID].szLabelName;
+		string szKeyName = vFEN[nID].szKeyName; 
+		string szErrLog = vFEN[nID].szErrLog;
+		size_t noutfeslash = szOutFeatureFile.find_last_of(delim);
+		string szPathName0 = szOutFeatureFile.substr(0, noutfeslash);
+
+		IplImage* pcurr = 0;
+		IplImage* pBkGndTmp = 0;
+		IplImage* pBkGnd = 0;
+		IplImage* pRef1 = 0;
+		IplImage* pRef2 = 0;
+		IplImage* pcurr2 = 0;
+		IplImage* pcurr2c = 0;
+		IplImage* pcurr2b = 0;
+		//IplImage* pcurr2bcpy = 0;
+		IplImage* pcurr2b_tempb = 0;
+		//IplImage* pcurr2b_tempb2 = 0;
+		IplImage* pcurr2b_tempb3 = 0;
+		IplImage* pImgb = 0;
+		IplImage* pImgbs = 0;
+		IplImage iplrefmask0;
+		IplImage iplrefmask;
+		////IplImage iplrefmask2;
+		CvMemStorage* storage = 0;
+		CvSeq* first_contour = 0;
+		CvSeq* contour = 0;
+		cv::Mat curr2b;
+		cv::Mat curr2b2;
+		vector< vector<double> > vvFeature;
+		vector<double> vTmpTmp(4);
+		vector<double> vTmp;
+		vector<int> vHandVanishIndices;
+		vector<CvRect> vRect;
+		vector<CvRect> vAggRect;
+		CvRect rectROI;
+		CvRect rect1;
+		CvRect recti;
+		IplImage* pImgbSWM = 0;
+		IplImage* pSWMask = 0;
+
+		HRESULT hr = S_OK;
+		HRESULT hrTrackFinger = S_OK;
+		int nStopBkGnd = 0;
+		int nStart = 0;
+		int nStop = (int)vpImgs.size() - 1;
+		int n = 0;
+		int kk1 = 0;
+		int kk2 = 0;
+		int nn1 = 0;
+		int nn2 = 0;
+		int nk = 0;
+		int nrectnum = 0;
+		int nROIIndex = 0;
+		
+		
+		double db1 = 0.0;
+		double cxn_k = 0.0;
+		double cyn_k = 0.0;
+		double dxn_k = 0.0;
+		double dyn_k = 0.0;
+		double cxn = 0.0;
+		double cyn = 0.0;;
+		double dxn = 0.0;
+		double dyn = 0.0;					
+		double r = 0.0;
+		//=============================================================================//
+		// Begin feature extraction
+		//=============================================================================//
+		if(nStop <= 0)
+		{
+			return ERROR_EMPTY;
+		}
+		//=============================================================================//
+
+		//=============================================================================//
+		// Check where hand is inside the frame and outside 
+		//=============================================================================//
+		for(size_t nn = 0; nn < ImgPathNames.size(); nn++)
+		{
+			if(lab.m_hJPGLavelInfo.find(ImgPathNames[nn]) == lab.m_hJPGLavelInfo.end())
+			{
+			}
+			else
+			{
+				if(lab.m_hJPGLavelInfo[ImgPathNames[nn]].m_nSkinCount)
+				{
+					nStopBkGnd = nn - 1;
+					break;
+				}
+			}
+		}
+		for(size_t nn = ImgPathNames.size() - 1; nn >= 0; nn--)
+		{
+			if(lab.m_hJPGLavelInfo.find(ImgPathNames[nn]) == lab.m_hJPGLavelInfo.end())
+			{
+			}
+			else
+			{
+				if(lab.m_hJPGLavelInfo[ImgPathNames[nn]].m_nSkinCount)
+				{
+					nStop = nn;
+					break;
+				}
+			}
+		}
+		for(n = nStart; n <= nStopBkGnd; n++)
+		{
+			pcurr = vpImgs[n];
+			cvReleaseImage(&pcurr);
+			vpImgs[n] = NULL;
+		}
+		for(n = nStop + 1; n < vpImgs.size(); n++)
+		{
+			pcurr = vpImgs[n];
+			cvReleaseImage(&pcurr);
+			vpImgs[n] = NULL;
+		}
+		for(n = nStopBkGnd + 1; n <= nStop; n++)
+		{
+			string szImgNamen = ImgPathNames[n];
+			// Load label:
+			int nBW = lab.m_hJPGLavelInfo[szImgNamen].m_nBlockWidth;
+			int nBH = lab.m_hJPGLavelInfo[szImgNamen].m_nBlockHeight;
+			cv::Mat refmask00(nBH, nBW, CV_8UC1);
+			refmask00.setTo(cv::Scalar(0,0,0,0));
+			for(int kk = 0; kk < nBH; kk++)
+			{
+				for(int ll = 0; ll < nBW; ll++)
+				{
+					if(lab.m_hJPGLavelInfo[szImgNamen].m_ppnLabel[kk][ll] == 1)
+					{
+						refmask00.at<uchar>(kk, ll) = 255;
+					}
+				}
+			}
+
+			cv::Mat refmask, refmaskq, refmask2, refmask0;
+			cv::resize(refmask00, refmask2, cvSize(nBW*4, nBH*4), 0, 0, cv::INTER_NEAREST);
+		
+			pcurr = vpImgs[n];
+
+			pImgb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			//pcurr2bcpy = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2c = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			pcurr2b_tempb = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			//pcurr2b_tempb2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			pcurr2b_tempb3 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_32F, 1);
+			IplImage iplrefmask2 = refmask2.operator IplImage();
+			cvConvert(&iplrefmask2,pcurr2b);
+			//curr2b = cv::Mat(cv::abs(pcurr2b));
+			//curr2b.convertTo(curr2b2, CV_8UC1);
+
+			//=============================================================================//
+			// Find ROI
+			//=============================================================================//
+			//storage = cvCreateMemStorage(0);
+			//cvConvert(pcurr2b, pcurr2bcpy);
+			//cvFindContours( pcurr2bcpy, storage, &first_contour, sizeof(CvContour), 
+			//				CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
+			//vRect.clear();
+			//rectROI = CvRect();
+			////=============================================================================//
+			//// Compute the bounding rectangle so that ROI can be assured	
+			////=============================================================================//
+			//if(first_contour == 0) // No contour found, no hand found
+			//{
+			//	cvReleaseMemStorage(&storage);
+			//	cvReleaseImage(&pcurr2bcpy);
+			//}
+			//else
+			//{
+			//	rect1 = cvBoundingRect(first_contour);
+			//	vRect.push_back(rect1);
+			//	contour = first_contour->h_next;			
+			//	while(contour != NULL)
+			//	{
+			//		recti = cvBoundingRect(contour);
+			//		vRect.push_back(recti);
+			//		contour = contour->h_next;
+			//	}
+			//	// Now, try to merge these rectangles
+			//	nrectnum = (int)vRect.size();
+			//	// Aggolomerate clustering here:
+			//	vAggRect.clear();
+			//	nROIIndex = 0;
+			//	AggMerge(vRect, vAggRect, nROIIndex);
+			//	// Take he region with largest area
+			//	rectROI = vAggRect[nROIIndex];
+			//}
+			//=============================================================================//
+
+	;
+
+			//=============================================================================//
+			// Now, combine the mask result with ROI
+			//=============================================================================//
+			cvConvert(pcurr2b, pcurr2b_tempb);
+			//cvAnd(pcurr, pcurr2b_tempb, pMask1);
+			cv::Mat cvCurrImgTemp = cv::imread(szImgNamen);
+			IplImage* pTmp = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 1);
+			IplImage* pMask1 = cvCreateImage(cvSize(cvCurrImgTemp.cols, cvCurrImgTemp.rows), IPL_DEPTH_8U, 3);
+			cvSet(pMask1, CV_RGB(64, 128, 64));
+			//cv::Mat Mask1(pMask1);
+			cvResize(pcurr2b_tempb, pTmp, CV_INTER_NN);
+			//cv::Mat Tmp(pTmp);
+			IplImage iplcurrimgtemp = cvCurrImgTemp.operator IplImage();
+			IplImage* piplcurrimgtemp = &iplcurrimgtemp;
+			cvCopy(piplcurrimgtemp, pMask1, pTmp);
+			//cvCurrImgTemp.copyTo(Mask1, Tmp);
+			SavecvImageForDebug(szPathName0, "ClrMask", szKeyName, n, 5, ".jpg", pMask1);
+			cvReleaseImage(&pTmp);
+			cvReleaseImage(&pMask1);
+			//cvAnd(pcurr2b_tempb, &iplrefmask2, pcurr2b_tempb2);
+			//cvConvert(pcurr2b_tempb2, pcurr2b_tempb3);
+			cvCopy(pcurr2b, pcurr2b_tempb3);
+			//=============================================================================//
+
+			//=============================================================================//
+			// Morphological closing/ hole filling
+			//=============================================================================//
+			CloseImage(pcurr2b_tempb3, (CvArr*&)pcurr2c);
+			cvConvert(pcurr2c, pImgb);
+			IplImage* pMask2 = cvCreateImage(cvSize(pcurr->width, pcurr->height), IPL_DEPTH_8U, 1);
+			cvAnd(pcurr, pImgb, pMask2);
+			SavecvImageForDebug(szPathName0, "ClosedMask", szKeyName, n, 5, ".jpg", pImgb);
+			cvReleaseImage(&pMask2);
+			//cvReleaseImage(&pcurr2b_tempb);
+			//cvReleaseImage(&pcurr2b_tempb2);
+			cvReleaseImage(&pcurr2b_tempb3);
+			//=============================================================================//
+			
+			//=============================================================================//
+			// Now, try to detect center of mass of the hand region along with
+			// fingertip.
+			// However, currently, finger detection is not good in in car dataset,
+			// we only use the center of mass, so this part should be simplified in the 
+			// future if only COM is used
+			//=============================================================================//
+			hrTrackFinger = S_OK;
+			if(vvFeature.size() == 0)
+			{
+				hrTrackFinger = EstCOMandFingerLoc1(pImgb, vTmp);
+			}
+			else
+			{
+				hrTrackFinger = EstCOMandFingerLoc2(pImgb, vTmp, vvFeature[vvFeature.size() - 1]);
+			}
+
+			if( S_OK == hrTrackFinger)
+			{
+				size_t nWait = vHandVanishIndices.size();
+				if(nWait > 0)
+				{
+					// simply discard those you cannot save
+					if(0 < vvFeature.size())
+					{
+						cxn_k = vvFeature[vvFeature.size()-1][0];
+						cyn_k = vvFeature[vvFeature.size()-1][1];
+						dxn_k = vvFeature[vvFeature.size()-1][2];
+						dyn_k = vvFeature[vvFeature.size()-1][3];
+						cxn = vTmp[0];
+						cyn = vTmp[1];
+						dxn = vTmp[2];
+						dyn = vTmp[3];					
+						for(nk = 1; nk <= (int)nWait; nk++)
+						{
+							r = (double)nk / ((double)nWait + 1.0);
+							vTmpTmp[0] = (cxn - cxn_k) * r + cxn_k;
+							vTmpTmp[1] = (cyn - cyn_k) * r + cyn_k;
+							vTmpTmp[2] = floor((dxn - dxn_k) * r + dxn_k + 0.5);
+							vTmpTmp[3] = floor((dyn - dyn_k) * r + dyn_k + 0.5);
+							vvFeature.push_back(vTmpTmp);
+						}
+					}
+					nWait = 0;
+					vHandVanishIndices.clear();
+				}
+				vvFeature.push_back(vTmp);
+			}
+			else
+			{
+				vHandVanishIndices.push_back(n);
+				if(vHandVanishIndices.size() >= MAX_NUM_FRAME_WAIT_FOR_HAND_APPEAR_AGAIN)
+				{	
+					// Means the gesture ends in online FE				
+				}
+				// When it comes to the frame before the last frame,
+				// we just assume the point stay at the last observation 
+				// all the time
+				//!!!! Can be wrong!!!!
+				else if(n == nStop - 1)
+				{
+					for(nk = 1; nk <= (int)vHandVanishIndices.size(); nk++)
+					{
+						if(vTmp.size() == 4)
+						{
+							vvFeature.push_back(vTmp);
+						}
+					}
+					vHandVanishIndices.clear();
+				}
+				else if(n == nStop)
+				{
+					// Do nothing, coz nothing is observed 
+					vHandVanishIndices.clear();
+				}
+			}
+			cvReleaseImage(&pcurr);
+			cvReleaseImage(&pcurr2c);
+			cvReleaseImage(&pcurr2b);
+			//cvReleaseImage(&pcurr2bcpy);
+			cvReleaseImage(&pImgb);
+			//cvReleaseMemStorage(&storage);
+			//cvReleaseImage(&pcurr2bcpy);
+
+		}
+		//cvReleaseImage(&pBkGnd);
+		// Write features
+		if(0 < vvFeature.size())
+		{
+			HRESULT hrlast = WriteFeatureAsHTKMFCCAndItsHalves(vvFeature, szOutFeatureFile, szOutFeatureFile_uhalf, szOutFeatureFile_lhalf);
+			if(S_OK == hrlast)
+			{
+				vFEN[nID].IsCreated = true;
+				string szOutFileName001, szOutFileName002;
+				MakeDebugOutputName(szPathName0, "COM", szKeyName, ".jpg", szOutFileName001);
+				MakeDebugOutputName(szPathName0, "FNG", szKeyName, ".jpg", szOutFileName002);
+				WriteFeatureAsDEBUGTRAJ(vvFeature, szOutFileName001, szOutFileName002);
+				//WriteFeatureAsHTKMFCC(vvFeature, szOutFeatureFile);
+				//WriteFeatureAsDEBUGTRAJ(szOutFeatureFile, szOutFileName1, szOutFileName2);
+				size_t nSizet = vvFeature.size() - 1;
+				nSizet *= 666666;
+				htVN[szKeyName][0].nStart = 0;
+				htVN[szKeyName][0].nStop = (int)nSizet;
+				htVN[szKeyName][0].szName = szLabelName;
+			}
+			else if(hrlast == ERROR_INVALID_DATA)
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				cerr<<szOutFeatureFile<<" is not created due to all the same on some coordinate!\n";
+				feout.close();
+			}
+			else
+			{
+				vFEN[nID].IsCreated = false;
+				ofstream feout;
+				feout.open(szErrLog.c_str(), ios_base::app);
+				feout<<szOutFeatureFile<<" is not created for some other reason!\n";
+				cerr<<szOutFeatureFile<<" is not created for some other reason!\n";
+				feout.close();
+			}
+		}
+		else
+		{
+			vFEN[nID].IsCreated = false;
+			ofstream feout;
+			feout.open(szErrLog.c_str(), ios_base::app);
+			feout<<szOutFeatureFile<<" is not created!\n";
+			cerr<<szOutFeatureFile<<" is not created!\n";
+			feout.close();
+		}
+		return hr;
+	}
+
+	int MkdirHier(string sztmp)
+	{
+		//////////////////////////////////////////////////////////////////////
+		// Make directory hierachically
+		//////////////////////////////////////////////////////////////////////
+		int nFound1 = 0;
+		int nFound2 = 0;
+		int MakeResult = 0;
+		int IfSuccess = 1;
+#ifdef _WIN32
+		string szdelim = "\\";\
+		char delim = '\\';
+#else
+		string szdelim = "/";
+		char delim = '/';
+#endif
+		nFound1 = (int)sztmp.find(szdelim, 0);
+		nFound2 = (int)sztmp.find(szdelim, nFound1 + 1);
+		string szdir = sztmp.substr(0, nFound1);
+		string szdmdtmp = szdir; //"";//sztmp.substr(0, nFound1);
+		vector<string> vsz1;
+		while(nFound2 >= 0)
+		{
+			vsz1.push_back(sztmp.substr(nFound1 + 1, nFound2-nFound1-1));
+			nFound1 = nFound2;
+			nFound2 = (int)sztmp.find(szdelim, nFound1 + 1);
+		}
+		
+		if(sztmp[sztmp.length() - 1] != delim)
+		{
+			vsz1.push_back(sztmp.substr(nFound1 + 1, sztmp.size()-nFound1-1));
+		}
+		string syscom = "";
+		for(size_t nn = 0; nn < vsz1.size(); nn++)
+		{
+			//cout<<"MkdirHier, index="<<nn<<", the string to be appended is ";
+			//cout<<vsz1[nn]<<endl;
+			szdmdtmp.append(szdelim);
+			szdmdtmp.append(vsz1[nn].c_str());
+			syscom.append(szdmdtmp);
+			syscom.append(szdelim);
+			string s1 = szdir;
+			s1.append(":\\");
+			struct stat st;
+			if(stat(syscom.c_str(),&st) != 0)
+			{
+#ifdef _WIN32
+				MakeResult = _mkdir(syscom.c_str());
+#else
+				MakeResult = mkdir(syscom.c_str(), 777);
+
+#endif
+			}
+			if(MakeResult == -1)
+			{
+				int nerrno = 0;
+#ifdef _WIN32
+				::_get_errno(&nerrno);
+#else
+				nerrno = 2;				
+#endif
+				if(nerrno == 2)
+				{
+					cerr<<"Cannot create path while processing command "<<syscom<<endl;
+					IfSuccess = -1;
+				}
+
+			}
+			syscom = "";
+		}
+		//////////////////////////////////////////////////////////////////////
+		return IfSuccess;
+	}	
+
+	//=======================================================
+	// New functions
+	//=======================================================
+	void MakeDebugOutputName(string szPathName0, string szSubFolder, string szKeyName, string szExt, string& szOutFileName)
+	{
+		char delim;
+		string szdelim;
+	#ifdef _WIN32
+		delim = '\\';
+		szdelim = "\\";
+	#else
+		delim = '/';
+		szdelim = "/";
+	#endif
+		szOutFileName = szPathName0;
+		//cout<<"In MakeDebugOutputName\n";
+		//cout<<"szPathName0 is ["<<szPathName0<<"]\n";
+		//cout<<"szSubFolder is ["<<szSubFolder<<"]\n";
+		//cout<<"szKeyName is ["<<szKeyName<<"]\n";
+		//cout<<"szExt is ["<<szExt<<"]\n";
+		//cout<<"szOutFileName is ["<<szOutFileName<<"]\n";
+		if(szSubFolder[0] != delim && szPathName0[szPathName0.size() - 1] != delim)
+		{
+			string szTemp = szdelim;
+			szSubFolder = szTemp + szSubFolder;
+		}
+		if(szSubFolder[szSubFolder.size() - 1] != delim)
+			szSubFolder.append(szdelim);
+		szOutFileName.append(szSubFolder);
+		//cout<<"before mkdirhier\n";
+		MkdirHier(szOutFileName);
+		//cout<<"after mkdirhier\n";
+        #ifdef _WIN32
+        #else
+		//cout<<"doing chmod\n";
+                string szchmod = "chmod 777 " + szOutFileName;
+		system(szchmod.c_str());
+		//cout<<"chmod done\n";
+        #endif
+
+		szOutFileName.append(szKeyName);
+		szOutFileName.append(szExt);
+		//cout<<"after append szKeyName and szExt\n";
+			
+	}
+
+	void SavecvImageForDebug(string szPathName0, string szSubFolder, string szKeyName, int n, int nLength, string szExt, IplImage* pImg)
+	{
+		//SavecvImageForDebug(szPathName0, "Debug01", szKeyName, n, 5, ".jpg", pImg);
+		char delim;
+		string szdelim;
+	#ifdef _WIN32
+		delim = '\\';
+		szdelim = "\\";
+	#else
+		delim = '/';
+		szdelim = "/";
+	#endif
+		string st111 = szPathName0;
+		if(szSubFolder[0] != delim && szPathName0[szPathName0.size() - 1] != delim)
+		{
+			string szTemp = szdelim;
+			szSubFolder = szTemp + szSubFolder;
+		}
+		if(szSubFolder[szSubFolder.size() - 1] != delim)
+			szSubFolder.append(szdelim);
+		st111.append(szSubFolder);
+		MkdirHier(st111);
+        #ifdef _WIN32
+        #else
+                string szchmod1 = "chmod 777 " + st111;
+		system(szchmod1.c_str());
+        #endif
+		st111.append(szKeyName);
+		char* buf01 = new char[nLength + 1];
+		memset(buf01, 0, nLength + 1);
+		string szTmpformat = "%0";
+		char* buf02 = new char[nLength + 1];
+		memset(buf02, 0, nLength + 1);
+		sprintf(buf02, "%i", nLength);
+		//itoa(nLength, buf02, 10);
+		szTmpformat.append(buf02);
+		szTmpformat.append("d");
+		sprintf(buf01, szTmpformat.c_str(), n);
+		st111.append(buf01);
+		st111.append(szExt);
+		if(pImg != NULL)
+		{
+			cvSaveImage(st111.c_str(), pImg);
+		}
+		delete [ ] buf02;
+		delete [ ] buf01;
+	}
+
+	//=======================================================
+
+	void SaveMATForDebug(string szPathName0, string szSubFolder, string szKeyName, int n, int nLength, string szExt, IplImage* pImg)
+	{
+		//SavecvImageForDebug(szPathName0, "Debug01", szKeyName, n, 5, ".jpg", pImg);
+		char delim;
+		string szdelim;
+	#ifdef _WIN32
+		delim = '\\';
+		szdelim = "\\";
+	#else
+		delim = '/';
+		szdelim = "/";
+	#endif
+		string st111 = szPathName0;
+		if(szSubFolder[0] != delim && szPathName0[szPathName0.size() - 1] != delim)
+		{
+			string szTemp = szdelim;
+			szSubFolder = szTemp + szSubFolder;
+		}
+		if(szSubFolder[szSubFolder.size() - 1] != delim)
+			szSubFolder.append(szdelim);
+		st111.append(szSubFolder);
+		MkdirHier(st111);
+        #ifdef _WIN32
+        #else
+                string szchmod1 = "chmod 777 " + st111;
+		system(szchmod1.c_str());
+        #endif
+		st111.append(szKeyName);
+		char* buf01 = new char[nLength + 1];
+		memset(buf01, 0, nLength + 1);
+		string szTmpformat = "%0";
+		char* buf02 = new char[nLength + 1];
+		memset(buf02, 0, nLength + 1);
+		sprintf(buf02, "%i", nLength);
+		//itoa(nLength, buf02, 10);
+		szTmpformat.append(buf02);
+		szTmpformat.append("d");
+		sprintf(buf01, szTmpformat.c_str(), n);
+		st111.append(buf01);
+		st111.append(szExt);
+		if(pImg != NULL)
+		{
+			FILE* f1 = NULL;
+			f1 = fopen(st111.c_str(), "wb");
+			if(!f1)
+			{
+				cerr<<"Cannot open file "<<st111<<" for writing"<<endl;
+				delete [ ] buf02;
+				delete [ ] buf01;
+				return;
+			}
+			int height = pImg->height;
+			int width = pImg->width;
+			fwrite(&height, sizeof(int), 1, f1);
+			fwrite(&width, sizeof(int), 1, f1);
+			for(int n = 0; n < pImg->height; ++n)
+			{
+				for(int m = 0; m < pImg->width; ++m)
+				{
+					double db1 = cvGetReal2D(pImg, n, m);
+					fwrite(&db1, sizeof(double), 1, f1);
+				}
+			}
+			fclose(f1);
+		}
+		delete [ ] buf02;
+		delete [ ] buf01;
+	}
+
+	//=======================================================
+
+
+	// Core of Stochastic matching on feature space
+	int GMMBiasAdapt(vector< vector<double> >& vvData, matrix<double>& newmub, vector<GMM>& oldGMMs, vector<GMM>& newGMMs)
+	{
+		return GMMAdaptTool::GMMBiasAdapt(vvData, newmub, oldGMMs, newGMMs);
+	}
+
+	// Get the minimum and maximum value of matrix stored in vector< vector<double> > form at n-th dimension
+	HRESULT GetvvRangeAtnD(const vector< vector<double> >& vvData, unsigned int n, double& dbMin, double& dbMax)
+	{
+		return (HRESULT) GMMAdaptTool::GetvvRangeAtnD(vvData, n, dbMin, dbMax);
+	}
+
+	// Calculate the mean vector of a vector< vector<double> > data matrix by trating each vector<double> as a data point
+	HRESULT CalcvvMean(const vector< vector<double> >& vvData, vector<double>& vMean)
+	{
+		return (HRESULT) GMMAdaptTool::CalcvvMean(vvData, vMean);
+	}
+	
+	// normalize so that the sequence are in [0,1]
+	HRESULT Makein01(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData)
+	{
+		return (HRESULT) GMMAdaptTool::Makein01(vvData, vvNewData);
+	}
+
+	// Make vector< vector<double> > data zero mean and range from [-1, 1]
+	HRESULT MakeZeroMeanAndUnitRange(const vector< vector<double> >& vvData, vector< vector<double> >& vvNewData)
+	{
+		return (HRESULT) GMMAdaptTool::MakeZeroMeanAndUnitRange(vvData, vvNewData);
+	}	
+	
+	// Write the feature vector as HTK format MFCC feature file
+	HRESULT WriteFeatureAsHTKMFCC(const vector< vector<double> >& vvData, string szOutFileName)
+	{
+		return (HRESULT) GMMAdaptTool::WriteFeatureAsHTKMFCC(vvData, szOutFileName);
+	}
+
+	// Write the feature vector as HTK format MFCC feature file and its lower and upper halves
+	HRESULT WriteFeatureAsHTKMFCCAndItsHalves(const vector< vector<double> >& vvData, string szOutFileName, string szOutFileName_uhalf, string szOutFileName_lhalf)
+	{
+		return (HRESULT) GMMAdaptTool::WriteFeatureAsHTKMFCCAndItsHalves(vvData, szOutFileName, szOutFileName_uhalf, szOutFileName_lhalf);
+	}
+
+	HRESULT WriteFeatureAsDEBUGTRAJ(const vector< vector<double> >& vvData, string szOutFileName1, string szOutFileName2)
+	{
+		return (HRESULT) GMMAdaptTool::WriteFeatureAsDEBUGTRAJ(vvData, szOutFileName1, szOutFileName2);
+	}
+	HRESULT WriteFeatureAsDEBUGTRAJ(const vector< vector<double> >& vvData, string szOutFileName1)
+	{
+		return (HRESULT) GMMAdaptTool::WriteFeatureAsDEBUGTRAJ(vvData, szOutFileName1);
+	}
+
+	// Algorithms
+	bool CompmatrixMeanVar(matrix<double>& X, matrix<double>& mu, matrix<double>& S, matrix<double>& invS)
+	{
+		int d = (int)X.ColNo();
+		int N = (int)X.RowNo();
+		double dbN = (double)N;
+		mu.SetSize(1, d);
+		mu.Null();
+		for(int n1 = 0; n1 < N; n1++)
+		{
+			for(int n2 = 0; n2 < d; n2++)
+				mu(0, n2) += X(n1, n2);
+		}
+		mu /= dbN;
+		matrix<double> dXTmp(N, d);
+		dXTmp.Null();
+		for(int n1 = 0; n1 < N; n1++)
+		{
+			for(int n2 = 0; n2 < d; n2++)
+				dXTmp(n1, n2) = X(n1, n2) - mu(0, n2);
+		}
+		S = ~dXTmp * dXTmp / (dbN - 1);
+		for(int n2 = 0; n2 < d; n2++)
+		{
+			S(n2, n2) += 1.0e-6;
+		}
+		invS = !S;
+		return true;
+	}
+	// 90 % CI test for outlier
+	bool MCD(matrix<double>& X, vector<bool>& vbOutlier, double dbSigVal = 4.605, int h = 0)
+	{
+		int d = (int)X.ColNo();
+		int N = (int)X.RowNo();
+		if(N <= 0 || d <= 0)
+		{
+			cerr<<"Invalid data, dimension 0!"<<endl;
+			return ERROR_INVALID_DATA;
+		}
+		//int dd = d*(d+1)/2;
+		if(N < d)
+		{
+			cerr<<"A singular dataset, need more data points"<<endl;
+			return false;
+		}
+		if(h < d)
+		{
+			int hh = (int)floor(0.75 * (double)N);			
+			h = (d < hh)?hh:d;
+		}
+		double dbh = (double)h;
+		vector<int> dummy(N);
+		
+		for(size_t nn = 0; nn < N ; nn++)
+		{
+			dummy[nn] = nn;
+		}
+		random_shuffle(dummy.begin(), dummy.end());
+		matrix<double> XTmp(h, d);
+		for(size_t nn = 0; nn < h ; nn++)
+		{
+			for(size_t dd = 0; dd < d; dd++)
+			{
+				XTmp(nn, dd) = X(dummy[nn], dd);
+			}
+		}
+		
+		matrix<double> mu1, s1_prev, s1, is1;
+		CompmatrixMeanVar(XTmp, mu1, s1, is1);
+		s1_prev = s1;
+		bool bStop = false;
+		vector<double> vmd(N, 0.0);
+		vector<int> dummy2(N);
+		vbOutlier.resize(N, false);
+		do
+		{
+			for(size_t nn = 0; nn < N ; nn++)
+				dummy2[nn] = nn;		
+			
+			// Compute sample mean
+			// Compute Mahalanobis distance
+			for(int n1 = 0; n1 < N; n1++)
+			{
+				matrix<double> xn1(1, d);
+				for(int n2 = 0; n2 < d; n2++)
+					xn1(0, n2) = X(n1, n2) - mu1(0, n2);
+				vmd[n1] = (xn1 * is1 * ~xn1)(0, 0);
+			}
+			sort(dummy2.begin(), dummy2.end(), index_cmp_ascend< vector<double>& >(vmd));
+			for(size_t nn = 0; nn < h ; nn++)
+			{
+				for(size_t dd = 0; dd < d; dd++)
+				{
+					XTmp(nn, dd) = X(dummy2[nn], dd);
+				}
+			}
+			CompmatrixMeanVar(XTmp, mu1, s1, is1);
+			double db1 = s1.Det();
+			double db0 = s1_prev.Det();
+			if(fabs(db1 - db0) < 1e-6)
+			{
+				bStop = true;
+			}
+			s1_prev = s1;
+//			CompmatrixMeanVar(XTmp, mu1, s1, is1);
+		}while(!bStop);
+		for(int n = 0; n < N; n++)
+		{
+			if(dbSigVal < vmd[dummy2[n]])
+			{		
+				vbOutlier[dummy2[n]] = true;
+			}
+		}
+		return true;
+	}
+
+	HRESULT MCD(vector< vector<double> >& vvX, vector<bool>& vbOutlier, double dbSigVal = 4.605, int h = 0)
+	{
+		size_t N = vvX.size();
+		if(N < 1)
+		{
+			cerr<<"Empty Data for MCD!"<<endl;
+			return ERROR_EMPTY;
+		}
+		size_t d0 = vvX[0].size();
+		for(size_t n = 1; n < N; n++)
+		{
+			size_t d = vvX[n].size();
+			if(d != d0)
+			{
+				cerr<<"Data dimension mismatched in MCD"<<endl;
+				return ERROR_INVALID_DATA;
+			}
+		}
+		matrix<double> X(N, d0);
+		for(size_t n = 0; n < N; n++)
+		{
+			for(size_t d = 0; d < d0; d++)
+			{
+				X(n, d) = vvX[n][d];
+			}
+		}
+		bool b = MCD(X, vbOutlier, dbSigVal, h);
+		if(b)
+			return S_OK;
+		else
+			return ERROR_INVALID_DATA;
+	}
+
+	HRESULT GetvvDelta(vector< vector<double> >& vvData, vector< vector<double> >& vvDData)
+	{
+		size_t N = vvData.size();
+		if(N < 1)
+		{
+			cerr<<"Empty Data for GetvvDelta!"<<endl;
+			return ERROR_EMPTY;
+		}
+		size_t d0 = vvData[0].size();
+		for(size_t n = 1; n < N; n++)
+		{
+			size_t d = vvData[n].size();
+			if(d != d0)
+			{
+				cerr<<"Data dimension mismatched in GetvvDelta"<<endl;
+				return ERROR_INVALID_DATA;
+			}
+		}
+		vvDData.resize(N, vector<double>(d0, 0.0));
+		for(size_t n = 1; n < N; n++)
+		{
+			for(size_t d = 0; d < d0; d++)
+			{
+				vvDData[n][d] = vvData[n][d] - vvData[n-1][d];
+			}
+		}
+		return S_OK;
+	}
+
+
+	HRESULT CheckTrajValidity(vector< vector<double> >& vvData, vector< vector<double> >& vvNewData)
+	{
+		size_t NN = vvData.size();
+		if(NN < 16)
+		{
+			cerr<<"The length of the sequence is already too short in CheckTrajValidity"<<endl;
+			vvNewData = vvData;
+			return ERROR_INVALID_DATA;
+		}
+		vector< vector<double> > vvDData;
+		HRESULT hr = GetvvDelta(vvData, vvDData);
+		if(hr != S_OK)	return hr;
+		vector<bool> vbOutlier, vbOutlierD;
+		hr = MCD(vvData,vbOutlier);
+		if(hr != S_OK)	return hr;
+		hr = MCD(vvDData,vbOutlierD);
+		if(hr != S_OK)	return hr;
+		size_t N =  vbOutlier.size();
+		vector<bool> vbNewOutlier(N, false);
+		for(size_t n = 0; n < N; n++)
+		{
+			if(vbOutlier[n])
+			{
+				size_t leftindex = (n >= 1)?n:1;
+				size_t rightindex = (n < N - 1)?(n+1):(N-1);
+				vbNewOutlier[n] = vbOutlier[n] & (vbOutlier[leftindex] | vbOutlier[rightindex]);
+			}
+		}
+		size_t nStart = 0;
+		size_t nStop = N-1;
+
+		for(size_t n = 0; n < N; n++)
+		{
+			if(vbNewOutlier[n] == false)
+			{
+				nStart = n;
+				break;
+			}
+		}
+		for(size_t n = nStop; n >= 0; n--)
+		{
+			if(vbNewOutlier[n] == false)
+			{
+				nStop = n;
+				break;
+			}
+		}
+		if(nStop-nStart < 15)
+		{
+			cerr<<"The sequence will beome too short after truncation, so aborted"<<endl;
+			vvNewData = vvData;
+			return ERROR_INVALID_DATA;			
+		}
+		vvNewData.resize(nStop - nStart + 1);
+		for(size_t n = nStart; n < nStop; n++)
+		{
+			vvNewData[n - nStart] = vvData[n];
+		}
+		return S_OK;
+	}
+
+
+	HRESULT CheckTrajValidityBYU2D(vector< vector<double> >& vvOriginalData, vector< vector<double> >& vvNewData)
+	{
+		size_t NN = vvOriginalData.size();
+		if(NN < 16)
+		{
+			cerr<<"The length of the sequence is already too short in CheckTrajValidityBYU2D"<<endl;
+			vvNewData = vvOriginalData;
+			return ERROR_INVALID_DATA;
+		}
+		vector< vector<double> > vvData(NN, vector<double>(2, 0.0) );
+		for(size_t n = 0; n < NN ; n++)
+		{
+			vvData[n][0] = vvOriginalData[n][0];
+			vvData[n][1] = vvOriginalData[n][1];
+		}
+		// Check validity only on first 2 dimensions
+		vector< vector<double> > vvDData;
+		HRESULT hr = GetvvDelta(vvData, vvDData);
+		if(hr != S_OK)	return hr;
+		vector<bool> vbOutlier, vbOutlierD;
+		hr = MCD(vvData,vbOutlier);
+		if(hr != S_OK)	return hr;
+		hr = MCD(vvDData,vbOutlierD);
+		if(hr != S_OK)	return hr;
+		size_t N =  vbOutlier.size();
+		vector<bool> vbNewOutlier(N, false);
+		for(size_t n = 0; n < N; n++)
+		{
+			if(vbOutlier[n])
+			{
+				size_t leftindex = (n >= 1)?n:1;
+				size_t rightindex = (n < N - 1)?(n+1):(N-1);
+				vbNewOutlier[n] = vbOutlier[n] & (vbOutlier[leftindex] | vbOutlier[rightindex]);
+			}
+		}
+		size_t nStart = 0;
+		size_t nStop = N-1;
+
+		for(size_t n = 0; n < N; n++)
+		{
+			if(vbNewOutlier[n] == false)
+			{
+				nStart = n;
+				break;
+			}
+		}
+		for(size_t n = nStop; n >= 0; n--)
+		{
+			if(vbNewOutlier[n] == false)
+			{
+				nStop = n;
+				break;
+			}
+		}
+		if(nStop-nStart < 15)
+		{
+			cerr<<"The sequence will beome too short after truncation, so aborted"<<endl;
+			vvNewData = vvOriginalData;
+			return ERROR_INVALID_DATA;			
+		}
+		vvNewData.resize(nStop - nStart + 1);
+		for(size_t n = nStart; n <= nStop; n++)
+		{
+			vvNewData[n - nStart] = vvOriginalData[n];
+		}
+		return S_OK;
+	}
+
+ 	// Divide the number of accumulated background by its number of frames
+	 HRESULT AvgBackground(const CvArr* src, CvArr*& dst, unsigned int nnum)
+	 {
+		 if(dst == NULL)
+		 {
+			 if(CV_IS_MAT_HDR(src))
+			 {
+				 dst = cvCreateMat(((CvMat*)src)->rows, ((CvMat*)src)->cols, ((CvMat*)src)->type);
+			 }
+			 else if(CV_IS_IMAGE_HDR(src))
+			 {
+				 dst = cvCreateImage(cvSize(((IplImage*)src)->width, ((IplImage*)src)->height), ((IplImage*)src)->depth, ((IplImage*)src)->nChannels );
+			 }
+		 }
+		 double dscale = 1.0;
+		 if(nnum > 0)
+		 {
+			 dscale = 1.0/((double)(nnum));
+		 }
+		 cvConvertScale(src, dst, dscale);
+		 return S_OK;
+	 }
+
+	void PreCompute2ClassesGMMTable(vector<GMM>& vGMMs, bool*** vvvDecisionTable)
+	{
+		//vvvDecisionTable = vector< vector< vector<bool> > >(256, vector< vector<bool> >(256, vector<bool>(256, false)));
+		vector<double> vtmp(3, 0.0);
+		for(int i = 0; i < 256; ++i)
+		{
+			for(int j = 0; j < 256; ++j)
+			{
+				for(int k = 0; k < 256; ++k)
+				{
+					vtmp[0] = (double)i;
+					vtmp[1] = (double)j;
+					vtmp[2] = (double)k;
+					double db0 = vGMMs[0].CompLikelihood(vtmp);
+					double db1 = vGMMs[1].CompLikelihood(vtmp);
+					vvvDecisionTable[i][j][k] = (db1 > db0)?true:false;
+				}
+			}
+		}
+	}
+	vector<int> vDimConsidered;
+	int m_nHandModelIndex;
+	int m_nBkGndModelIndex;
+	int m_nK;
+	double m_duth;
+	string m_szGMMPath;
+};
diff --git a/connected.h b/connected.h
new file mode 100644
index 0000000..1a9dc70
--- /dev/null
+++ b/connected.h
@@ -0,0 +1,187 @@
+/* Find connect components in an image.
+   By Ali Rahimi
+   ali@mit.edu
+   Jun 2001.
+
+   See connected.cc for how to use this package.
+*/
+
+
+#ifndef _CONNECTED_H
+#define _CONNECTED_H
+
+
+#include <vector>
+#include <algorithm>
+
+template <class T, T V>
+struct constant
+{
+    operator T() const { return V; }
+};
+
+
+class ConnectedComponents
+{
+public:
+    ConnectedComponents(int soft_maxlabels) : labels(soft_maxlabels) {
+		clear();
+    }
+    void clear() {
+		std::fill(labels.begin(), labels.end(), Similarity());
+		highest_label = 0;
+    }
+    template<class Tin, class Tlabel, class Comparator, class Boolean>
+    int connected(const Tin *img, Tlabel *out,
+				  int width, int height, Comparator,
+				  Boolean K8_connectivity);
+
+
+
+private:
+    struct Similarity {
+		Similarity() : id(0), sameas(0) {}
+		Similarity(int _id, int _sameas) : id(_id), sameas(_sameas) {}
+		Similarity(int _id) : id(_id), sameas(_id) {}
+		int id, sameas, tag;
+    };
+
+    bool is_root_label(int id) {
+		return (labels[id].sameas == id);
+    }
+    int root_of(int id) {
+	while (!is_root_label(id)) {
+	    // link this node to its parent's parent, just to shorten
+	    // the tree.
+	    labels[id].sameas = labels[labels[id].sameas].sameas;
+
+	    id = labels[id].sameas;
+	}
+	return id;
+    }
+    bool is_equivalent(int id, int as) {
+		return (root_of(id) == root_of(as));
+    }
+    bool merge(int id1, int id2) {
+	if(!is_equivalent(id1, id2)) {
+	    labels[root_of(id1)].sameas = root_of(id2);
+	    return false;
+	}
+	return true;
+    }
+    int new_label() {
+		// Thanks to Pierre Grinspan for suggesting using capacity()
+		// instead of size() here.
+		if(highest_label+1 > labels.capacity())
+			labels.reserve(highest_label*2);
+		labels.resize(highest_label+1);
+		labels[highest_label] = Similarity(highest_label);
+		return highest_label++;
+    }
+
+
+    template<class Tin, class Tlabel, class Comparator, class Boolean>
+    void label_image(const Tin *img, Tlabel *out,
+					 int width, int height, Comparator,
+					 Boolean K8_connectivity);
+    template<class Tlabel>
+    int relabel_image(Tlabel *out, int width, int height);
+
+
+    std::vector<Similarity> labels;
+    int highest_label;
+};
+
+template<class Tin, class Tlabel, class Comparator, class Boolean>
+int
+ConnectedComponents::connected(const Tin *img, Tlabel *labelimg,
+			       int width, int height, Comparator SAME,
+			       Boolean K8_connectivity)
+{
+    label_image(img,labelimg, width,height, SAME, K8_connectivity);
+    return relabel_image(labelimg, width,height);
+}
+
+
+
+
+template<class Tin, class Tlabel, class Comparator, class Boolean>
+void
+ConnectedComponents::label_image(const Tin *img, Tlabel *labelimg,
+				 int width, int height, Comparator SAME,
+				 const Boolean K8_CONNECTIVITY)
+{
+    const Tin *row = img;
+    const Tin *last_row = 0;
+    struct Label_handler {
+	Label_handler(const Tin *img, Tlabel *limg) :
+	    piximg(img), labelimg(limg) {}
+	Tlabel &operator()(const Tin *pixp) { return labelimg[pixp-piximg]; }
+	const Tin *piximg;
+	Tlabel *labelimg;
+    } label(img, labelimg);
+
+    clear();
+
+    label(&row[0]) = new_label();
+
+    // label the first row.
+    for(int c=1, r=0; c<width; ++c) {
+	if(SAME(row[c], row[c-1]))
+	    label(&row[c]) = label(&row[c-1]);
+	else
+	    label(&row[c]) = new_label();
+    }
+
+    // label subsequent rows.
+    for(int r=1; r<height; ++r)    {
+	// label the first pixel on this row.
+	last_row = row;
+	row = &img[width*r];
+
+	if(SAME(row[0], last_row[0]))
+	    label(&row[0]) = label(&last_row[0]);
+	else
+	    label(&row[0]) = new_label();
+
+	// label subsequent pixels on this row.
+	for(int c=1; c<width; ++c)	{
+	    int mylab = -1;
+
+	    // inherit label from pixel on the left if we're in the same blob.
+	    if(SAME(row[c],row[c-1]))
+		mylab = label(&row[c-1]);
+	    for(int d=(K8_CONNECTIVITY?-1:0); d<1; ++d) {
+		// if we're in the same blob, inherit value from above pixel.
+		// if we've already been assigned, merge its label with ours.
+		if(SAME(row[c], last_row[c+d])) {
+		    if(mylab>=0) merge(mylab, label(&last_row[c+d]));
+		    else mylab = label(&last_row[c+d]);
+		}
+	    }
+	    if(mylab>=0) label(&row[c]) = static_cast<Tlabel>(mylab);
+	    else label(&row[c]) = new_label();
+
+	    if(K8_CONNECTIVITY && SAME(row[c-1], last_row[c]))
+		merge(label(&row[c-1]), label(&last_row[c]));
+	}
+    }
+}
+
+template<class Tlabel>
+int
+ConnectedComponents::relabel_image(Tlabel *labelimg, int width, int height)
+{
+    int newtag = 0;
+    for(int id=0; id<labels.size(); ++id)
+	if(is_root_label(id))
+	    labels[id].tag = newtag++;
+
+    for(int i = 0; i<width*height; ++i)
+	labelimg[i] = labels[root_of(labelimg[i])].tag;
+
+    return newtag;
+}
+
+
+#endif // _CONNECTED_H
diff --git a/matrix.h b/matrix.h
new file mode 100644
index 0000000..e67d295
--- /dev/null
+++ b/matrix.h
@@ -0,0 +1,1063 @@
+////////////////////////////////
+// Matrix TCL Lite v1.13
+// Copyright (c) 1997-2002 Techsoft Pvt. Ltd. (See License.Txt file.)
+//
+// Matrix.h: Matrix C++ template class include file 
+// Web: http://www.techsoftpl.com/matrix/
+// Email: matrix@techsoftpl.com
+//
+
+//////////////////////////////
+// Installation:
+//
+// Copy this "matrix.h" file into include directory of your compiler.
+//
+
+//////////////////////////////
+// Note: This matrix template class defines majority of the matrix
+// operations as overloaded operators or methods. It is assumed that
+// users of this class is familiar with matrix algebra. We have not
+// defined any specialization of this template here, so all the instances
+// of matrix will be created implicitly by the compiler. The data types
+// tested with this class are float, double, long double, complex<float>,
+// complex<double> and complex<long double>. Note that this class is not 
+// optimized for performance.
+//
+// Since implementation of exception, namespace and template are still
+// not standardized among the various (mainly old) compilers, you may 
+// encounter compilation error with some compilers. In that case remove 
+// any of the above three features by defining the following macros:
+//
+//  _NO_NAMESPACE:  Define this macro to remove namespace support.
+//
+//  _NO_EXCEPTION:  Define this macro to remove exception handling
+//                  and use old style of error handling using function.
+//
+//  _NO_TEMPLATE:   If this macro is defined matrix class of double
+//                  type will be generated by default. You can also
+//                  generate a different type of matrix like float.
+//
+//  _SGI_BROKEN_STL: For SGI C++ v.7.2.1 compiler.
+//
+//  Since all the definitions are also included in this header file as
+//  inline function, some compiler may give warning "inline function
+//  can't be expanded". You may ignore/disable this warning using compiler
+//  switches. All the operators/methods defined in this class have their
+//  natural meaning except the followings:
+//
+//  Operator/Method                          Description
+//  ---------------                          -----------
+//   operator ()   :   This function operator can be used as a
+//                     two-dimensional subscript operator to get/set
+//                     individual matrix elements.
+//
+//   operator !    :   This operator has been used to calculate inversion
+//                     of matrix.
+//
+//   operator ~    :   This operator has been used to return transpose of
+//                     a matrix.
+//
+//   operator ^    :   It is used calculate power (by a scalar) of a matrix.
+//                     When using this operator in a matrix equation, care
+//                     must be taken by parenthesizing it because it has
+//                     lower precedence than addition, subtraction,
+//                     multiplication and division operators.
+//
+//   operator >>   :   It is used to read matrix from input stream as per
+//                     standard C++ stream operators.
+//
+//   operator <<   :   It is used to write matrix to output stream as per
+//                     standard C++ stream operators.
+//
+// Note that professional version of this package, Matrix TCL Pro 2.11
+// is optimized for performance and supports many more matrix operations.
+// It is available from our web site at <http://www.techsoftpl.com/matrix/>.
+//
+
+#ifndef __cplusplus
+#error Must use C++ for the type matrix.
+#endif
+
+#if !defined(__STD_MATRIX_H)
+#define __STD_MATRIX_H
+
+//////////////////////////////
+// First deal with various shortcomings and incompatibilities of
+// various (mainly old) versions of popular compilers available.
+//
+
+#if defined(__BORLANDC__)
+#pragma option -w-inl -w-pch
+#endif
+
+#if ( defined(__BORLANDC__) || _MSC_VER <= 1000 ) && !defined( __GNUG__ )
+#  include <stdio.h>
+#  include <stdlib.h>
+#  include <math.h>
+#  include <iostream.h>
+#  include <string.h>
+#else
+#  include <cmath>
+#  include <cstdio>
+#  include <cstdlib>
+#  include <string>
+#  include <iostream>
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER <= 1000
+#  define _NO_EXCEPTION        // stdexception is not fully supported in MSVC++ 4.0
+typedef int bool;
+#  if !defined(false)
+#    define false  0
+#  endif
+#  if !defined(true)
+#    define true   1
+#  endif
+#endif
+
+#if defined(__BORLANDC__) && !defined(__WIN32__)
+#  define _NO_EXCEPTION        // std exception and namespace are not fully
+#  define _NO_NAMESPACE        // supported in 16-bit compiler
+#endif
+
+#if defined(_MSC_VER) && !defined(_WIN32)
+#  define _NO_EXCEPTION
+#endif
+
+#if defined(_NO_EXCEPTION)
+#  define _NO_THROW
+#  define _THROW_MATRIX_ERROR
+#else
+#  if defined(_MSC_VER)
+#    if _MSC_VER >= 1020
+#      include <stdexcept>
+#    else
+#      include <stdexcpt.h>
+#    endif
+#  elif defined(__MWERKS__)
+#      include <stdexcept>
+#  elif (__GNUC__ >= 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))
+#     include <stdexcept>
+#  else
+#     include <stdexcep>
+#  endif
+#  define _NO_THROW               throw ()
+#  define _THROW_MATRIX_ERROR     throw (matrix_error)
+#endif
+
+#ifndef __MINMAX_DEFINED
+#  define max(a,b)    (((a) > (b)) ? (a) : (b))
+#  define min(a,b)    (((a) < (b)) ? (a) : (b))
+#endif
+
+#if defined(_MSC_VER)
+#undef _MSC_EXTENSIONS      // To include overloaded abs function definitions!
+#endif
+
+//#if ( defined(__BORLANDC__) || _MSC_VER ) && !defined( __GNUG__ ) 
+//inline float abs (float v) { return (float)fabs( v); } 
+//inline double abs (double v) { return fabs( v); } 
+//inline long double abs (long double v) { return fabsl( v); }
+//#endif
+
+#if defined(__GNUG__) || defined(__MWERKS__) || (defined(__BORLANDC__) && (__BORLANDC__ >= 0x540))
+#define FRIEND_FUN_TEMPLATE <>
+#else
+#define FRIEND_FUN_TEMPLATE
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER <= 1020   // MSVC++ 4.0/4.2 does not
+#  define _NO_NAMESPACE                     // support "std" namespace
+#endif
+
+#if !defined(_NO_NAMESPACE)
+#if defined( _SGI_BROKEN_STL )              // For SGI C++ v.7.2.1 compiler
+namespace std { }
+#endif
+using namespace std;
+#endif
+
+#ifndef _NO_NAMESPACE
+namespace math {
+#endif
+
+#if !defined(_NO_EXCEPTION)
+class matrix_error : public logic_error
+{
+    public:
+	matrix_error (const string& what_arg) : logic_error( what_arg) {}
+};
+#define REPORT_ERROR(ErrormMsg)  throw matrix_error( ErrormMsg);
+#else
+inline void _matrix_error (const char* pErrMsg)
+{
+    cout << pErrMsg << endl;
+    exit(1);
+}
+#define REPORT_ERROR(ErrormMsg)  _matrix_error( ErrormMsg);
+#endif
+
+#if !defined(_NO_TEMPLATE)
+#  define MAT_TEMPLATE  template <class T>
+#  define matrixT  matrix<T>
+#else
+#  define MAT_TEMPLATE
+#  define matrixT  matrix
+#  ifdef MATRIX_TYPE
+     typedef MATRIX_TYPE T;
+#  else
+     typedef double T;
+#  endif
+#endif
+
+
+MAT_TEMPLATE
+class matrix
+{
+public:
+   // Constructors
+   matrix (const matrixT& m);
+   matrix (size_t row = 6, size_t col = 6);
+
+   // Destructor
+   ~matrix ();
+
+   // Assignment operators
+   matrixT& operator = (const matrixT& m) _NO_THROW;
+
+   // Value extraction method
+   size_t RowNo () const { return _m->Row; }
+   size_t ColNo () const { return _m->Col; }
+
+   // Subscript operator
+   T& operator () (size_t row, size_t col) _THROW_MATRIX_ERROR;
+   T  operator () (size_t row, size_t col) const _THROW_MATRIX_ERROR;
+
+   // Unary operators
+   matrixT operator + () _NO_THROW { return *this; }
+   matrixT operator - () _NO_THROW;
+
+   // Combined assignment - calculation operators
+   matrixT& operator += (const matrixT& m) _THROW_MATRIX_ERROR;
+   matrixT& operator -= (const matrixT& m) _THROW_MATRIX_ERROR;
+   matrixT& operator *= (const matrixT& m) _THROW_MATRIX_ERROR;
+   matrixT& operator *= (const T& c) _NO_THROW;
+   matrixT& operator /= (const T& c) _NO_THROW;
+   matrixT& operator ^= (const size_t& pow) _THROW_MATRIX_ERROR;
+
+   // Miscellaneous -methods
+   void Null (const size_t& row, const size_t& col) _NO_THROW;
+   void Null () _NO_THROW;
+   void Unit (const size_t& row) _NO_THROW;
+   void Unit () _NO_THROW;
+   void SetSize (size_t row, size_t col) _NO_THROW;
+
+   // Utility methods
+   matrixT Solve (const matrixT& v) const _THROW_MATRIX_ERROR;
+   matrixT Adj () _THROW_MATRIX_ERROR;
+   matrixT Inv () _THROW_MATRIX_ERROR;
+   T Det () const _THROW_MATRIX_ERROR;
+   T Norm () _NO_THROW;
+   T Cofact (size_t row, size_t col) _THROW_MATRIX_ERROR;
+   T Cond () _NO_THROW;
+
+   // Type of matrices
+   bool IsSquare () _NO_THROW { return (_m->Row == _m->Col); } 
+   bool IsSingular () _NO_THROW;
+   bool IsDiagonal () _NO_THROW;
+   bool IsScalar () _NO_THROW;
+   bool IsUnit () _NO_THROW;
+   bool IsNull () _NO_THROW;
+   bool IsSymmetric () _NO_THROW;
+   bool IsSkewSymmetric () _NO_THROW;
+   bool IsUpperTriangular () _NO_THROW;
+   bool IsLowerTriangular () _NO_THROW;
+
+private:
+    struct base_mat
+    {
+	T **Val;
+	size_t Row, Col, RowSiz, ColSiz;
+	int Refcnt;
+
+	base_mat (size_t row, size_t col, T** v)
+	{
+	    Row = row; RowSiz = row;
+	    Col = col; ColSiz = col;
+	    Refcnt = 1;
+
+	    Val = new T* [row];
+	    size_t rowlen = col * sizeof(T);
+
+	    for (size_t i=0; i < row; i++)
+	    {
+		Val[i] = new T [col];
+		if (v) memcpy( Val[i], v[i], rowlen);
+	    }
+	}
+	~base_mat ()
+	{
+	    for (size_t i=0; i < RowSiz; i++)
+		delete [] Val[i];
+	    delete [] Val;
+	}
+    };
+    base_mat *_m;
+
+    void clone ();
+    void realloc (size_t row, size_t col);
+    int pivot (size_t row);
+};
+
+#if defined(_MSC_VER) && _MSC_VER <= 1020
+#  undef  _NO_THROW               // MSVC++ 4.0/4.2 does not support 
+#  undef  _THROW_MATRIX_ERROR     // exception specification in definition
+#  define _NO_THROW
+#  define _THROW_MATRIX_ERROR
+#endif
+
+// constructor
+MAT_TEMPLATE inline
+matrixT::matrix (size_t row, size_t col)
+{
+  _m = new base_mat( row, col, 0);
+}
+
+// copy constructor
+MAT_TEMPLATE inline
+matrixT::matrix (const matrixT& m)
+{
+    _m = m._m;
+    _m->Refcnt++;
+}
+
+// Internal copy constructor
+MAT_TEMPLATE inline void
+matrixT::clone ()
+{
+    _m->Refcnt--;
+    _m = new base_mat( _m->Row, _m->Col, _m->Val);
+}
+
+// destructor
+MAT_TEMPLATE inline
+matrixT::~matrix ()
+{
+   if (--_m->Refcnt == 0) delete _m;
+}
+
+// assignment operator
+MAT_TEMPLATE inline matrixT&
+matrixT::operator = (const matrixT& m) _NO_THROW
+{
+    m._m->Refcnt++;
+    if (--_m->Refcnt == 0) delete _m;
+    _m = m._m;
+    return *this;
+}
+
+//  reallocation method
+MAT_TEMPLATE inline void 
+matrixT::realloc (size_t row, size_t col)
+{
+   if (row == _m->RowSiz && col == _m->ColSiz)
+   {
+      _m->Row = _m->RowSiz;
+      _m->Col = _m->ColSiz;
+      return;
+   }
+
+   base_mat *m1 = new base_mat( row, col, NULL);
+   size_t colSize = min(_m->Col,col) * sizeof(T);
+   size_t minRow = min(_m->Row,row);
+
+   for (size_t i=0; i < minRow; i++)
+      memcpy( m1->Val[i], _m->Val[i], colSize);
+
+   if (--_m->Refcnt == 0) 
+       delete _m;
+   _m = m1;
+
+   return;
+}
+
+// public method for resizing matrix
+MAT_TEMPLATE inline void
+matrixT::SetSize (size_t row, size_t col) _NO_THROW
+{
+   size_t i,j;
+   size_t oldRow = _m->Row;
+   size_t oldCol = _m->Col;
+
+   if (row != _m->RowSiz || col != _m->ColSiz)
+      realloc( row, col);
+
+   for (i=oldRow; i < row; i++)
+      for (j=0; j < col; j++)
+	 _m->Val[i][j] = T(0);
+
+   for (i=0; i < row; i++)                      
+      for (j=oldCol; j < col; j++)
+	 _m->Val[i][j] = T(0);
+
+   return;
+}
+
+// subscript operator to get/set individual elements
+MAT_TEMPLATE inline T&
+matrixT::operator () (size_t row, size_t col) _THROW_MATRIX_ERROR
+{
+   if (row >= _m->Row || col >= _m->Col)
+      REPORT_ERROR( "matrixT::operator(): Index out of range!");
+   if (_m->Refcnt > 1) clone();
+   return _m->Val[row][col];
+}
+
+// subscript operator to get/set individual elements
+MAT_TEMPLATE inline T
+matrixT::operator () (size_t row, size_t col) const _THROW_MATRIX_ERROR
+{
+   if (row >= _m->Row || col >= _m->Col)
+      REPORT_ERROR( "matrixT::operator(): Index out of range!");
+   return _m->Val[row][col];
+}
+
+// input stream function
+MAT_TEMPLATE inline istream&
+operator >> (istream& istrm, matrixT& m)
+{
+   for (size_t i=0; i < m.RowNo(); i++)
+      for (size_t j=0; j < m.ColNo(); j++)
+      {
+         T x;
+         istrm >> x;
+         m(i,j) = x;
+      }
+   return istrm;
+}
+
+// output stream function
+MAT_TEMPLATE inline ostream&
+operator << (ostream& ostrm, const matrixT& m)
+{
+   for (size_t i=0; i < m.RowNo(); i++)
+   {
+      for (size_t j=0; j < m.ColNo(); j++)
+      {
+         T x = m(i,j);
+         ostrm << x << '\t';
+      }
+      ostrm << endl;
+   }
+   return ostrm;
+}
+
+
+// logical equal-to operator
+MAT_TEMPLATE inline bool
+operator == (const matrixT& m1, const matrixT& m2) _NO_THROW
+{
+   if (m1.RowNo() != m2.RowNo() || m1.ColNo() != m2.ColNo())
+      return false;
+
+   for (size_t i=0; i < m1.RowNo(); i++)
+      for (size_t j=0; j < m1.ColNo(); j++)
+	      if (m1(i,j) != m2(i,j))
+	         return false;
+
+   return true;
+}
+
+// logical no-equal-to operator
+MAT_TEMPLATE inline bool
+operator != (const matrixT& m1, const matrixT& m2) _NO_THROW
+{
+    return (m1 == m2) ? false : true;
+}
+
+// combined addition and assignment operator
+MAT_TEMPLATE inline matrixT&
+matrixT::operator += (const matrixT& m) _THROW_MATRIX_ERROR
+{
+   if (_m->Row != m._m->Row || _m->Col != m._m->Col)
+      REPORT_ERROR( "matrixT::operator+= : Inconsistent matrix sizes in addition!");
+   if (_m->Refcnt > 1) clone();
+   for (size_t i=0; i < m._m->Row; i++)
+      for (size_t j=0; j < m._m->Col; j++)
+	 _m->Val[i][j] += m._m->Val[i][j];
+   return *this;
+}
+
+// combined subtraction and assignment operator
+MAT_TEMPLATE inline matrixT&
+matrixT::operator -= (const matrixT& m) _THROW_MATRIX_ERROR
+{
+   if (_m->Row != m._m->Row || _m->Col != m._m->Col)
+      REPORT_ERROR( "matrixT::operator-= : Inconsistent matrix sizes in subtraction!");
+   if (_m->Refcnt > 1) clone();
+   for (size_t i=0; i < m._m->Row; i++)
+      for (size_t j=0; j < m._m->Col; j++)
+	 _m->Val[i][j] -= m._m->Val[i][j];
+   return *this;
+}
+
+// combined scalar multiplication and assignment operator
+MAT_TEMPLATE inline matrixT&
+matrixT::operator *= (const T& c) _NO_THROW
+{
+    if (_m->Refcnt > 1) clone();
+    for (size_t i=0; i < _m->Row; i++)
+	for (size_t j=0; j < _m->Col; j++)
+	    _m->Val[i][j] *= c;
+    return *this;
+}
+
+// combined matrix multiplication and assignment operator
+MAT_TEMPLATE inline matrixT&
+matrixT::operator *= (const matrixT& m) _THROW_MATRIX_ERROR
+{
+   if (_m->Col != m._m->Row)
+      REPORT_ERROR( "matrixT::operator*= : Inconsistent matrix sizes in multiplication!");
+
+   matrixT temp(_m->Row,m._m->Col);
+
+   for (size_t i=0; i < _m->Row; i++)
+      for (size_t j=0; j < m._m->Col; j++)
+      {
+         temp._m->Val[i][j] = T(0);
+         for (size_t k=0; k < _m->Col; k++)
+            temp._m->Val[i][j] += _m->Val[i][k] * m._m->Val[k][j];
+      }
+   *this = temp;
+
+   return *this;
+}
+
+// combined scalar division and assignment operator
+MAT_TEMPLATE inline matrixT&
+matrixT::operator /= (const T& c) _NO_THROW
+{
+    if (_m->Refcnt > 1) clone();
+    for (size_t i=0; i < _m->Row; i++)
+	for (size_t j=0; j < _m->Col; j++)
+	    _m->Val[i][j] /= c;
+
+    return *this;
+}
+
+// combined power and assignment operator
+MAT_TEMPLATE inline matrixT&
+matrixT::operator ^= (const size_t& pow) _THROW_MATRIX_ERROR
+{
+	matrixT temp(*this);
+
+	for (size_t i=2; i <= pow; i++)
+      *this = *this * temp;
+
+	return *this;
+}
+
+// unary negation operator
+MAT_TEMPLATE inline matrixT
+matrixT::operator - () _NO_THROW
+{
+   matrixT temp(_m->Row,_m->Col);
+
+   for (size_t i=0; i < _m->Row; i++)
+      for (size_t j=0; j < _m->Col; j++)
+	 temp._m->Val[i][j] = - _m->Val[i][j];
+
+   return temp;
+}
+
+// binary addition operator
+MAT_TEMPLATE inline matrixT
+operator + (const matrixT& m1, const matrixT& m2) _THROW_MATRIX_ERROR
+{
+   matrixT temp = m1;
+   temp += m2;
+   return temp;
+}
+
+// binary subtraction operator
+MAT_TEMPLATE inline matrixT
+operator - (const matrixT& m1, const matrixT& m2) _THROW_MATRIX_ERROR
+{
+   matrixT temp = m1;
+   temp -= m2;
+   return temp;
+}
+
+// binary scalar multiplication operator
+MAT_TEMPLATE inline matrixT
+operator * (const matrixT& m, const T& no) _NO_THROW
+{
+   matrixT temp = m;
+   temp *= no;
+   return temp;
+}
+
+
+// binary scalar multiplication operator
+MAT_TEMPLATE inline matrixT
+operator * (const T& no, const matrixT& m) _NO_THROW
+{
+   return (m * no);
+}
+
+// binary matrix multiplication operator
+MAT_TEMPLATE inline matrixT
+operator * (const matrixT& m1, const matrixT& m2) _THROW_MATRIX_ERROR
+{
+   matrixT temp = m1;
+   temp *= m2;
+   return temp;
+}
+
+// binary scalar division operator
+MAT_TEMPLATE inline matrixT
+operator / (const matrixT& m, const T& no) _NO_THROW
+{
+    return (m * (T(1) / no));
+}
+
+
+// binary scalar division operator
+MAT_TEMPLATE inline matrixT
+operator / (const T& no, const matrixT& m) _THROW_MATRIX_ERROR
+{
+    return (!m * no);
+}
+
+// binary matrix division operator
+MAT_TEMPLATE inline matrixT
+operator / (const matrixT& m1, const matrixT& m2) _THROW_MATRIX_ERROR
+{
+    return (m1 * !m2);
+}
+
+// binary power operator
+MAT_TEMPLATE inline matrixT
+operator ^ (const matrixT& m, const size_t& pow) _THROW_MATRIX_ERROR
+{
+   matrixT temp = m;
+   temp ^= pow;
+   return temp;
+}
+
+// unary transpose operator
+MAT_TEMPLATE inline matrixT
+operator ~ (const matrixT& m) _NO_THROW
+{
+   matrixT temp(m.ColNo(),m.RowNo());
+
+   for (size_t i=0; i < m.RowNo(); i++)
+      for (size_t j=0; j < m.ColNo(); j++)
+      {
+         T x = m(i,j);
+	      temp(j,i) = x;
+      }
+   return temp;
+}
+
+// unary inversion operator
+MAT_TEMPLATE inline matrixT
+operator ! (const matrixT m) _THROW_MATRIX_ERROR
+{
+   matrixT temp = m;
+   return temp.Inv();
+}
+
+// inversion function
+MAT_TEMPLATE inline matrixT
+matrixT::Inv () _THROW_MATRIX_ERROR
+{
+   size_t i,j,k;
+   T a1,a2,*rowptr;
+
+   if (_m->Row != _m->Col)
+      REPORT_ERROR( "matrixT::operator!: Inversion of a non-square matrix");
+
+   matrixT temp(_m->Row,_m->Col);
+   if (_m->Refcnt > 1) clone();
+
+
+   temp.Unit();
+   for (k=0; k < _m->Row; k++)
+   {
+      int indx = pivot(k);
+      if (indx == -1)
+	      REPORT_ERROR( "matrixT::operator!: Inversion of a singular matrix");
+
+      if (indx != 0)
+      {
+	      rowptr = temp._m->Val[k];
+	      temp._m->Val[k] = temp._m->Val[indx];
+	      temp._m->Val[indx] = rowptr;
+      }
+      a1 = _m->Val[k][k];
+      for (j=0; j < _m->Row; j++)
+      {
+	      _m->Val[k][j] /= a1;
+	      temp._m->Val[k][j] /= a1;
+      }
+      for (i=0; i < _m->Row; i++)
+	   if (i != k)
+	   {
+	      a2 = _m->Val[i][k];
+	      for (j=0; j < _m->Row; j++)
+	      {
+	         _m->Val[i][j] -= a2 * _m->Val[k][j];
+	         temp._m->Val[i][j] -= a2 * temp._m->Val[k][j];
+	      }
+	   }
+   }
+   return temp;
+}
+
+// solve simultaneous equation
+MAT_TEMPLATE inline matrixT
+matrixT::Solve (const matrixT& v) const _THROW_MATRIX_ERROR
+{
+   size_t i,j,k;
+   T a1;
+
+   if (!(_m->Row == _m->Col && _m->Col == v._m->Row))
+      REPORT_ERROR( "matrixT::Solve():Inconsistent matrices!");
+
+   matrixT temp(_m->Row,_m->Col+v._m->Col);
+   for (i=0; i < _m->Row; i++)
+   {
+      for (j=0; j < _m->Col; j++)
+	 temp._m->Val[i][j] = _m->Val[i][j];
+      for (k=0; k < v._m->Col; k++)
+	 temp._m->Val[i][_m->Col+k] = v._m->Val[i][k];
+   }
+   for (k=0; k < _m->Row; k++)
+   {
+      int indx = temp.pivot(k);
+      if (indx == -1)
+	 REPORT_ERROR( "matrixT::Solve(): Singular matrix!");
+
+      a1 = temp._m->Val[k][k];
+      for (j=k; j < temp._m->Col; j++)
+	 temp._m->Val[k][j] /= a1;
+
+      for (i=k+1; i < _m->Row; i++)
+      {
+	 a1 = temp._m->Val[i][k];
+	 for (j=k; j < temp._m->Col; j++)
+	   temp._m->Val[i][j] -= a1 * temp._m->Val[k][j];
+      }
+   }
+   matrixT s(v._m->Row,v._m->Col);
+   for (k=0; k < v._m->Col; k++)
+      for (int m=int(_m->Row)-1; m >= 0; m--)
+      {
+	 s._m->Val[m][k] = temp._m->Val[m][_m->Col+k];
+	 for (j=m+1; j < _m->Col; j++)
+	    s._m->Val[m][k] -= temp._m->Val[m][j] * s._m->Val[j][k];
+      }
+   return s;
+}
+
+// set zero to all elements of this matrix
+MAT_TEMPLATE inline void
+matrixT::Null (const size_t& row, const size_t& col) _NO_THROW
+{
+    if (row != _m->Row || col != _m->Col)
+	realloc( row,col);
+
+    if (_m->Refcnt > 1) 
+	clone();
+
+    for (size_t i=0; i < _m->Row; i++)
+	for (size_t j=0; j < _m->Col; j++)
+	    _m->Val[i][j] = T(0);
+    return;
+}
+
+// set zero to all elements of this matrix
+MAT_TEMPLATE inline void
+matrixT::Null() _NO_THROW
+{
+    if (_m->Refcnt > 1) clone();   
+    for (size_t i=0; i < _m->Row; i++)
+	for (size_t j=0; j < _m->Col; j++)
+		_m->Val[i][j] = T(0);
+    return;
+}
+
+// set this matrix to unity
+MAT_TEMPLATE inline void
+matrixT::Unit (const size_t& row) _NO_THROW
+{
+    if (row != _m->Row || row != _m->Col)
+	realloc( row, row);
+	
+    if (_m->Refcnt > 1) 
+	clone();
+
+    for (size_t i=0; i < _m->Row; i++)
+	for (size_t j=0; j < _m->Col; j++)
+	    _m->Val[i][j] = i == j ? T(1) : T(0);
+    return;
+}
+
+// set this matrix to unity
+MAT_TEMPLATE inline void
+matrixT::Unit () _NO_THROW
+{
+    if (_m->Refcnt > 1) clone();   
+    size_t row = min(_m->Row,_m->Col);
+    _m->Row = _m->Col = row;
+
+    for (size_t i=0; i < _m->Row; i++)
+	for (size_t j=0; j < _m->Col; j++)
+	    _m->Val[i][j] = i == j ? T(1) : T(0);
+    return;
+}
+
+// private partial pivoting method
+MAT_TEMPLATE inline int
+matrixT::pivot (size_t row)
+{
+  int k = int(row);
+  double amax,temp;
+
+  amax = -1;
+  for (size_t i=row; i < _m->Row; i++)
+    if ( (temp = abs( _m->Val[i][row])) > amax && temp != 0.0)
+     {
+       amax = temp;
+       k = i;
+     }
+  if (_m->Val[k][row] == T(0))
+     return -1;
+  if (k != int(row))
+  {
+     T* rowptr = _m->Val[k];
+     _m->Val[k] = _m->Val[row];
+     _m->Val[row] = rowptr;
+     return k;
+  }
+  return 0;
+}
+
+// calculate the determinant of a matrix
+MAT_TEMPLATE inline T
+matrixT::Det () const _THROW_MATRIX_ERROR
+{
+   size_t i,j,k;
+   T piv,detVal = T(1);
+
+   if (_m->Row != _m->Col)
+      REPORT_ERROR( "matrixT::Det(): Determinant a non-square matrix!");
+   
+   matrixT temp(*this);
+   if (temp._m->Refcnt > 1) temp.clone();
+
+   for (k=0; k < _m->Row; k++)
+   {
+      int indx = temp.pivot(k);
+      if (indx == -1)
+	 return 0;
+      if (indx != 0)
+	 detVal = - detVal;
+      detVal = detVal * temp._m->Val[k][k];
+      for (i=k+1; i < _m->Row; i++)
+      {
+	 piv = temp._m->Val[i][k] / temp._m->Val[k][k];
+	 for (j=k+1; j < _m->Row; j++)
+	    temp._m->Val[i][j] -= piv * temp._m->Val[k][j];
+      }
+   }
+   return detVal;
+}
+
+// calculate the norm of a matrix
+MAT_TEMPLATE inline T
+matrixT::Norm () _NO_THROW
+{
+   T retVal = T(0);
+
+   for (size_t i=0; i < _m->Row; i++)
+      for (size_t j=0; j < _m->Col; j++)
+	 retVal += _m->Val[i][j] * _m->Val[i][j];
+   retVal = sqrt( retVal);
+
+   return retVal;
+}
+
+// calculate the condition number of a matrix
+MAT_TEMPLATE inline T
+matrixT::Cond () _NO_THROW
+{
+   matrixT inv = ! (*this);
+   return (Norm() * inv.Norm());
+}
+
+// calculate the cofactor of a matrix for a given element
+MAT_TEMPLATE inline T
+matrixT::Cofact (size_t row, size_t col) _THROW_MATRIX_ERROR
+{
+   size_t i,i1,j,j1;
+
+   if (_m->Row != _m->Col)
+      REPORT_ERROR( "matrixT::Cofact(): Cofactor of a non-square matrix!");
+
+   if (row > _m->Row || col > _m->Col)
+      REPORT_ERROR( "matrixT::Cofact(): Index out of range!");
+
+   matrixT temp (_m->Row-1,_m->Col-1);
+
+   for (i=i1=0; i < _m->Row; i++)
+   {
+      if (i == row)
+	continue;
+      for (j=j1=0; j < _m->Col; j++)
+      {
+	 if (j == col)
+	    continue;
+	 temp._m->Val[i1][j1] = _m->Val[i][j];
+	 j1++;
+      }
+      i1++;
+   }
+   T  cof = temp.Det();
+   if ((row+col)%2 == 1)
+      cof = -cof;
+
+   return cof;
+}
+
+
+// calculate adjoin of a matrix
+MAT_TEMPLATE inline matrixT
+matrixT::Adj () _THROW_MATRIX_ERROR
+{
+   if (_m->Row != _m->Col)
+      REPORT_ERROR( "matrixT::Adj(): Adjoin of a non-square matrix.");
+
+   matrixT temp(_m->Row,_m->Col);
+
+   for (size_t i=0; i < _m->Row; i++)
+      for (size_t j=0; j < _m->Col; j++)
+	  temp._m->Val[j][i] = Cofact(i,j);
+   return temp;
+}
+
+// Determine if the matrix is singular
+MAT_TEMPLATE inline bool
+matrixT::IsSingular () _NO_THROW
+{
+   if (_m->Row != _m->Col)
+      return false;
+   return (Det() == T(0));
+}
+
+// Determine if the matrix is diagonal
+MAT_TEMPLATE inline bool
+matrixT::IsDiagonal () _NO_THROW
+{
+   if (_m->Row != _m->Col)
+      return false;
+   for (size_t i=0; i < _m->Row; i++)
+     for (size_t j=0; j < _m->Col; j++)
+	if (i != j && _m->Val[i][j] != T(0))
+	  return false;
+   return true;
+}
+
+// Determine if the matrix is scalar
+MAT_TEMPLATE inline bool
+matrixT::IsScalar () _NO_THROW
+{
+   if (!IsDiagonal())
+     return false;
+   T v = _m->Val[0][0];
+   for (size_t i=1; i < _m->Row; i++)
+     if (_m->Val[i][i] != v)
+	return false;
+   return true;
+}
+
+// Determine if the matrix is a unit matrix
+MAT_TEMPLATE inline bool
+matrixT::IsUnit () _NO_THROW
+{
+   if (IsScalar() && _m->Val[0][0] == T(1))
+     return true;
+   return false;
+}
+
+// Determine if this is a null matrix
+MAT_TEMPLATE inline bool
+matrixT::IsNull () _NO_THROW
+{
+   for (size_t i=0; i < _m->Row; i++)
+      for (size_t j=0; j < _m->Col; j++)
+	 if (_m->Val[i][j] != T(0))
+	    return false;
+   return true;
+}
+
+// Determine if the matrix is symmetric
+MAT_TEMPLATE inline bool
+matrixT::IsSymmetric () _NO_THROW
+{
+   if (_m->Row != _m->Col)
+      return false;
+   for (size_t i=0; i < _m->Row; i++)
+      for (size_t j=0; j < _m->Col; j++)
+	 if (_m->Val[i][j] != _m->Val[j][i])
+	    return false;
+   return true;
+}
+	   
+// Determine if the matrix is skew-symmetric
+MAT_TEMPLATE inline bool
+matrixT::IsSkewSymmetric () _NO_THROW
+{
+   if (_m->Row != _m->Col)
+      return false;
+   for (size_t i=0; i < _m->Row; i++)
+      for (size_t j=0; j < _m->Col; j++)
+	 if (_m->Val[i][j] != -_m->Val[j][i])
+	    return false;
+   return true;
+}
+   
+// Determine if the matrix is upper triangular
+MAT_TEMPLATE inline bool
+matrixT::IsUpperTriangular () _NO_THROW
+{
+   if (_m->Row != _m->Col)
+      return false;
+   for (size_t i=1; i < _m->Row; i++)
+      for (size_t j=0; j < i-1; j++)
+	 if (_m->Val[i][j] != T(0))
+	    return false;
+   return true;
+}
+
+// Determine if the matrix is lower triangular
+MAT_TEMPLATE inline bool
+matrixT::IsLowerTriangular () _NO_THROW
+{
+   if (_m->Row != _m->Col)
+      return false;
+
+   for (size_t j=1; j < _m->Col; j++)
+      for (size_t i=0; i < j-1; i++)
+	 if (_m->Val[i][j] != T(0))
+	    return false;
+
+   return true;
+}
+
+#ifndef _NO_NAMESPACE
+} 
+#endif
+
+#endif //__STD_MATRIX_H
